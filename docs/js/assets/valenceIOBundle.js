;

function _typeof2(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof2 = function _typeof2(obj) { return typeof obj; }; } else { _typeof2 = function _typeof2(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof2(obj); }

/******/
(function (modules) {
  // webpackBootstrap

  /******/
  // The module cache

  /******/
  var installedModules = {};
  /******/

  /******/
  // The require function

  /******/

  function __webpack_require__(moduleId) {
    /******/

    /******/
    // Check if module is in cache

    /******/
    if (installedModules[moduleId]) {
      /******/
      return installedModules[moduleId].exports;
      /******/
    }
    /******/
    // Create a new module (and put it into the cache)

    /******/


    var module = installedModules[moduleId] = {
      /******/
      i: moduleId,

      /******/
      l: false,

      /******/
      exports: {}
      /******/

    };
    /******/

    /******/
    // Execute the module function

    /******/

    modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
    /******/

    /******/
    // Flag the module as loaded

    /******/

    module.l = true;
    /******/

    /******/
    // Return the exports of the module

    /******/

    return module.exports;
    /******/
  }
  /******/

  /******/

  /******/
  // expose the modules object (__webpack_modules__)

  /******/


  __webpack_require__.m = modules;
  /******/

  /******/
  // expose the module cache

  /******/

  __webpack_require__.c = installedModules;
  /******/

  /******/
  // define getter function for harmony exports

  /******/

  __webpack_require__.d = function (exports, name, getter) {
    /******/
    if (!__webpack_require__.o(exports, name)) {
      /******/
      Object.defineProperty(exports, name, {
        enumerable: true,
        get: getter
      });
      /******/
    }
    /******/

  };
  /******/

  /******/
  // define __esModule on exports

  /******/


  __webpack_require__.r = function (exports) {
    /******/
    if (typeof Symbol !== 'undefined' && Symbol.toStringTag) {
      /******/
      Object.defineProperty(exports, Symbol.toStringTag, {
        value: 'Module'
      });
      /******/
    }
    /******/


    Object.defineProperty(exports, '__esModule', {
      value: true
    });
    /******/
  };
  /******/

  /******/
  // create a fake namespace object

  /******/
  // mode & 1: value is a module id, require it

  /******/
  // mode & 2: merge all properties of value into the ns

  /******/
  // mode & 4: return value when already ns object

  /******/
  // mode & 8|1: behave like require

  /******/


  __webpack_require__.t = function (value, mode) {
    /******/
    if (mode & 1) value = __webpack_require__(value);
    /******/

    if (mode & 8) return value;
    /******/

    if (mode & 4 && _typeof2(value) === 'object' && value && value.__esModule) return value;
    /******/

    var ns = Object.create(null);
    /******/

    __webpack_require__.r(ns);
    /******/


    Object.defineProperty(ns, 'default', {
      enumerable: true,
      value: value
    });
    /******/

    if (mode & 2 && typeof value != 'string') for (var key in value) {
      __webpack_require__.d(ns, key, function (key) {
        return value[key];
      }.bind(null, key));
    }
    /******/

    return ns;
    /******/
  };
  /******/

  /******/
  // getDefaultExport function for compatibility with non-harmony modules

  /******/


  __webpack_require__.n = function (module) {
    /******/
    var getter = module && module.__esModule ?
    /******/
    function getDefault() {
      return module['default'];
    } :
    /******/
    function getModuleExports() {
      return module;
    };
    /******/

    __webpack_require__.d(getter, 'a', getter);
    /******/


    return getter;
    /******/
  };
  /******/

  /******/
  // Object.prototype.hasOwnProperty.call

  /******/


  __webpack_require__.o = function (object, property) {
    return Object.prototype.hasOwnProperty.call(object, property);
  };
  /******/

  /******/
  // __webpack_public_path__

  /******/


  __webpack_require__.p = "";
  /******/

  /******/

  /******/
  // Load entry module and return exports

  /******/

  return __webpack_require__(__webpack_require__.s = 0);
  /******/
})(
/************************************************************************/

/******/
[
/* 0 */

/***/
function (module, __webpack_exports__, __webpack_require__) {
  ;

  __webpack_require__.r(__webpack_exports__);
  /* harmony import */


  var _Valence__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1);
  /* harmony import */


  var _js_src_WebComponents_Button_Button__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(191);
  /* harmony import */


  var _js_src_WebComponents_Input_Input__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(194);
  /* harmony import */


  var _js_src_WebComponents_Grid_Container__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(196);
  /* harmony import */


  var _js_src_WebComponents_Grid_Column__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(197);
  /* harmony import */


  var _js_src_WebComponents_Grid_Row__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(199);
  /* harmony import */


  var _assets_valenceLogo__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(201);

  function _typeof(obj) {
    if (typeof Symbol === "function" && _typeof2(Symbol.iterator) === "symbol") {
      _typeof = function _typeof(obj) {
        return _typeof2(obj);
      };
    } else {
      _typeof = function _typeof(obj) {
        return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : _typeof2(obj);
      };
    }

    return _typeof(obj);
  }

  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  function _defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    return Constructor;
  }

  function _possibleConstructorReturn(self, call) {
    if (call && (_typeof(call) === "object" || typeof call === "function")) {
      return call;
    }

    return _assertThisInitialized(self);
  }

  function _assertThisInitialized(self) {
    if (self === void 0) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }

    return self;
  }

  function _getPrototypeOf(o) {
    _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
      return o.__proto__ || Object.getPrototypeOf(o);
    };
    return _getPrototypeOf(o);
  }

  function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function");
    }

    subClass.prototype = Object.create(superClass && superClass.prototype, {
      constructor: {
        value: subClass,
        writable: true,
        configurable: true
      }
    });
    if (superClass) _setPrototypeOf(subClass, superClass);
  }

  function _setPrototypeOf(o, p) {
    _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
      o.__proto__ = p;
      return o;
    };

    return _setPrototypeOf(o, p);
  }

  function _templateObject11() {
    var data = _taggedTemplateLiteral(["\n  width: 100%;\n  padding: 10px;\n  margin: auto;\n  z-index: 999;\n\n  p {\n    color: white;\n    font-family: sf mono;\n  }\n"]);

    _templateObject11 = function _templateObject11() {
      return data;
    };

    return data;
  }

  function _templateObject10() {
    var data = _taggedTemplateLiteral(["\n  position: absolute;\n  top: 55%;\n  left: 50px;\n  height: 300px;\n  width: 300px;\n  display: block;\n  padding: 5px;\n  background: grey;\n\n  div {\n    position: absolute;\n    text-align: center;\n    vertical-align: middle;\n    top: 0;\n    left: 0;\n    right: 0;\n    bottom: 0;\n    margin: 0 auto;\n    padding: 40% 0;\n    background: tomato;\n    font-size: 44px;\n    color: blue;\n    font-family: sf mono, space mono;\n    animation: ", " 2s linear infinite;\n  }\n"]);

    _templateObject10 = function _templateObject10() {
      return data;
    };

    return data;
  }

  function _templateObject9() {
    var data = _taggedTemplateLiteral(["\n  from {\n    transform: rotate(0deg);\n  }\n\n  to {\n    transform: rotate(360deg);\n  }\n"]);

    _templateObject9 = function _templateObject9() {
      return data;
    };

    return data;
  }

  function _templateObject8() {
    var data = _taggedTemplateLiteral(["\n  position: relative;\n  top: 100px;\n  background-color: ", ";\n  opacity: ", ";\n  color: white;\n  border: 2px solid ", "\n"]);

    _templateObject8 = function _templateObject8() {
      return data;
    };

    return data;
  }

  function _templateObject7() {
    var data = _taggedTemplateLiteral(["\n  position: absolute;\n  font-family: sfmono, space mono;\n  font-size: 38px;\n  width: 200px;\n  height: 38px;\n  margin: 0 auto;\n  top: 0;\n  bottom: 0;\n  right: 0;\n  left: 0;\n  background-color: orange;\n  border: none;\n  border-radius: 5px;\n  color: yellow;\n\n  @media (max-height: 400px) {\n      background: blue;\n  }\n"]);

    _templateObject7 = function _templateObject7() {
      return data;
    };

    return data;
  }

  function _templateObject6() {
    var data = _taggedTemplateLiteral(["\n  position: absolute;\n  left: 82%;\n  top: 25%;\n  height: ", ";\n  width: 200px;\n  background-color: ", ";\n  z-index: 99;\n  p {\n    color: white;\n  }\n"]);

    _templateObject6 = function _templateObject6() {
      return data;
    };

    return data;
  }

  function _templateObject5() {
    var data = _taggedTemplateLiteral(["\n  height: ", ";\n  width: 75px;\n  border: none;\n  border-radius: 7px;\n  background-color: pink;\n"]);

    _templateObject5 = function _templateObject5() {
      return data;
    };

    return data;
  }

  function _templateObject4() {
    var data = _taggedTemplateLiteral(["\n  position: absolute;\n  left: 76%;\n  top: 25%;\n  height: ", ";\n  width: 200px;\n  background: ", ";\n  z-index: 99;\n"]);

    _templateObject4 = function _templateObject4() {
      return data;
    };

    return data;
  }

  function _templateObject3() {
    var data = _taggedTemplateLiteral(["\n  position: absolute;\n  top: 50%;\n  height: 200px;\n  width: 100%;\n  margin-top: -130px;\n  padding: 30px;\n  z-index: 9;\n  background-color: transparent;\n\n  h1 {\n    color: yellow;\n    position: absolute;\n    top: -150px;\n    left: 100px;\n    text-align: center;\n    vertical-align: middle;\n    font-size: 84px;\n    font-family: sf mono;\n  }\n\n  @media (max-height: 400px) {\n    background: red;\n    border-radius: 40%;\n  }\n"]);

    _templateObject3 = function _templateObject3() {
      return data;
    };

    return data;
  }

  function _templateObject2() {
    var data = _taggedTemplateLiteral(["\n  position: absolute;\n  height: 100%;\n  width: 100%;\n  padding: 0;\n"]);

    _templateObject2 = function _templateObject2() {
      return data;
    };

    return data;
  }

  function _templateObject() {
    var data = _taggedTemplateLiteral(["\n  body {\n    background: ", "\n  }\n"]);

    _templateObject = function _templateObject() {
      return data;
    };

    return data;
  }

  function _taggedTemplateLiteral(strings, raw) {
    if (!raw) {
      raw = strings.slice(0);
    }

    return Object.freeze(Object.defineProperties(strings, {
      raw: {
        value: Object.freeze(raw)
      }
    }));
  }
  /*
  ** valenceIO.jsx
  **
  ** Javascript entry-point file for the
  ** Valence framework project Web-Site
  **
  ** Eric J Foster, MIT License.
  **
  **/
  // WebComponents .....


  _Valence__WEBPACK_IMPORTED_MODULE_0__["Valence"].assume({
    shadowByDefault: false,
    underscoreGlobal: true,
    directChildNesting: true,
    kebabCase: false,
    syntaxHighlighting: true
  });

  var blue = '#0057ff';
  var yellow = '#ffc700';
  var tomato = '#ff4500';
  var green = '#17a637';
  var coolGreen = '#669a0f';
  var grey = '#323232'; //global styles..

  styled.global(_templateObject(), grey);

  var Fluid = function Fluid() {
    return styled.div({
      className: 'container-fluid',
      id: 'hwhatthe'
    })(_templateObject2());
  };

  var Box = function Box() {
    return styled.div({
      id: 'box',
      className: 'boxy'
    })(_templateObject3());
  };

  var MyDiv = function MyDiv(_ref) {
    var shadow = _ref.shadow;
    return styled.div(_templateObject4(), shadow ? '100px' : '700px', tomato);
  }; // attribute for inner button text.....


  var Thing = function Thing(_ref2) {
    var myAtty = _ref2.myAtty;
    return styled.button({
      id: 'buttonThing',
      className: 'thang',
      type: 'submit',
      label: 'press'
    })(_templateObject5(), myAtty);
  };

  var MyDiv2 = function MyDiv2(_ref3) {
    var shadow = _ref3.shadow;
    return styled.div(_templateObject6(), shadow ? '100px' : '700px', green);
  };

  var MyInput = function MyInput() {
    return styled.input({
      placeholder: 'onsearch',
      type: 'text',
      className: 'myput'
    })(_templateObject7());
  }; //


  var Thing2 = function Thing2(_ref4) {
    var attrib = _ref4.attrib,
        shadow = _ref4.shadow;
    return styled.extend(Thing, {
      id: 'thing2',
      label: 'press me!'
    })(_templateObject8(), tomato, attrib, shadow ? 'black' : 'orange');
  };

  var rotate = styled.keyframes(_templateObject9());

  var Spinner = function Spinner() {
    return styled.div(_templateObject10(), rotate);
  };

  var Logo = function Logo() {
    return styled.div({
      cleanHTML: Object(_assets_valenceLogo__WEBPACK_IMPORTED_MODULE_6__["default"])(),
      shadow: false
    })(_templateObject11());
  };

  var inputStyles = "\n  --size: 80px\n";

  var MyName = function MyName(_ref5) {
    var className = _ref5.className,
        kebabCase = _ref5.kebabCase;
    return x("div", null, x(Box, null, x(_js_src_WebComponents_Button_Button__WEBPACK_IMPORTED_MODULE_1__["default"], {
      variant: "info",
      size: "sm"
    }, "Info"), x(_js_src_WebComponents_Button_Button__WEBPACK_IMPORTED_MODULE_1__["default"], {
      variant: "primary",
      size: "lg",
      disabled: true
    }, "Primary"), x(_js_src_WebComponents_Button_Button__WEBPACK_IMPORTED_MODULE_1__["default"], {
      variant: "secondary",
      size: "sm",
      disabled: true
    }, "Secondary"), x(_js_src_WebComponents_Button_Button__WEBPACK_IMPORTED_MODULE_1__["default"], {
      variant: "success",
      disabled: true
    }, "Success"), x(_js_src_WebComponents_Button_Button__WEBPACK_IMPORTED_MODULE_1__["default"], {
      variant: "danger",
      autofocus: true
    }, "Danger"), x(_js_src_WebComponents_Button_Button__WEBPACK_IMPORTED_MODULE_1__["default"], {
      variant: "warning",
      size: "lg"
    }, "Warning"), x(_js_src_WebComponents_Button_Button__WEBPACK_IMPORTED_MODULE_1__["default"], {
      variant: "light"
    }, "Light"), x(_js_src_WebComponents_Button_Button__WEBPACK_IMPORTED_MODULE_1__["default"], {
      variant: "dark",
      size: "lg",
      disabled: true
    }, "Dark"), x(_js_src_WebComponents_Button_Button__WEBPACK_IMPORTED_MODULE_1__["default"], {
      variant: "link"
    }, "Link"), x(_js_src_WebComponents_Input_Input__WEBPACK_IMPORTED_MODULE_2__["default"], {
      label: "Your Name:",
      labelMod: "left",
      placeholder: "Name",
      styles: inputStyles
    })));
  };

  var App =
  /*#__PURE__*/
  function (_Valence$Component) {
    _inherits(App, _Valence$Component);

    function App() {
      _classCallCheck(this, App);

      return _possibleConstructorReturn(this, _getPrototypeOf(App).call(this));
    }

    _createClass(App, [{
      key: "componentWillMount",
      value: function componentWillMount() {}
    }, {
      key: "render",
      value: function render() {
        return x(Fluid, null, x(_js_src_WebComponents_Grid_Container__WEBPACK_IMPORTED_MODULE_3__["default"], {
          "class": "contain"
        }, x(_js_src_WebComponents_Grid_Row__WEBPACK_IMPORTED_MODULE_5__["default"], {
          bumpers: "5px"
        }, x(_js_src_WebComponents_Grid_Column__WEBPACK_IMPORTED_MODULE_4__["default"], {
          "class": "on",
          cols: 12,
          md: 6
        }, "1 of 2"), x(_js_src_WebComponents_Grid_Column__WEBPACK_IMPORTED_MODULE_4__["default"], {
          "class": "tw",
          cols: 6,
          md: 4
        }, "2 of 2"), x(_js_src_WebComponents_Grid_Column__WEBPACK_IMPORTED_MODULE_4__["default"], {
          "class": "thr",
          cols: 6,
          md: 2
        }, "3 of 2")), x(_js_src_WebComponents_Grid_Row__WEBPACK_IMPORTED_MODULE_5__["default"], {
          bumpers: "5px",
          gutters: false
        }, x(_js_src_WebComponents_Grid_Column__WEBPACK_IMPORTED_MODULE_4__["default"], null, "1 of 2"), x(_js_src_WebComponents_Grid_Column__WEBPACK_IMPORTED_MODULE_4__["default"], null, "2 of 2"), x(_js_src_WebComponents_Grid_Column__WEBPACK_IMPORTED_MODULE_4__["default"], null, "3 of 2"))));
      }
    }]);

    return App;
  }(_Valence__WEBPACK_IMPORTED_MODULE_0__["Valence"].Component);

  _Valence__WEBPACK_IMPORTED_MODULE_0__["Valence"].realize(x(App, {
    myProp: "hoping",
    otherProp: 42
  }), el('#root'));
  /***/

},
/* 1 */

/***/
function (module, __webpack_exports__, __webpack_require__) {
  ;

  __webpack_require__.r(__webpack_exports__);
  /* harmony export (binding) */


  __webpack_require__.d(__webpack_exports__, "Valence", function () {
    return Valence;
  });
  /* harmony import */


  var _js_src_support_polyfillLoader__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(2);
  /* harmony import */


  var _js_src_support_polyfillLoader__WEBPACK_IMPORTED_MODULE_0___default =
  /*#__PURE__*/
  __webpack_require__.n(_js_src_support_polyfillLoader__WEBPACK_IMPORTED_MODULE_0__);
  /* harmony import */


  var _js_src_support_shimLoader__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(3);
  /* harmony import */


  var _js_src_support_shimLoader__WEBPACK_IMPORTED_MODULE_1___default =
  /*#__PURE__*/
  __webpack_require__.n(_js_src_support_shimLoader__WEBPACK_IMPORTED_MODULE_1__);
  /* harmony import */


  var _js_src_Utilities_helpers__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(4);
  /* harmony import */


  var _js_src_Utilities_DOM_el__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(32);
  /* harmony import */


  var _js_src_Utilities_Loggers__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(33);
  /* harmony import */


  var _js_src_Form_Form__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(34);
  /* harmony import */


  var _js_src_Component__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(40);
  /* harmony import */


  var _js_src_Events__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(37);
  /* harmony import */


  var _js_src_Errors_Errors__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(187);
  /* harmony import */


  var _js_src_Props_Props__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(38);
  /* harmony import */


  var _js_src_Props_PropTypes__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(39);
  /* harmony import */


  var _js_src_Flare_Flare__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(167);

  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  function _defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    return Constructor;
  }

  function _defineProperty(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }

    return obj;
  }
  /*
  Valence.js
  
  Valence is A JavaScript library for building UI's with an API resembling that
  of React, but uses Vanilla JS Web components under the hood...
  
  Eric James Foster, MIT License.
  */
  // TODO: Difference between shadow and light dom, composed and user html.
  // content etc...  What happens to children of component being use? light dom?
  // versus components shadow dom...

  /*
  Todo's
  -------*/
  //TODO: Set up observedAttributeCallbacks, if not already done.....
  //DONE?: Finish lifecycle event firings...

  /*
  [X] - componentWillMount
  [X] - componentDidMount
  [X] - shouldComponentUpdate
  [X] - componentWillReceiveProps
  [X] - componentWillUpdate
  [X] - componentDidUpdate **TWEAK: SEE Component.js line 54...
  [X] - componentWillUnmount
  
  */
  //DONE?: Figure out the native-shim ambivalence thing...
  //DONE?: Implement the polyfill & native-shim where needed...
  //DONE?: Finish coding update on setState() process, there's still an unsolved
  // problem there...
  //DONE?: Figure out the name for good, Valence or Valence or ambiValence...
  //TODO: Figure out how to integrate <slot/> and/or <content/> functionality...
  //DONE?: Implement observed attributes functionality.. Trigger effecient
  // re-rendering when certain attributes change...
  //DONE: Reformat utilities, with one main class and sub classes, IS class for ex.
  // then move on to propTypes and defaultProps...
  //DONE: refs...
  //DONE?: propTypes & defaultProps...
  //TODO: Add errors where needed...
  //TODO: Explore more of what vanilla js webcomponents can add to the framework...
  //TODO: Add some testing, Continuous Integration....
  //TODO: Make a website.. Logo.. whathaveyou...
  //TODO: Learn about proxies....
  // Get the polyfillLoader...
  // Get the nativeShimLoader...
  //Get utilities...
  // Get Virtual DOM...
  // Get Component..
  // Get events...
  // Get errors...
  // Get Props...
  // Get styles...
  // Create empty object for the library's globals.....


  window.valenceGlobals = {}; // Initializing an array for Flare component tag names...

  window.valenceGlobals.flareComponents = {};
  window.valenceGlobals.webComponents = {};
  window.valenceGlobals.valenceComponents = [];
  window.valenceGlobals.registeredComponents = []; // Initializing an array for all stateless instantiated component tag names...

  window.valenceGlobals.statelessComponents = []; // initialize global flags...

  window.valenceGlobals.webComponentsLoaded = false;
  window.valenceGlobals.rootNodeDefined = false;
  window.valenceGlobals.webComponents.flexBasisDefined = false; // Provide access to PropTypes...

  window.PropTypes = _js_src_Props_PropTypes__WEBPACK_IMPORTED_MODULE_10__["PropTypes"]; // Provide `jsx to vDOM`, x(), function...

  window.x = _js_src_Form_Form__WEBPACK_IMPORTED_MODULE_5__["Form"].x; // Globalize common utility functions...

  window.el = _js_src_Utilities_DOM_el__WEBPACK_IMPORTED_MODULE_3__["default"];
  window.dir = _js_src_Utilities_Loggers__WEBPACK_IMPORTED_MODULE_4__["_dir"];
  window.log = _js_src_Utilities_Loggers__WEBPACK_IMPORTED_MODULE_4__["_log"]; // Globalize Flare library...

  window.flare = _js_src_Flare_Flare__WEBPACK_IMPORTED_MODULE_11__["Flare"]; // The framework's API class...

  var Valence =
  /*#__PURE__*/
  function () {
    function Valence() {
      _classCallCheck(this, Valence);
    }

    _createClass(Valence, null, [{
      key: "_setAssumptions",

      /*
       * Class Properties....
       */
      // Pull in Component class for building components...
      // Attach Errors...
      // A boolean that confirms whether or not the rootComponent is mounted...
      // the node to which Valence will attach...
      // The true DOM representation of the rootNode...
      // The root Valence component...
      // The form virtual DOM instance...
      // The config options object.. with default assumptions...
      value: function _setAssumptions(assumptions) {
        // If we have the global functions option set to true.....
        if (assumptions.globalFunctions) {
          // Globalize Flare functions for convenience...
          window.global = flare.global;
          window.extend = flare.extend;
          window.keyframes = flare.keyframes; // Globalize style elements for convenience...

          window.div = flare.div;
          window.aside = flare.aside;
          window.area = flare.area;
          window.button = flare.button;
          window.col = flare.col;
          window.colgroup = flare.colgroup;
          window.header = flare.header;
          window.footer = flare.footer;
          window.input = flare.input;
          window.h1 = flare.h1;
          window.h2 = flare.h2;
          window.h3 = flare.h3;
          window.h4 = flare.h4;
          window.h5 = flare.h5;
          window.h6 = flare.h6;
          window.p = flare.p;
          window.section = flare.section;
          window.span = flare.span;
          window.table = flare.table;
          window.textarea = flare.textarea;
        } // If underscore abbreviation for global insertion option is set to true....


        if (assumptions.underscoreGlobal) {
          // Abbreviate flare.global...
          window.__ = flare.global;
        } // Syntax highlighting....


        if (assumptions.syntaxHighlighting) {
          window.styled = flare;
        }

        return assumptions;
      } // A public helper method for setting Flare assumptions, config options...

    }, {
      key: "assume",
      value: function assume(userAssumptions) {
        return Valence._setAssumptions(_js_src_Flare_Flare__WEBPACK_IMPORTED_MODULE_11__["Flare"].assume(Object(_js_src_Utilities_helpers__WEBPACK_IMPORTED_MODULE_2__["combineObjects"])(Valence._assumptions, userAssumptions)));
      } // Method for converting virtual dom to real dom...

    }, {
      key: "realize",
      value: function realize(node, root) {
        var _this = this; // Set component root and root component properties...


        this.componentRoot = root;
        this.rootNode = node;
        this.rootNode.props.rootNode = true; // Create new virtual DOM and mount the root component...

        var mount = function mount() {
          // Get new vDOM and draw tree...
          _this.form = new _js_src_Form_Form__WEBPACK_IMPORTED_MODULE_5__["Form"](_this.rootNode, root); // Give this.form to this.Component...

          _this.Component.form = _this.form; // Convert virtual DOM to actual DOM...

          _this.rootComponent = _this.form.draw(); // Mount on Valence root node...

          root.appendChild(_this.rootComponent); // Confirm component mounted...

          _this.rootComponentMounted = true;
        }; // Method for effeciently updating the UI of the Valence application. It is a
        // link to Form DOM's updateElement method...


        var update = function update() {
          return _this.form.updateDOM(root, rootNode);
        }; // If no component is mounted, mount component. Otherwise
        // update the component...


        if (!this.rootComponentMounted) {
          if (valenceGlobals.webComponentsLoaded) {
            mount();
          } else {
            document.addEventListener('webComponentsLoaded', function () {
              mount();
            });
          }
        } else {
          try {
            update();
          } catch (err) {
            console.error("UpdateError: ".concat(err.message));
          }
        }
      } // Method for unmounting the given component at the given node...

    }, {
      key: "unMount",
      value: function unMount() {
        if (this.rootComponentMounted) {
          // Fire componentWillUnmount event, then remove component...
          _js_src_Events__WEBPACK_IMPORTED_MODULE_7__["Events"].fire('componentWillUnmount', this.rootComponent);

          this.rootComponent.remove(); // Reset componentMounted flag...

          this.rootComponentMounted = false;
        } else {
          try {
            throw this.Errors.UnmountError;
          } catch (err) {
            console.error(err.message);
          }
        }
      }
    }]);

    return Valence;
  }();

  _defineProperty(Valence, "Component", _js_src_Component__WEBPACK_IMPORTED_MODULE_6__["default"]);

  _defineProperty(Valence, "Errors", _js_src_Errors_Errors__WEBPACK_IMPORTED_MODULE_8__["Errors"]);

  _defineProperty(Valence, "rootComponentMounted", false);

  _defineProperty(Valence, "componentRoot", null);

  _defineProperty(Valence, "rootComponent", null);

  _defineProperty(Valence, "rootNode", null);

  _defineProperty(Valence, "form", null);

  _defineProperty(Valence, "_assumptions", {
    cornDogCase: false
    /*
     * Class Methods...
     */
    // A private static method for setting library user assumptions...

  });
  /***/

},
/* 2 */

/***/
function (module, exports) {
  /*
  polyfillLoader.js
  
  Valence, a JavaScript library for building UI's, with an API
  resembling that of React, but uses Vanilla JS Web components
  under the hood...This file handles loading of the polyfill
  loader...
  
  Eric James Foster, MIT License.
  */
  (function () {
    // The polyfill CDN url...
    var polyfillCDN = 'https://cdn.rawgit.com/webcomponents/custom-elements/4f7072c0/custom-elements.min.js'; // A function for loading the native-shim....

    function loadPolyfill() {
      return new Promise(function (resolve, reject) {
        var // Create and config script...
        script = document.createElement('script');
        script.src = polyfillCDN;
        script.type = 'text/javascript';
        script.onload = resolve;
        script.onerror = reject; // Append to the DOM...

        document.head.append(script);
      });
    } // Check for existence of customElements API, and load shim or not...


    if (window.customElements) {
      return;
    } else {
      // Load the shim...
      loadPolyfill().then(function (result) {
        console.dir(result);
      });
    }
  })();
  /***/

},
/* 3 */

/***/
function (module, exports) {
  /*
  shimLoader.js
  
  Valence, a JavaScript library for building UI's, with an API
  resembling that of React, but uses Vanilla JS Web components
  under the hood...This file handles loading of the native-shim
  dynamic loader...
  
  Eric James Foster, MIT License.
  */
  //TODO: Get external source for shim....
  (function () {
    // native shim src...
    var shimSrc = './nativeShim.js'; // A function for loading the native-shim....

    function loadNativeShim() {
      return new Promise(function (resolve, reject) {
        var // Create and config script...
        script = document.createElement('script');
        script.src = shimSrc;
        script.onload = resolve;
        script.onerror = reject; // Append to the DOM just after the previously loaded inline script...

        document.head.append(script);
      });
    } // Check for existence of customElements API, and load shim or not...


    if (!window.customElements) {
      return;
    } else {
      // Load the shim...
      loadNativeShim().then(function (result) {
        console.dir(result); // Confirm load with following function that is defined on the window object
        // in the shim...

        supportLoaded();
      });
    }
  })();
  /***/

},
/* 4 */

/***/
function (module, __webpack_exports__, __webpack_require__) {
  ;

  __webpack_require__.r(__webpack_exports__);
  /* harmony export (binding) */


  __webpack_require__.d(__webpack_exports__, "flareComponentNamesRE", function () {
    return flareComponentNamesRE;
  });
  /* harmony export (binding) */


  __webpack_require__.d(__webpack_exports__, "piper", function () {
    return piper;
  });
  /* harmony export (binding) */


  __webpack_require__.d(__webpack_exports__, "propNames", function () {
    return propNames;
  });
  /* harmony export (binding) */


  __webpack_require__.d(__webpack_exports__, "propsArray", function () {
    return propsArray;
  });
  /* harmony export (binding) */


  __webpack_require__.d(__webpack_exports__, "lowerCaseListeners3", function () {
    return lowerCaseListeners3;
  });
  /* harmony export (binding) */


  __webpack_require__.d(__webpack_exports__, "lowerCaseListeners2", function () {
    return lowerCaseListeners2;
  });
  /* harmony export (binding) */


  __webpack_require__.d(__webpack_exports__, "lowerCaseListeners1", function () {
    return lowerCaseListeners1;
  });
  /* harmony export (binding) */


  __webpack_require__.d(__webpack_exports__, "isolateEventListeners", function () {
    return isolateEventListeners;
  });
  /* harmony export (binding) */


  __webpack_require__.d(__webpack_exports__, "sansON", function () {
    return sansON;
  });
  /* harmony export (binding) */


  __webpack_require__.d(__webpack_exports__, "removePrefixFromListeners", function () {
    return removePrefixFromListeners;
  });
  /* harmony export (binding) */


  __webpack_require__.d(__webpack_exports__, "removeEventListeners", function () {
    return removeEventListeners;
  });
  /* harmony export (binding) */


  __webpack_require__.d(__webpack_exports__, "removeExistingAttributes", function () {
    return removeExistingAttributes;
  });
  /* harmony export (binding) */


  __webpack_require__.d(__webpack_exports__, "processEventListeners", function () {
    return processEventListeners;
  });
  /* harmony export (binding) */


  __webpack_require__.d(__webpack_exports__, "extractCustomProps", function () {
    return extractCustomProps;
  });
  /* harmony export (binding) */


  __webpack_require__.d(__webpack_exports__, "extractCustomPropNames", function () {
    return extractCustomPropNames;
  });
  /* harmony export (binding) */


  __webpack_require__.d(__webpack_exports__, "processProps", function () {
    return processProps;
  });
  /* harmony export (binding) */


  __webpack_require__.d(__webpack_exports__, "processData", function () {
    return processData;
  });
  /* harmony export (binding) */


  __webpack_require__.d(__webpack_exports__, "_shishKebab", function () {
    return _shishKebab;
  });
  /* harmony export (binding) */


  __webpack_require__.d(__webpack_exports__, "convertFuncNameToTagName", function () {
    return convertFuncNameToTagName;
  });
  /* harmony export (binding) */


  __webpack_require__.d(__webpack_exports__, "extractFunctionName", function () {
    return extractFunctionName;
  });
  /* harmony export (binding) */


  __webpack_require__.d(__webpack_exports__, "combineObjects", function () {
    return combineObjects;
  });
  /* harmony export (binding) */


  __webpack_require__.d(__webpack_exports__, "capitalizeAndRemoveHyphen", function () {
    return capitalizeAndRemoveHyphen;
  });
  /* harmony export (binding) */


  __webpack_require__.d(__webpack_exports__, "uniqueCustomEventString", function () {
    return uniqueCustomEventString;
  });
  /* harmony export (binding) */


  __webpack_require__.d(__webpack_exports__, "included", function () {
    return included;
  });
  /* harmony export (binding) */


  __webpack_require__.d(__webpack_exports__, "template", function () {
    return template;
  });
  /* harmony export (binding) */


  __webpack_require__.d(__webpack_exports__, "replicator", function () {
    return replicator;
  });
  /* harmony export (binding) */


  __webpack_require__.d(__webpack_exports__, "splitFilter", function () {
    return splitFilter;
  });
  /* harmony export (binding) */


  __webpack_require__.d(__webpack_exports__, "reAssembleTemplates", function () {
    return reAssembleTemplates;
  });
  /* harmony export (binding) */


  __webpack_require__.d(__webpack_exports__, "applyInterpolations", function () {
    return applyInterpolations;
  });
  /* harmony export (binding) */


  __webpack_require__.d(__webpack_exports__, "separateStyleRules", function () {
    return separateStyleRules;
  });
  /* harmony export (binding) */


  __webpack_require__.d(__webpack_exports__, "deeplicateObj", function () {
    return deeplicateObj;
  });
  /* harmony import */


  var _data__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(5);
  /* harmony import */


  var _Is__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(6);
  /* harmony import */


  var lodash_words__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(7);
  /* harmony import */


  var lodash_words__WEBPACK_IMPORTED_MODULE_2___default =
  /*#__PURE__*/
  __webpack_require__.n(lodash_words__WEBPACK_IMPORTED_MODULE_2__);
  /* harmony import */


  var elementsJS__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(24);
  /* harmony import */


  var elementsJS__WEBPACK_IMPORTED_MODULE_3___default =
  /*#__PURE__*/
  __webpack_require__.n(elementsJS__WEBPACK_IMPORTED_MODULE_3__);
  /* harmony reexport (safe) */


  __webpack_require__.d(__webpack_exports__, "el", function () {
    return elementsJS__WEBPACK_IMPORTED_MODULE_3__["el"];
  });
  /* harmony reexport (safe) */


  __webpack_require__.d(__webpack_exports__, "dom", function () {
    return elementsJS__WEBPACK_IMPORTED_MODULE_3__["dom"];
  });
  /* harmony reexport (safe) */


  __webpack_require__.d(__webpack_exports__, "log", function () {
    return elementsJS__WEBPACK_IMPORTED_MODULE_3__["log"];
  });

  function _typeof(obj) {
    if (typeof Symbol === "function" && _typeof2(Symbol.iterator) === "symbol") {
      _typeof = function _typeof(obj) {
        return _typeof2(obj);
      };
    } else {
      _typeof = function _typeof(obj) {
        return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : _typeof2(obj);
      };
    }

    return _typeof(obj);
  }

  function _objectSpread(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i] != null ? arguments[i] : {};
      var ownKeys = Object.keys(source);

      if (typeof Object.getOwnPropertySymbols === 'function') {
        ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) {
          return Object.getOwnPropertyDescriptor(source, sym).enumerable;
        }));
      }

      ownKeys.forEach(function (key) {
        _defineProperty(target, key, source[key]);
      });
    }

    return target;
  }

  function _defineProperty(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }

    return obj;
  }
  /*
  Utilities.js
  
  A file containing utility functions to aid in the functional
  nature of Valence...
  
  Eric James Foster, MIT License.
  */
  // Get data...
  // Get Is...
  // Get words from lodash...
  // Get and send some utils from elementsJS...
  // a Regular expression for extracting component names from a function's
  // source code...


  var flareComponentNamesRE = function flareComponentNamesRE() {
    return /(\([A-Z]\w*-?)+/g;
  };

  var piper = function piper() {
    for (var _len = arguments.length, fns = new Array(_len), _key = 0; _key < _len; _key++) {
      fns[_key] = arguments[_key];
    }

    return function (arg) {
      return fns.reduce(function (value, fn) {
        return fn(value);
      }, arg);
    };
  }; // Returns an array of prop names...


  var propNames = function propNames(props) {
    return Object.keys(props);
  }; // Get an array of key value pairs from the attributes object...


  var propsArray = function propsArray(attribs) {
    return Object.entries(attribs);
  }; // Create a new array with all event listeners lower-cased...


  var lowerCaseListeners3 = function lowerCaseListeners3(arr) {
    return arr.map(function (entry) {
      return [entry[0].toLowerCase(), entry[0], entry[1]];
    });
  }; // Create a new array with all event listeners lower-cased...


  var lowerCaseListeners2 = function lowerCaseListeners2(arr) {
    return arr.map(function (entry) {
      return [entry[0].toLowerCase(), entry[1]];
    });
  }; // Create a new array with all event listeners lower-cased...


  var lowerCaseListeners1 = function lowerCaseListeners1(arr) {
    return arr.map(function (entry) {
      return entry.toLowerCase();
    });
  }; // Create a new array with event listeners and their callback functions...


  var isolateEventListeners = function isolateEventListeners(arr) {
    return arr.filter(function (entry) {
      return _data__WEBPACK_IMPORTED_MODULE_0__["DATA"].DOMElementEvents.indexOf(entry[0]) != -1;
    });
  }; // A function for removing the `on` from event listeners...


  var sansON = function sansON(name) {
    return name.slice(2).toLowerCase();
  }; // Create a new array with the `on` removed from the event listener names...


  var removePrefixFromListeners = function removePrefixFromListeners(arr) {
    return arr.map(function (entry) {
      return [sansON(entry[0]), entry[1], entry[2]];
    });
  }; // Create a new array without the  event listeners and their callback functions...


  var removeEventListeners = function removeEventListeners(arr) {
    return arr.filter(function (entry) {
      return _data__WEBPACK_IMPORTED_MODULE_0__["DATA"].DOMElementEvents.indexOf(_Is__WEBPACK_IMPORTED_MODULE_1__["Is"].array(entry) ? entry[0] : entry) == -1;
    });
  }; // Remove non-custom attributes...


  var removeExistingAttributes = function removeExistingAttributes(arr) {
    return arr.filter(function (entry) {
      return _data__WEBPACK_IMPORTED_MODULE_0__["DATA"].HTMLAttributes.indexOf(_Is__WEBPACK_IMPORTED_MODULE_1__["Is"].array(entry) ? entry[0] : entry) == -1;
    });
  }; // Process event listener attributes...


  var processEventListeners = function processEventListeners(arr) {
    return piper(lowerCaseListeners3, isolateEventListeners, removePrefixFromListeners)(arr);
  }; // Process attribute data...


  var extractCustomProps = function extractCustomProps(arr) {
    return piper(lowerCaseListeners2, removeEventListeners, removeExistingAttributes)(arr);
  }; // Process attribute data...


  var extractCustomPropNames = function extractCustomPropNames(arr) {
    return piper(lowerCaseListeners1, removeEventListeners, removeExistingAttributes)(arr);
  }; // NOT CURRENTLY IN USE...
  // Process attribute data...


  var processProps = function processProps(arr) {
    return piper(lowerCaseListeners2, removeEventListeners)(arr);
  }; // Create an object from the isolated event listener array, and the array width
  // the listeners removed...


  var processData = function processData(arr) {
    return {
      // The following object contains 2 arrays, 1 of the event listener attributes, appendChild
      // one of the remaining attributes...
      'eventListeners': processEventListeners(arr),
      'props': extractCustomProps(arr)
    };
  }; // A function for converting a unicode string into a kebabCase string...


  var _shishKebab = function _shishKebab(string) {
    return lodash_words__WEBPACK_IMPORTED_MODULE_2___default()(string).reduce(function (result, word, ix) {
      return result + (ix ? '-' : '') + word.toLowerCase();
    }, '');
  }; // A function for converting the func name to a custom tag name...


  var convertFuncNameToTagName = function convertFuncNameToTagName(func) {
    var cornDog = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
    return _shishKebab(func).indexOf('-') !== -1 && cornDog ? _shishKebab(func) : "".concat(func.toLowerCase(), "-");
  }; // NO LONGER USED: Use Function.name instead... duh..
  // Function for extracting the func name from the function statement of the
  // function that called createElement...


  var extractFunctionName = function extractFunctionName(element) {
    return functionRegExp.exec(element.toString()).toString().replace(functArgRegExp, '');
  }; // A function for combining to Props objects into 1 new object...


  var combineObjects = function combineObjects(obj1, obj2) {
    return _objectSpread({}, obj1, obj2);
  }; // Removes the hyphen at the end of the component tag name...


  var capitalizeAndRemoveHyphen = function capitalizeAndRemoveHyphen(name) {
    return name[0].toUpperCase() + name.slice(1, name.length - 1);
  }; // Creates a unique custom event string for individual flare element instantiation
  // notification...


  var uniqueCustomEventString = function uniqueCustomEventString(tagName) {
    return "flare".concat(capitalizeAndRemoveHyphen(tagName), "ElementInstantiated");
  }; // A small helper function for determining if a given string is in a given array..


  var included = function included(string, array) {
    if (array.indexOf(string) > 0) {
      return true;
    } else {
      return false;
    }
  }; // A node.js code templating function. The function takes a string of code, and
  // an object containing replacement values.


  var template = function template(obj, code) {
    // Replacement regexp...
    var replaceRE = /\|\|\w+\|\|/,
        variableRE = /\w+/,
        variable,
        tuple,
        match,
        temp; // If we find a replacement match,

    if (replaceRE.test(code)) {
      // store it...
      match = replaceRE.exec(code)[1]; // extract the variable from the match...

      variable = variableRE.exec(match)[1]; // Replace it in the original code with...

      temp = code.replace(match, variable); // Call function again to be sure we don't have anymore matches...

      template(temp, obj);
    } else {
      // load tuple with UppercaseName and code...
      tuple.push(obj.UppercaseName);
      tuple.push(code);
      return tuple;
    }
  }; // A node.js function for filling out and returning in an array, templates, given an array
  // of replacement objects and a template....


  var replicator = function replicator(objArray, template) {
    var loaded, loadedArray; // Load each template using the above template function...

    objArray.forEach(function (obj) {
      loaded = loader(obj, template);
      loadedArray.push(loaded);
    }); // Return the array...

    return loadedArray;
  };
  /* An array filter function, which splits the array into 2 new arrays.. Those that
  agree with the given boolean, and those that do not...*/


  var splitFilter = function splitFilter(array, bool) {
    var t = [],
        f = []; // Iterate over the array...

    array.forEach(function (i) {
      if (bool(i)) {
        t.push(i);
      } else {
        f.push(i);
      }
    }); // Return an object containing both arrays...

    return {
      "true": t,
      "false": f
    };
  };
  /* A helper function for processing tagged template literal interpolation functions,
  and inserting their values back into the template.... The function takes an array
  of strings and an array of functions as arguments, and returns the completed
  template string....*/


  var reAssembleTemplates = function reAssembleTemplates(arrStrings, arrFuncs, props) {
    return (// We need to execute them with the props object, and add the value into the template...
      arrStrings.map(function (string, i) {
        var val;
        /*
        Since the interpolation functions (refs) array will always be 1 shorter in length than
        the strings array, The last index will be undefined if we are iterating based on 'string's'
        indeces. So, we make sure that  we don't try to execute an undefined function by skipping
        the last index.....
        */

        if (i < arrStrings.length - 1) {
          // If we have a function...
          if (typeof arrFuncs[i] === 'function') {
            // Execute it with props passed in...
            val = arrFuncs[i](props); // Or, if we have a string...
          } else if (typeof arrFuncs[i] === 'string') {
            // We can just insert it into the template....
            val = arrFuncs[i]; // Otherwise, I don't know what the hell we're dealing with..... Better off
            // throwing an error!
          } else {
            throw TypeError("Expecting a 'string' or a 'function' here. A value of type: ".concat(_typeof(arrFuncs[i]), ", was given."));
          }
        } else {
          val = ' ';
        } // Add ref function values to array strings, join them...


        return string.concat('', val);
      }).join('')
    );
  };
  /*
  A combination of two of the above functions, this function serves to activate prop
  function interpolations in css styling... The function simply takes a tagged template
  literal as an argument, and spits out completed styles, ready for appending to a style tag...
  */


  var applyInterpolations = function applyInterpolations(taggedTempLit, props) {
    // Declare var for splitting strings and functions into respective arrays...
    var arrays = splitFilter(taggedTempLit, function (index) {
      return _Is__WEBPACK_IMPORTED_MODULE_1__["Is"].array(index);
    }); // Reassemble the css literals...

    return reAssembleTemplates(arrays["true"][0], arrays["false"], props);
  };
  /*
  A helper function that takes a string containing css rules and splits them up
  into individual rule/strings and appends them to an array. An array of rules
  is returned...*/


  var separateStyleRules = function separateStyleRules(css) {
    return (// Below we are using a regular expression, returning an array of all of it's matches....
      css.match(/[^\s\{][^\{]*\{[^\}]*\}/g)
    );
  }; // A simple trick to deep copy an object....
  //NOTE: This will now work on an object with methods....


  var deeplicateObj = function deeplicateObj(obj) {
    // Get a shallow copy of given obj. 2nd level, and beyond, objects will be copied later..
    var newObj = JSON.parse(JSON.stringify(obj)); // Recursive deeper level object copier...

    var reCopier = function reCopier(newie, oldie) {
      // Iterate over the object to be copied...
      for (key in oldie) {
        // Manually copy in all functions, regexp's...
        if (typeof oldie[key] === 'function' || oldie[key] instanceof RegExp) {
          newie[key] = oldie[key];
        } // Deal with arrays...


        if (Array.isArray(oldie[key])) {
          newie[key] = Array.from(oldie[key]);
        } // Recursively copy in all objects, save nulls, regexp's and arrays...


        if (_typeof(oldie[key]) === 'object' && !(oldie[key] instanceof RegExp) && oldie[key] !== null && !_Is__WEBPACK_IMPORTED_MODULE_1__["Is"].array(oldie[key])) {
          // Copy away...
          newie[key] = Object.assign({}, oldie[key]);
          reCopier(newie[key], oldie[key]);
        }
      }

      return newie;
    };

    return reCopier(newObj, obj);
  };
  /***/

},
/* 5 */

/***/
function (module, __webpack_exports__, __webpack_require__) {
  ;

  __webpack_require__.r(__webpack_exports__);
  /* harmony export (binding) */


  __webpack_require__.d(__webpack_exports__, "DATA", function () {
    return DATA;
  });
  /*
  data.js
  
  A file to hold information about HTML
  Elements...
  
  Eric James Foster, MIT License.
  */


  var DATA = {
    DOMElementEvents: ['onabort', 'onauxclick', 'onbeforecopy', 'onbeforecut', 'onbeforepaste', 'onblur', 'oncancel', 'oncanplay', 'oncanplaythrough', 'onchange', 'onclick', 'onclose', 'oncontextmenu', 'oncopy', 'oncuechange', 'oncut', 'ondblclick', 'ondrag', 'ondragend', 'ondragenter', 'ondragleave', 'ondragover', 'ondragstart', 'ondrop', 'ondurationchange', 'onemptied', 'onended', 'onerror', 'onfocus', 'ongotpointercapture', 'oninput', 'oninvalid', 'onkeydown', 'onkeypress', 'onkeyup', 'onload', 'onloadeddata', 'onloadedmetadata', 'onloadstart', 'onlostpointercapture', 'onmousedown', 'onmouseenter', 'onmouseleave', 'onmousemove', 'onmouseout', 'onmouseover', 'onmouseup', 'onmousewheel', 'onpaste', 'onpause', 'onplay', 'onplaying', 'onpointercancel', 'onpointerdown', 'onpointerenter', 'onpointerleave', 'onpointermove', 'onpointerout', 'onpointerover', 'onpointerup', 'onprogress', 'onratechange', 'onreset', 'onresize', 'onscroll', 'onsearch', 'onseeked', 'onseeking', 'onselect', 'onselectstart', 'onstalled', 'onsubmit', 'onsuspend', 'ontimeupdate', 'ontoggle', 'onvolumechange', 'onwaiting', 'onwebkitfullscreenchange', 'onwebkitfullscreenerror', 'onwheel'],
    HTMLAttributes: ['accept', 'accept-charset', 'accesskey', 'action', 'align', 'alt', 'async', 'autocomplete', 'autofocus', 'autoplay', 'bgcolor', 'border', 'charset', 'checked', 'cite', 'class', 'classname', 'color', 'cols', 'colspan', 'content', 'contenteditable', 'contextmenu', 'controls', 'coords', 'data', 'datetime', 'default', 'defer', 'dir', 'dirname', 'disabled', 'download', 'draggable', 'dropzone', 'enctype', 'for', 'form', 'formaction', 'headers', 'height', 'hidden', 'high', 'href', 'hreflang', 'http-equiv', 'id', 'ismap', 'kind', 'label', 'lang', 'list', 'loop', 'low', 'max', 'maxlength', 'media', 'method', 'min', 'multiple', 'muted', 'name', 'novalidate', 'onabort', 'onafterprint', 'onbeforeprint', 'onbeforeunload', 'onblur', 'oncanplay', 'oncanplaythrough', 'onchange', 'onclick', 'oncontextmenu', 'oncopy', 'oncuechange', 'oncut', 'ondblclick', 'ondrag', 'ondragend', 'ondragenter', 'ondragleave', 'ondragover', 'ondragstart', 'ondrop', 'ondurationchange', 'onemptied', 'onended', 'onerror', 'onfocus', 'onhashchange', 'oninput', 'oninvalid', 'onkeydown', 'onkeypress', 'onkeyup', 'onload', 'onloadeddata', 'onloadedmetadata', 'onloadstart', 'onmousedown', 'onmousemove', 'onmouseout', 'onmouseover', 'onmouseup', 'onmousewheel', 'onoffline', 'ononline', 'onpagehide', 'onpageshow', 'onpaste', 'onpause', 'onplay', 'onplaying', 'onpopstate', 'onprogress', 'onratechange', 'onreset', 'onresize', 'onscroll', 'onsearch', 'onseeked', 'onseeking', 'onselect', 'onshow', 'onst', 'onstorage', 'onsubmit', 'onsuspend', 'ontimeupdate', 'ontoggle', 'onunload', 'onvolumechange', 'onwaiting', 'onwheel', 'open', 'optimum', 'pattern', 'placeholder', 'poster', 'preload', 'readonly', 'rel', 'required', 'reversed', 'rows', 'rowspan', 'sandbox', 'scope', 'scoped', 'selected', 'shape', 'size', 'sizes', 'span', 'spellcheck', 'src', 'srcdoc', 'srclang', 'srcset', 'start', 'step', 'style', 'tabindex', 'target', 'title', 'translate', 'type', 'usemap', 'value', 'width', 'wrap'],
    ComponentLifecycleEvents: ['componentWillMount', 'componentWillUnmount', 'componentDidMount', 'componentDidUnmount', 'componentWillUpdate', 'componentDidUpdate', 'componentWillReceiveProps'],
    flareComponentElements: [{
      UppercaseName: 'Area',
      name: 'area'
    }, {
      UppercaseName: 'Col',
      name: 'col'
    }, {
      UppercaseName: 'Aside',
      name: 'aside'
    }, {
      UppercaseName: 'Colgroup',
      name: 'colgroup'
    }, {
      UppercaseName: 'Footer',
      name: 'footer'
    }, {
      UppercaseName: 'Header',
      name: 'header'
    }, {
      UppercaseName: 'H2',
      name: 'h2'
    }, {
      UppercaseName: 'H3',
      name: 'h3'
    }, {
      UppercaseName: 'H4',
      name: 'h4'
    }, {
      UppercaseName: 'H5',
      name: 'h5'
    }, {
      UppercaseName: 'H6',
      name: 'h6'
    }, {
      UppercaseName: 'Section',
      name: 'section'
    }, {
      UppercaseName: 'Span',
      name: 'span'
    }, {
      UppercaseName: 'Table',
      name: 'table'
    }, {
      UppercaseName: 'Textarea',
      name: 'textarea'
    }]
  };
  /***/
},
/* 6 */

/***/
function (module, __webpack_exports__, __webpack_require__) {
  ;

  __webpack_require__.r(__webpack_exports__);
  /* harmony export (binding) */


  __webpack_require__.d(__webpack_exports__, "Is", function () {
    return Is;
  });
  /* harmony export (binding) */


  __webpack_require__.d(__webpack_exports__, "isEventListener", function () {
    return isEventListener;
  });
  /* harmony export (binding) */


  __webpack_require__.d(__webpack_exports__, "isNewPropName", function () {
    return isNewPropName;
  });
  /* harmony export (binding) */


  __webpack_require__.d(__webpack_exports__, "isNewFunction", function () {
    return isNewFunction;
  });
  /* harmony export (binding) */


  __webpack_require__.d(__webpack_exports__, "isUndefined", function () {
    return isUndefined;
  });
  /* harmony export (binding) */


  __webpack_require__.d(__webpack_exports__, "isObject", function () {
    return isObject;
  });
  /* harmony export (binding) */


  __webpack_require__.d(__webpack_exports__, "isNumber", function () {
    return isNumber;
  });
  /* harmony export (binding) */


  __webpack_require__.d(__webpack_exports__, "isString", function () {
    return isString;
  });
  /* harmony export (binding) */


  __webpack_require__.d(__webpack_exports__, "isFunction", function () {
    return isFunction;
  });
  /* harmony export (binding) */


  __webpack_require__.d(__webpack_exports__, "isFunc", function () {
    return isFunc;
  });
  /* harmony export (binding) */


  __webpack_require__.d(__webpack_exports__, "isSymbol", function () {
    return isSymbol;
  });
  /* harmony export (binding) */


  __webpack_require__.d(__webpack_exports__, "isBoolean", function () {
    return isBoolean;
  });
  /* harmony export (binding) */


  __webpack_require__.d(__webpack_exports__, "isClass", function () {
    return isClass;
  });
  /* harmony export (binding) */


  __webpack_require__.d(__webpack_exports__, "isComponent", function () {
    return isComponent;
  });
  /* harmony export (binding) */


  __webpack_require__.d(__webpack_exports__, "isArray", function () {
    return isArray;
  });
  /* harmony export (binding) */


  __webpack_require__.d(__webpack_exports__, "isKin", function () {
    return isKin;
  });
  /* harmony export (binding) */


  __webpack_require__.d(__webpack_exports__, "isRequiredProp", function () {
    return isRequiredProp;
  });
  /* harmony export (binding) */


  __webpack_require__.d(__webpack_exports__, "isInterpolated", function () {
    return isInterpolated;
  });
  /* harmony export (binding) */


  __webpack_require__.d(__webpack_exports__, "isValence", function () {
    return isValence;
  });
  /* harmony export (binding) */


  __webpack_require__.d(__webpack_exports__, "isFlareComponent", function () {
    return isFlareComponent;
  });
  /* harmony export (binding) */


  __webpack_require__.d(__webpack_exports__, "isFlare", function () {
    return isFlare;
  });
  /* harmony import */


  var _data__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(5);

  function _typeof(obj) {
    if (typeof Symbol === "function" && _typeof2(Symbol.iterator) === "symbol") {
      _typeof = function _typeof(obj) {
        return _typeof2(obj);
      };
    } else {
      _typeof = function _typeof(obj) {
        return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : _typeof2(obj);
      };
    }

    return _typeof(obj);
  }

  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  function _defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    return Constructor;
  }
  /*
  Is.js
  
  A file containing a small type checking utility library...
  
  Eric James Foster, MIT License.
  */
  // Get data...


  var Is =
  /*#__PURE__*/
  function () {
    function Is() {
      _classCallCheck(this, Is);
    }

    _createClass(Is, null, [{
      key: "eventListener",
      // Determines whether or not a prop is an event listener...
      value: function eventListener(name) {
        return /on[A-Z]\w*/g.test(name) || _data__WEBPACK_IMPORTED_MODULE_0__["DATA"].DOMElementEvents.indexOf(name.toLowerCase()) !== -1;
      } // Determines whether or not an attribute name is custom or not...

    }, {
      key: "newPropName",
      value: function newPropName() {
        return _data__WEBPACK_IMPORTED_MODULE_0__["DATA"].HTMLAttributes.indexOf(name.toLowerCase()) === -1;
      } // NOT CURRENTLY IN USE...
      // A boolean function for determining if a func has called for the first time...

    }, {
      key: "newFunction",
      value: function newFunction(funcs, func) {
        return funcs.indexOf(func) == -1;
      } // Simple convenience function for determining if a value is
      // undefined or not...

    }, {
      key: "undefined",
      value: function undefined(val) {
        return typeof val === 'undefined';
      } // Simple convenience function for determining if a value is
      // an object or not...

    }, {
      key: "object",
      value: function object(val) {
        return _typeof(val) === 'object';
      } // Simple convenience function for determining if a value is
      // a number or not...

    }, {
      key: "number",
      value: function number(val) {
        return typeof val === 'number';
      } // Simple convenience function for determining if a value is
      // a string or not...

    }, {
      key: "string",
      value: function string(val) {
        return typeof val === 'string';
      } // Simple convenience function for determining if a value is
      // a function or not...

    }, {
      key: "function",
      value: function _function(val) {
        return typeof val === 'function';
      } // A copy of the above function with a different name... I have my reasons....

    }, {
      key: "func",
      value: function func(val) {
        return typeof val === 'function';
      } // Simple convenience function for determining if a value is
      // a symbol or not...

    }, {
      key: "symbol",
      value: function symbol(val) {
        return _typeof(val) === 'symbol';
      } // Simple convenience function for determining if a value is
      // a boolean or not...

    }, {
      key: "boolean",
      value: function _boolean(val) {
        return typeof val === 'boolean';
      } // A simple convenience function for determining if a value is
      // a class or not...

    }, {
      key: "class",
      value: function _class(val) {
        return /_classCallCheck/.test(String(val));
      } // A simple convenience function for determining if a value is
      // a component or not...

    }, {
      key: "component",
      value: function component(tagName) {
        return !tagName.indexOf('-') === -1 && true;
      } // A simple convenience function for determining if a value is
      // a function or not...

    }, {
      key: "array",
      value: function array(val) {
        return Array.isArray(val);
      } // A function for confirming same type...

    }, {
      key: "kin",
      value: function kin(val1, val2) {
        return _typeof(val1) === _typeof(val2);
      } // A function for determining whether or not a propType is Required...

    }, {
      key: "requiredProp",
      value: function requiredProp(types) {
        return types.length === 1;
      } // A function for determining if a tagged template literal has interpolations...

    }, {
      key: "interpolated",
      value: function interpolated(tagTempLit) {
        return tagTempLit.length > 1;
      }
      /* A function for determining whether or not a component is a
      valence component ... */

    }, {
      key: "valenceComponent",
      value: function valenceComponent(tag) {
        return window.valenceComponents.indexOf(tag) !== -1;
      }
      /* A function for determining whether or not a component is
      a flare component... */

    }, {
      key: "flareComponent",
      value: function flareComponent(tag) {
        return window.flareComponents.indexOf(tag) !== -1;
      }
      /* A function for determining whether or not a component is
      a flare component... */

    }, {
      key: "flare",
      value: function flare(node) {
        // Regular expression for determination...
        var flareFuncRE = /_templateObject/g,
            funcSourceCode; // Do your thing.....

        if (typeof node === 'undefined') {
          return false; // If we have a node.type....
        } else if (node !== undefined && node.type !== undefined) {
          funcSourceCode = node.type.toString(); // Test the regexp....

          if (flareFuncRE.test(funcSourceCode)) {
            return true;
          } else {
            return false;
          }
        } else {
          // If we already have a node.tag, go ahead and return true....
          if (node.tag) {
            return true;
          }

          return false;
        }
      }
    }]);

    return Is;
  }();

  var isEventListener = Is.eventListener;
  var isNewPropName = Is.newPropName;
  var isUndefined = Is.undefined;
  var isObject = Is.object;
  var isNumber = Is.number;
  var isString = Is.string;
  var isFunction = Is["function"];
  var isNewFunction = Is.newFunction;
  var isFunc = Is.func;
  var isSymbol = Is.symbol;
  var isBoolean = Is["boolean"];
  var isClass = Is["class"];
  var isComponent = Is.component;
  var isArray = Is.array;
  var isKin = Is.kin;
  var isRequiredProp = Is.requiredProp;
  var isInterpolated = Is.interpolated;
  var isValence = Is.valenceComponent;
  var isFlareComponent = Is.flareComponent;
  var isFlare = Is.flare;
  /***/
},
/* 7 */

/***/
function (module, exports, __webpack_require__) {
  var asciiWords = __webpack_require__(8),
      hasUnicodeWord = __webpack_require__(9),
      toString = __webpack_require__(10),
      unicodeWords = __webpack_require__(23);
  /**
   * Splits `string` into an array of its words.
   *
   * @static
   * @memberOf _
   * @since 3.0.0
   * @category String
   * @param {string} [string=''] The string to inspect.
   * @param {RegExp|string} [pattern] The pattern to match words.
   * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
   * @returns {Array} Returns the words of `string`.
   * @example
   *
   * _.words('fred, barney, & pebbles');
   * // => ['fred', 'barney', 'pebbles']
   *
   * _.words('fred, barney, & pebbles', /[^, ]+/g);
   * // => ['fred', 'barney', '&', 'pebbles']
   */


  function words(string, pattern, guard) {
    string = toString(string);
    pattern = guard ? undefined : pattern;

    if (pattern === undefined) {
      return hasUnicodeWord(string) ? unicodeWords(string) : asciiWords(string);
    }

    return string.match(pattern) || [];
  }

  module.exports = words;
  /***/
},
/* 8 */

/***/
function (module, exports) {
  /** Used to match words composed of alphanumeric characters. */
  var reAsciiWord = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;
  /**
   * Splits an ASCII `string` into an array of its words.
   *
   * @private
   * @param {string} The string to inspect.
   * @returns {Array} Returns the words of `string`.
   */

  function asciiWords(string) {
    return string.match(reAsciiWord) || [];
  }

  module.exports = asciiWords;
  /***/
},
/* 9 */

/***/
function (module, exports) {
  /** Used to detect strings that need a more robust regexp to match words. */
  var reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;
  /**
   * Checks if `string` contains a word composed of Unicode symbols.
   *
   * @private
   * @param {string} string The string to inspect.
   * @returns {boolean} Returns `true` if a word is found, else `false`.
   */

  function hasUnicodeWord(string) {
    return reHasUnicodeWord.test(string);
  }

  module.exports = hasUnicodeWord;
  /***/
},
/* 10 */

/***/
function (module, exports, __webpack_require__) {
  var baseToString = __webpack_require__(11);
  /**
   * Converts `value` to a string. An empty string is returned for `null`
   * and `undefined` values. The sign of `-0` is preserved.
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to convert.
   * @returns {string} Returns the converted string.
   * @example
   *
   * _.toString(null);
   * // => ''
   *
   * _.toString(-0);
   * // => '-0'
   *
   * _.toString([1, 2, 3]);
   * // => '1,2,3'
   */


  function toString(value) {
    return value == null ? '' : baseToString(value);
  }

  module.exports = toString;
  /***/
},
/* 11 */

/***/
function (module, exports, __webpack_require__) {
  var _Symbol = __webpack_require__(12),
      arrayMap = __webpack_require__(16),
      isArray = __webpack_require__(17),
      isSymbol = __webpack_require__(18);
  /** Used as references for various `Number` constants. */


  var INFINITY = 1 / 0;
  /** Used to convert symbols to primitives and strings. */

  var symbolProto = _Symbol ? _Symbol.prototype : undefined,
      symbolToString = symbolProto ? symbolProto.toString : undefined;
  /**
   * The base implementation of `_.toString` which doesn't convert nullish
   * values to empty strings.
   *
   * @private
   * @param {*} value The value to process.
   * @returns {string} Returns the string.
   */

  function baseToString(value) {
    // Exit early for strings to avoid a performance hit in some environments.
    if (typeof value == 'string') {
      return value;
    }

    if (isArray(value)) {
      // Recursively convert values (susceptible to call stack limits).
      return arrayMap(value, baseToString) + '';
    }

    if (isSymbol(value)) {
      return symbolToString ? symbolToString.call(value) : '';
    }

    var result = value + '';
    return result == '0' && 1 / value == -INFINITY ? '-0' : result;
  }

  module.exports = baseToString;
  /***/
},
/* 12 */

/***/
function (module, exports, __webpack_require__) {
  var root = __webpack_require__(13);
  /** Built-in value references. */


  var _Symbol2 = root.Symbol;
  module.exports = _Symbol2;
  /***/
},
/* 13 */

/***/
function (module, exports, __webpack_require__) {
  var freeGlobal = __webpack_require__(14);
  /** Detect free variable `self`. */


  var freeSelf = (typeof self === "undefined" ? "undefined" : _typeof2(self)) == 'object' && self && self.Object === Object && self;
  /** Used as a reference to the global object. */

  var root = freeGlobal || freeSelf || Function('return this')();
  module.exports = root;
  /***/
},
/* 14 */

/***/
function (module, exports, __webpack_require__) {
  /* WEBPACK VAR INJECTION */
  (function (global) {
    /** Detect free variable `global` from Node.js. */
    var freeGlobal = _typeof2(global) == 'object' && global && global.Object === Object && global;
    module.exports = freeGlobal;
    /* WEBPACK VAR INJECTION */
  }).call(this, __webpack_require__(15));
  /***/
},
/* 15 */

/***/
function (module, exports) {
  var g; // This works in non-strict mode

  g = function () {
    return this;
  }();

  try {
    // This works if eval is allowed (see CSP)
    g = g || new Function("return this")();
  } catch (e) {
    // This works if the window reference is available
    if ((typeof window === "undefined" ? "undefined" : _typeof2(window)) === "object") g = window;
  } // g can still be undefined, but nothing to do about it...
  // We return undefined, instead of nothing here, so it's
  // easier to handle this case. if(!global) { ...}


  module.exports = g;
  /***/
},
/* 16 */

/***/
function (module, exports) {
  /**
   * A specialized version of `_.map` for arrays without support for iteratee
   * shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {Array} Returns the new mapped array.
   */
  function arrayMap(array, iteratee) {
    var index = -1,
        length = array == null ? 0 : array.length,
        result = Array(length);

    while (++index < length) {
      result[index] = iteratee(array[index], index, array);
    }

    return result;
  }

  module.exports = arrayMap;
  /***/
},
/* 17 */

/***/
function (module, exports) {
  /**
   * Checks if `value` is classified as an `Array` object.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is an array, else `false`.
   * @example
   *
   * _.isArray([1, 2, 3]);
   * // => true
   *
   * _.isArray(document.body.children);
   * // => false
   *
   * _.isArray('abc');
   * // => false
   *
   * _.isArray(_.noop);
   * // => false
   */
  var isArray = Array.isArray;
  module.exports = isArray;
  /***/
},
/* 18 */

/***/
function (module, exports, __webpack_require__) {
  var baseGetTag = __webpack_require__(19),
      isObjectLike = __webpack_require__(22);
  /** `Object#toString` result references. */


  var symbolTag = '[object Symbol]';
  /**
   * Checks if `value` is classified as a `Symbol` primitive or object.
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
   * @example
   *
   * _.isSymbol(Symbol.iterator);
   * // => true
   *
   * _.isSymbol('abc');
   * // => false
   */

  function isSymbol(value) {
    return _typeof2(value) == 'symbol' || isObjectLike(value) && baseGetTag(value) == symbolTag;
  }

  module.exports = isSymbol;
  /***/
},
/* 19 */

/***/
function (module, exports, __webpack_require__) {
  var _Symbol3 = __webpack_require__(12),
      getRawTag = __webpack_require__(20),
      objectToString = __webpack_require__(21);
  /** `Object#toString` result references. */


  var nullTag = '[object Null]',
      undefinedTag = '[object Undefined]';
  /** Built-in value references. */

  var symToStringTag = _Symbol3 ? _Symbol3.toStringTag : undefined;
  /**
   * The base implementation of `getTag` without fallbacks for buggy environments.
   *
   * @private
   * @param {*} value The value to query.
   * @returns {string} Returns the `toStringTag`.
   */

  function baseGetTag(value) {
    if (value == null) {
      return value === undefined ? undefinedTag : nullTag;
    }

    return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
  }

  module.exports = baseGetTag;
  /***/
},
/* 20 */

/***/
function (module, exports, __webpack_require__) {
  var _Symbol4 = __webpack_require__(12);
  /** Used for built-in method references. */


  var objectProto = Object.prototype;
  /** Used to check objects for own properties. */

  var hasOwnProperty = objectProto.hasOwnProperty;
  /**
   * Used to resolve the
   * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
   * of values.
   */

  var nativeObjectToString = objectProto.toString;
  /** Built-in value references. */

  var symToStringTag = _Symbol4 ? _Symbol4.toStringTag : undefined;
  /**
   * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
   *
   * @private
   * @param {*} value The value to query.
   * @returns {string} Returns the raw `toStringTag`.
   */

  function getRawTag(value) {
    var isOwn = hasOwnProperty.call(value, symToStringTag),
        tag = value[symToStringTag];

    try {
      value[symToStringTag] = undefined;
      var unmasked = true;
    } catch (e) {}

    var result = nativeObjectToString.call(value);

    if (unmasked) {
      if (isOwn) {
        value[symToStringTag] = tag;
      } else {
        delete value[symToStringTag];
      }
    }

    return result;
  }

  module.exports = getRawTag;
  /***/
},
/* 21 */

/***/
function (module, exports) {
  /** Used for built-in method references. */
  var objectProto = Object.prototype;
  /**
   * Used to resolve the
   * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
   * of values.
   */

  var nativeObjectToString = objectProto.toString;
  /**
   * Converts `value` to a string using `Object.prototype.toString`.
   *
   * @private
   * @param {*} value The value to convert.
   * @returns {string} Returns the converted string.
   */

  function objectToString(value) {
    return nativeObjectToString.call(value);
  }

  module.exports = objectToString;
  /***/
},
/* 22 */

/***/
function (module, exports) {
  /**
   * Checks if `value` is object-like. A value is object-like if it's not `null`
   * and has a `typeof` result of "object".
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
   * @example
   *
   * _.isObjectLike({});
   * // => true
   *
   * _.isObjectLike([1, 2, 3]);
   * // => true
   *
   * _.isObjectLike(_.noop);
   * // => false
   *
   * _.isObjectLike(null);
   * // => false
   */
  function isObjectLike(value) {
    return value != null && _typeof2(value) == 'object';
  }

  module.exports = isObjectLike;
  /***/
},
/* 23 */

/***/
function (module, exports) {
  /** Used to compose unicode character classes. */
  var rsAstralRange = "\\ud800-\\udfff",
      rsComboMarksRange = "\\u0300-\\u036f",
      reComboHalfMarksRange = "\\ufe20-\\ufe2f",
      rsComboSymbolsRange = "\\u20d0-\\u20ff",
      rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange,
      rsDingbatRange = "\\u2700-\\u27bf",
      rsLowerRange = 'a-z\\xdf-\\xf6\\xf8-\\xff',
      rsMathOpRange = '\\xac\\xb1\\xd7\\xf7',
      rsNonCharRange = '\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf',
      rsPunctuationRange = "\\u2000-\\u206f",
      rsSpaceRange = " \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000",
      rsUpperRange = 'A-Z\\xc0-\\xd6\\xd8-\\xde',
      rsVarRange = "\\ufe0e\\ufe0f",
      rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;
  /** Used to compose unicode capture groups. */

  var rsApos = "['\u2019]",
      rsBreak = '[' + rsBreakRange + ']',
      rsCombo = '[' + rsComboRange + ']',
      rsDigits = '\\d+',
      rsDingbat = '[' + rsDingbatRange + ']',
      rsLower = '[' + rsLowerRange + ']',
      rsMisc = '[^' + rsAstralRange + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + ']',
      rsFitz = "\\ud83c[\\udffb-\\udfff]",
      rsModifier = '(?:' + rsCombo + '|' + rsFitz + ')',
      rsNonAstral = '[^' + rsAstralRange + ']',
      rsRegional = "(?:\\ud83c[\\udde6-\\uddff]){2}",
      rsSurrPair = "[\\ud800-\\udbff][\\udc00-\\udfff]",
      rsUpper = '[' + rsUpperRange + ']',
      rsZWJ = "\\u200d";
  /** Used to compose unicode regexes. */

  var rsMiscLower = '(?:' + rsLower + '|' + rsMisc + ')',
      rsMiscUpper = '(?:' + rsUpper + '|' + rsMisc + ')',
      rsOptContrLower = '(?:' + rsApos + '(?:d|ll|m|re|s|t|ve))?',
      rsOptContrUpper = '(?:' + rsApos + '(?:D|LL|M|RE|S|T|VE))?',
      reOptMod = rsModifier + '?',
      rsOptVar = '[' + rsVarRange + ']?',
      rsOptJoin = '(?:' + rsZWJ + '(?:' + [rsNonAstral, rsRegional, rsSurrPair].join('|') + ')' + rsOptVar + reOptMod + ')*',
      rsOrdLower = '\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])',
      rsOrdUpper = '\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])',
      rsSeq = rsOptVar + reOptMod + rsOptJoin,
      rsEmoji = '(?:' + [rsDingbat, rsRegional, rsSurrPair].join('|') + ')' + rsSeq;
  /** Used to match complex or compound words. */

  var reUnicodeWord = RegExp([rsUpper + '?' + rsLower + '+' + rsOptContrLower + '(?=' + [rsBreak, rsUpper, '$'].join('|') + ')', rsMiscUpper + '+' + rsOptContrUpper + '(?=' + [rsBreak, rsUpper + rsMiscLower, '$'].join('|') + ')', rsUpper + '?' + rsMiscLower + '+' + rsOptContrLower, rsUpper + '+' + rsOptContrUpper, rsOrdUpper, rsOrdLower, rsDigits, rsEmoji].join('|'), 'g');
  /**
   * Splits a Unicode `string` into an array of its words.
   *
   * @private
   * @param {string} The string to inspect.
   * @returns {Array} Returns the words of `string`.
   */

  function unicodeWords(string) {
    return string.match(reUnicodeWord) || [];
  }

  module.exports = unicodeWords;
  /***/
},
/* 24 */

/***/
function (module, exports, __webpack_require__) {
  ;

  var _module$exports;

  var _element = __webpack_require__(25);

  var _element2 = _interopRequireDefault(_element);

  var _httpRequests = __webpack_require__(31);

  var requests = _interopRequireWildcard(_httpRequests);

  var _events = __webpack_require__(29);

  var events = _interopRequireWildcard(_events);

  var _logger = __webpack_require__(26);

  var consol = _interopRequireWildcard(_logger);

  var _utilities = __webpack_require__(28);

  var utils = _interopRequireWildcard(_utilities);

  var _DOM = __webpack_require__(30);

  var DOM = _interopRequireWildcard(_DOM);

  function _interopRequireWildcard(obj) {
    if (obj && obj.__esModule) {
      return obj;
    } else {
      var newObj = {};

      if (obj != null) {
        for (var key in obj) {
          if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
        }
      }

      newObj["default"] = obj;
      return newObj;
    }
  }

  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
      "default": obj
    };
  }

  function _defineProperty(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }

    return obj;
  }
  /*
  Elements.js
  
  A JavaScript DOM manipulation/Alias function Library.
  This is the index file for the library. It contains alias functions for
  all of the librarys' public functions. This makes it easy to import the
  functions without a module prefix es6 style.
  
  Author: Eric James Foster
  EMail: maniphestival@gmail.com
  License: MIT
  Version: 1.0.0
  URL: ""
  */
  //DONE: elements syntax not working in parenthesis.
  //FIXME: reg exp did not find element with CSS Selector, <'[class=active]'/>.
  //FIXME: eJS Interpreter hangs when eJS element is within brackets, and directly adjacent to one of them.
  //FIXME: cannot create element from variable representing a string.
  //FIXME: Find out why module imports are printing twice..
  //FIXME: Figure out why elements in square brackets slow things up...
  //DONE: Can't put elements in comments.
  //DONE: HTML interfering with regExp's.
  //DONE: can't use file blobs with import() func.
  //DONE: Should be able to use variables inside of elementJS elements.
  //TODO: make some functions complete operations for arrays automagically, instead of needing .every().
  //TODO: Make all event functions like once(), .once().
  //TODO: Complete <elem> syntax docs.
  //TODO: change apropo methods to properties.
  //DONE: .sib() does not return element.......
  //DONE: addClass() method.
  //DONE: new log.dir() function.
  //DONE: .src, .href() etc.
  //DONE: add a class method, remove a class method.
  //TODO: more .transform() methods.
  //DONE: += html method.
  //DONE: transform methods. i.e. this.turnX(), this.turnY.
  //TODO: .do(), do() animation functionality. (with tween.js?)
  //DONE: be able to create element object from e.target.....
  //TODO: getCookie, setCookie, checkCookie functions....
  //TODO: move functions........
  //TODO: Needed polyfills.
  //TODO: element.classList()....
  //TODO: hover(mouseOverFunc, mouseOutFunc) func.....
  //TODO: element.name() function.....
  //TODO: add functionality to make() function to allow creating nameless, id less divs.
  //TODO: write scroll-snapper plugin,
  //TODO: list of plug-ins
  //TODO: touch('start', ()=> {});  touch event function, method..
  //DONE:0 Complete X-Browser 'style' functions, and implement X-Browser compatibility in EventListener functions.
  //Index of polyfill for IE...........


  if (!Array.prototype.indexOf) {
    Array.prototype.indexOf = function (item) {
      var i = this.length;

      while (i--) {
        if (this[i] === item) return i;
      }

      return -1;
    };
  }

  var element = function element(el) {
    if (isDOMElement(el)) {
      return new _element2["default"](el);
    } else if (utils.isArray(el)) {
      if (isElement(el[0])) {
        return new _element2["default"](el);
      } else if (isDOMElement(el[0])) {
        var arr = [];

        for (var i = 0; i < el.length; i++) {
          arr.push(new _element2["default"](el[i]));
        }

        return new _element2["default"](arr);
      } else {
        throw new Error('Invalid Array.');
      }
    } else {
      throw new Error('Invalid Argument.');
    }
  };

  var isElement = function isElement(el) {
    return utils.isElement(el);
  };

  var isDOMElement = function isDOMElement(el) {
    return utils.isDOMElement(el);
  };
  /*This function copies the prototype object of a superConstructor to the prototype object
  of a constructor. It functions just like nodes' util.inherits function, it copies methods only,
  not internal properties.*/


  var proto = function proto(construct, superConstruct) {
    return utils.proto(construct, superConstruct);
  }; //This function will simply return true if the given element exists in the DOM, and false otherwise. not a public function.


  var _$ = function _$(el) {
    return null !== utils.queryDOM(el);
  };

  var isArray = function isArray(arr) {
    return utils.isArray(arr);
  }; //This function queries the dom, getting one element for each query (i.e. class/tags), creates
  //an Element object with it and returns it, so that it may be easily styled.


  var dom = function dom(el) {
    var rv = void 0;
    el = utils.queryDOM(el);

    if (el.length !== undefined) {
      rv = [];

      for (var i = 0; i < el.length; i++) {
        rv.push(new _element2["default"](el[i]));
      }

      rv = new _element2["default"](rv);
    } else {
      rv = new _element2["default"](el);
    }

    return rv;
  };
  /*function for inserting template literals into the DOM.
  
  bones(`
  
  <html>
    <head></head>
    <body></body>
  </html>
  
  `);
  
  */


  var __ = function __(tempLit) {
    var el = arguments.length <= 1 || arguments[1] === undefined ? 'body' : arguments[1];
    return DOM.bones(tempLit, el);
  }; //Create element alias function.


  var make = function make(el, tag) {
    return DOM.make(el, tag);
  }; //DOM querying alias function. Will automatically narrow class or tag queries down to one result. It will not return an array.


  var el = function el(l) {
    return utils.queryDOM(l);
  }; //Function for appending elements to other elements.


  var put = function put(el, mom) {
    return DOM.put(el, mom);
  }; //Function for deleting elements from the DOM tree.


  var x = function x(el) {
    return DOM.kill(el);
  };

  var fore = function fore(ref, elem) {
    return DOM.fore(ref, elem);
  };

  var aft = function aft(ref, elem) {
    return DOM.aft(ref, elem);
  };

  var show = function show(elem, disp) {
    return DOM.show(elem);
  };

  var hide = function hide(elem) {
    return DOM.hide(elem);
  };

  var size = function size(elem, h, w) {
    return DOM.size(elem, h, w);
  };

  var clone = function clone(elem, deep) {
    return DOM.clone(elem, deep);
  }; //console.log alias function.


  var log = function log(text, style, tyme) {
    return consol.log(text, style, tyme);
  }; //console.error alias function.


  var err = function err(text, tyme) {
    return consol.err(text, tyme);
  }; //console.info alias function.


  var info = function info(text, tyme) {
    return consol.info(text, tyme);
  }; //console.warn alias function.


  var warn = function warn(text, tyme) {
    return consol.warn(text, tyme);
  };

  var inspect = function inspect(obj) {
    return consol.inspect(obj);
  };

  var shifter = function shifter(onFunc, offFunc) {
    return utils.shifter(onFunc, offFunc);
  };

  var hasAncestor = function hasAncestor(l, ance) {
    return utils.hasAncestor(l, ance);
  };

  var lookBehind = function lookBehind(leftContextRE, matchRE, subject) {
    return utils.lookBehind(leftContextRE, matchRE, subject);
  };

  var isMobile = function isMobile() {
    return utils.isMobile();
  }; //This practically useless function will lock up the browser for a preset amount of time.


  var sleep = function sleep(milliseconds) {
    return utils.sleep(milliseconds);
  }; //A function for combining strings for urls


  var url = function url(bit1, bit2) {
    var bit3 = arguments.length <= 2 || arguments[2] === undefined ? '' : arguments[2];
    var bit4 = arguments.length <= 3 || arguments[3] === undefined ? '' : arguments[3];
    return bit1 + bit2 + bit3 + bit4;
  }; //This is a synchronous alias function for XMLHttpRequests.


  var xhr = function xhr(url, fd, method) {
    return requests.xhr(url, fd, method);
  }; //This is an asynchronous alias function for XMLHttpRequests.


  var ajax = function ajax(url, fd, callback, method) {
    return requests.ajax(url, fd, callback, method);
  };
  /*---------Event Functions-----------*/


  var go = function go(cb) {
    if (document.addEventListener) {
      return events.go(cb);
    } else {
      return events.goIE(cb);
    }
  }; //Function for setting event listeners.


  var on = function on(event, el, callback) {
    if (document.addEventListener) {
      return events.on(event, el, callback);
    } else {
      return events.onIE(event, el, callback);
    }
  }; //Function for removing event listeners.


  var off = function off(event, el, callback) {
    if (document.addEventListener) {
      return events.off(event, el, callback);
    } else {
      return events.offIE(event, el, callback);
    }
  };

  var once = function once(event, el, callback) {
    //DONE:50 Finish once function.
    if (document.addEventListener) {
      return events.once(event, el, callback);
    } else {
      return events.onceIE(event, el, callback);
    } //TEST:70 Test once function.

  };

  var spark = function spark(evt, el) {
    el = utils.queryDOM(el);

    if (document.addEventListener) {
      return events.spark(evt, el);
    } else {
      return events.sparkIE(evt, el);
    }
  };

  var blur = function blur(el) {
    var cb = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];
    el = utils.queryDOM(el);

    if (document.addEventListener) {
      return events.blur(el, cb);
    } else {
      return events.blurIE(el, cb);
    }
  };

  var click = function click(el) {
    var cb = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];
    el = utils.queryDOM(el);

    if (document.addEventListener) {
      return events.click(el, cb);
    } else {
      return events.clickIE(el, cb);
    }
  };

  var dblClick = function dblClick(el) {
    var cb = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];
    el = utils.queryDOM(el);

    if (document.addEventListener) {
      return events.dblClick(el, cb);
    } else {
      return events.dblClickIE(el, cb);
    }
  };

  var error = function error(el) {
    var cb = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];
    el = utils.queryDOM(el);

    if (document.addEventListener) {
      return events.error(el, cb);
    } else {
      return events.errorIE(el, cb);
    }
  };

  var focus = function focus(el) {
    var cb = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];
    el = utils.queryDOM(el);

    if (document.addEventListener) {
      return events.focus(el, cb);
    } else {
      return events.focusIE(el, cb);
    }
  };

  var focusIn = function focusIn(el) {
    var cb = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];
    el = utils.queryDOM(el);

    if (document.addEventListener) {
      return events.focusIn(el, cb);
    } else {
      return events.focusInIE(el, cb);
    }
  };

  var focusOut = function focusOut(el) {
    var cb = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];
    el = utils.queryDOM(el);

    if (document.addEventListener) {
      return events.focusOut(el, cb);
    } else {
      return events.focusOut(el, cb);
    }
  };

  var keyUp = function keyUp(el) {
    var cb = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];
    el = utils.queryDOM(el);

    if (document.addEventListener) {
      return events.keyUp(el, cb);
    } else {
      return events.keyUpIE(el, cb);
    }
  };

  var keyDown = function keyDown(el) {
    var cb = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];
    el = utils.queryDOM(el);

    if (document.addEventListener) {
      return events.keyDown(el, cb);
    } else {
      return events.keyDownIE(el, cb);
    }
  };

  var load = function load(el) {
    var cb = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];
    el = utils.queryDOM(el);

    if (document.addEventListener) {
      return events.load(el, cb);
    } else {
      return events.loadIE(el, cb);
    }
  };

  var unLoad = function unLoad(el) {
    var cb = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];
    el = utils.queryDOM(el);

    if (document.addEventListener) {
      return events.unLoad(el, cb);
    } else {
      return events.unLoadIE(el, cb);
    }
  };

  var mouse = function mouse(sfx, el) {
    var cb = arguments.length <= 2 || arguments[2] === undefined ? null : arguments[2];
    el = utils.queryDOM(el);

    if (document.addEventListener) {
      return events.mouse(sfx, el, cb);
    } else {
      return events.mouseIE(sfx, el, cb);
    }
  };

  var resize = function resize(el) {
    var cb = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];
    el = utils.queryDOM(el);

    if (document.addEventListener) {
      return events.resize(el, cb);
    } else {
      return events.resizeIE(el, cb);
    }
  };

  var scroll = function scroll(el) {
    var cb = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];
    el = utils.queryDOM(el);

    if (document.addEventListener) {
      return events.scroll(el, cb);
    } else {
      return events.scrollIE(el, cb);
    }
  };

  var select = function select(el) {
    var cb = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];
    el = utils.queryDOM(el);

    if (document.addEventListener) {
      return events.select(el, cb);
    } else {
      return events.selectIE(el, cb);
    }
  }; //<<=================May have found a better solution.======================================>>//

  /*This convenience function sets imported module function names as global variables, so that
  the module variable doesn't need to preface every function.*/
  // var functions = function(funcs, mod) {
  //   var context = mod || this;
  //
  //   if (Array.isArray(funcs)) {
  //     log(mod, 'red');
  //
  //     funcs.forEach(function(func) {
  //       var evil = new Function('window.' + func + ' = ' + 'this.' + func + ';');
  //           evil.call(context);
  //     }, context);
  //   } else {
  //     (function() {
  //       var evil = new Function('window.' + funcs + ' = ' + 'this.' + funcs + ';');
  //           evil.call(context);
  //     }).apply(context);
  //   }
  // };


  module.exports = (_module$exports = {
    element: element,
    _$: _$,
    x: x,
    go: go,
    shifter: shifter,
    make: make,
    __: __,
    dom: dom,
    proto: proto,
    clone: clone,
    isArray: isArray,
    isElement: isElement,
    isDOMElement: isDOMElement,
    // functions: functions,
    hasAncestor: hasAncestor,
    lookBehind: lookBehind,
    isMobile: isMobile,
    put: put,
    on: on,
    off: off,
    once: once,
    el: el,
    log: log,
    url: url,
    xhr: xhr,
    err: err,
    info: info,
    warn: warn,
    inspect: inspect,
    ajax: ajax,
    fore: fore,
    aft: aft,
    show: show,
    hide: hide,
    size: size
  }, _defineProperty(_module$exports, 'clone', clone), _defineProperty(_module$exports, 'spark', spark), _defineProperty(_module$exports, 'blur', blur), _defineProperty(_module$exports, 'click', click), _defineProperty(_module$exports, 'dblClick', dblClick), _defineProperty(_module$exports, 'error', error), _defineProperty(_module$exports, 'focus', focus), _defineProperty(_module$exports, 'focusIn', focusIn), _defineProperty(_module$exports, 'focusOut', focusOut), _defineProperty(_module$exports, 'keyUp', keyUp), _defineProperty(_module$exports, 'keyDown', keyDown), _defineProperty(_module$exports, 'load', load), _defineProperty(_module$exports, 'unLoad', unLoad), _defineProperty(_module$exports, 'mouse', mouse), _defineProperty(_module$exports, 'resize', resize), _defineProperty(_module$exports, 'scroll', scroll), _defineProperty(_module$exports, 'select', select), _module$exports); //DONE:30 functions: err(), info(), warn().
  //DONE:130 Complete all standalone style functions.

  /***/
},
/* 25 */

/***/
function (module, exports, __webpack_require__) {
  ;

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _typeof = typeof Symbol === "function" && _typeof2(Symbol.iterator) === "symbol" ? function (obj) {
    return _typeof2(obj);
  } : function (obj) {
    return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : _typeof2(obj);
  };
  /*
  Element.js
  
  This is a helper file for the elements.js index, which houses
  the code for the Element Class.
  
  Author: Eric James Foster
  License: ISC
  */


  exports["default"] = Element;

  var _logger = __webpack_require__(26);

  var _utilities = __webpack_require__(28);

  var _events = __webpack_require__(29);

  var events = _interopRequireWildcard(_events);

  var _DOM = __webpack_require__(30);

  var DOM = _interopRequireWildcard(_DOM);

  function _interopRequireWildcard(obj) {
    if (obj && obj.__esModule) {
      return obj;
    } else {
      var newObj = {};

      if (obj != null) {
        for (var key in obj) {
          if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
        }
      }

      newObj["default"] = obj;
      return newObj;
    }
  } //DOING:10 List all functions that need to be added (.textContent, innerHTML etc.)
  //DOING:20 Complete all functions for this object.


  function Element(el) {
    if ((0, _utilities.isArray)(el)) {
      this.els = el;
    } else {
      this.el = el;
      this.element = true;
    }

    var self = this;

    if (!(this instanceof Element)) {
      return new Element();
    } // Style methods //


    this.border = function (val) {
      if (val !== undefined) {
        el.style.border = val;
        return this;
      } else {
        val = el.style.border;
        return val;
      }
    };

    this.bg = function (val) {
      if (val !== undefined) {
        el.style.background = val;
        return this;
      } else {
        val = el.style.background;
        return val;
      }
    };

    this.bgColor = function (val) {
      if (val !== undefined) {
        el.style.backgroundColor = val;
        return this;
      } else {
        val = el.style.backgroundColor;
        return val;
      }
    };

    this.bgImage = function (val) {
      if (val !== undefined) {
        el.style.backgroundImage = val;
        return this;
      } else {
        val = el.style.backgroundImage;
        return val;
      }
    };

    this.bgSize = function (val) {
      if (val !== undefined) {
        el.style.backgroundSize = val;
        return this;
      } else {
        val = el.style.backgroundSize;
        return val;
      }
    };

    this.bgPosition = function (val) {
      if (val !== undefined) {
        el.style.backgroundPosition = val;
        return this;
      } else {
        val = el.style.backgroundPosition;
        return val;
      }
    };

    this.borderColor = function (val) {
      if (val !== undefined) {
        el.style.borderColor = val;
        return this;
      } else {
        val = el.style.borderColor;
        return val;
      }
    };

    this.borderRadius = function (val) {
      if (val !== undefined) {
        el.style.borderRadius = val;
        return this;
      } else {
        val = el.style.borderRadius;
        return val;
      }
    };

    this.borderWidth = function (val) {
      if (val !== undefined) {
        el.style.borderWidth = val;
        return this;
      } else {
        val = el.style.borderWidth;
        return val;
      }
    };

    this.borderTop = function (val) {
      if (val !== undefined) {
        el.style.borderTop = val;
        return this;
      } else {
        val = el.style.borderTop;
        return val;
      }
    };

    this.borderBottom = function (val) {
      if (val !== undefined) {
        el.style.borderBottom = val;
        return this;
      } else {
        val = el.style.borderBottom;
        return val;
      }
    };

    this.borderRight = function (val) {
      if (val !== undefined) {
        el.style.borderRight = val;
        return this;
      } else {
        val = el.style.borderRight;
        return val;
      }
    };

    this.borderLeft = function (val) {
      if (val !== undefined) {
        el.style.borderLeft = val;
        return this;
      } else {
        val = el.style.borderLeft;
        return val;
      }
    };

    this.bottom = function (val) {
      if (val !== undefined) {
        el.style.bottom = val;
        return this;
      } else {
        val = el.style.bottom;
        return val;
      }
    };

    this.boxShadow = function (val) {
      if (val !== undefined) {
        el.style.boxShadow = val;
        return this;
      } else {
        val = el.style.boxShadow;
        return val;
      }
    };

    this.boxSizing = function (val) {
      if (val !== undefined) {
        el.style.boxSizing = val;
        return this;
      } else {
        val = el.style.boxSizing;
        return val;
      }
    };

    this.clear = function (val) {
      if (val !== undefined) {
        el.style.clear = val;
        return this;
      } else {
        val = el.style.clear;
        return val;
      }
    };

    this.color = function (val) {
      if (val !== undefined) {
        el.style.color = val;
        return this;
      } else {
        val = el.style.color;
        return val;
      }
    };

    this.columns = function (val) {
      if (val !== undefined) {
        el.style.columns = val;
        return this;
      } else {
        val = el.style.columns;
        return val;
      }
    };

    this.content = function (val) {
      if (val !== undefined) {
        el.style.content = val;
        return this;
      } else {
        val = el.style.content;
        return val;
      }
    };

    this.cursor = function (val) {
      if (val !== undefined) {
        el.style.cursor = val;
        return this;
      } else {
        val = el.style.cursor;
        return val;
      }
    };

    this.direction = function (val) {
      if (val !== undefined) {
        el.style.direction = val;
        return this;
      } else {
        val = el.style.direction;
        return val;
      }
    };

    this.display = function (val) {
      if (val !== undefined) {
        el.style.display = val;
        return this;
      } else {
        val = el.style.display;
        return val;
      }
    };

    this.cssFloat = function (val) {
      if (val !== undefined) {
        el.style.cssFloat = val;
        return this;
      } else {
        val = el.style.cssFloat;
        return val;
      }
    };

    this.font = function (val) {
      if (val !== undefined) {
        el.style.font = val;
        return this;
      } else {
        val = el.style.font;
        return val;
      }
    };

    this.fontFamily = function (val) {
      if (val !== undefined) {
        el.style.fontFamily = val;
        return this;
      } else {
        val = el.style.fontFamily;
        return val;
      }
    };

    this.fontStyle = function (val) {
      if (val !== undefined) {
        el.style.fontStyle = val;
        return this;
      } else {
        val = el.style.fontStyle;
        return val;
      }
    };

    this.fontSize = function (val) {
      if (val !== undefined) {
        el.style.fontSize = val;
        return this;
      } else {
        val = el.style.fontSize;
        return val;
      }
    };

    this.fontWeight = function (val) {
      if (val !== undefined) {
        el.style.fontWeight = val;
        return this;
      } else {
        val = el.style.fontWeight;
        return val;
      }
    };

    this.height = function (val) {
      if (val !== undefined) {
        el.style.height = val;
        return this;
      } else {
        val = el.style.height;
        return val;
      }
    };

    this.lineHeight = function (val) {
      if (val !== undefined) {
        el.style.lineHeight = val;
        return this;
      } else {
        val = el.style.lineHeight;
        return val;
      }
    };

    this.icon = function (val) {
      if (val !== undefined) {
        el.style.icon = val;
        return this;
      } else {
        val = el.style.icon;
        return val;
      }
    };

    this.left = function (val) {
      if (val !== undefined) {
        el.style.left = val;
        return this;
      } else {
        val = el.style.left;
        return val;
      }
    };

    this.listStyle = function (val) {
      if (val !== undefined) {
        el.style.listStyle = val;
        return this;
      } else {
        val = el.style.listStyle;
        return val;
      }
    };

    this.margin = function (val) {
      if (val !== undefined) {
        el.style.margin = val;
        return this;
      } else {
        val = el.style.margin;
        return val;
      }
    };

    this.marginRight = function (val) {
      if (val !== undefined) {
        el.style.marginRight = val;
        return this;
      } else {
        val = el.style.marginRight;
        return val;
      }
    };

    this.marginLeft = function (val) {
      if (val !== undefined) {
        el.style.marginLeft = val;
        return this;
      } else {
        val = el.style.marginLeft;
        return val;
      }
    };

    this.marginTop = function (val) {
      if (val !== undefined) {
        el.style.marginTop = val;
        return this;
      } else {
        val = el.style.marginTop;
        return val;
      }
    };

    this.marginBottom = function (val) {
      if (val !== undefined) {
        el.style.marginBottom = val;
        return this;
      } else {
        val = el.style.marginBottom;
        return val;
      }
    };

    this.maxHeight = function (val) {
      if (val !== undefined) {
        el.style.maxHeight = val;
        return this;
      } else {
        val = el.style.maxHeight;
        return val;
      }
    };

    this.maxWidth = function (val) {
      if (val !== undefined) {
        el.style.maxWidth = val;
        return this;
      } else {
        val = el.style.maxWidth;
        return val;
      }
    };

    this.minWidth = function (val) {
      if (val !== undefined) {
        el.style.minWidth = val;
        return this;
      } else {
        val = el.style.minWidth;
        return val;
      }
    };

    this.minHeight = function (val) {
      if (val !== undefined) {
        el.style.minHeight = val;
        return this;
      } else {
        val = el.style.minHeight;
        return val;
      }
    };

    this.opacity = function (val) {
      if (val !== undefined) {
        el.style.opacity = val;
        return this;
      } else {
        val = el.style.opacity;
        return val;
      }
    };

    this.outline = function (val) {
      if (val !== undefined) {
        el.style.outline = val;
        return this;
      } else {
        val = el.style.outline;
        return val;
      }
    };

    this.overflow = function (val) {
      if (val !== undefined) {
        el.style.overflow = val;
        return this;
      } else {
        val = el.style.overflow;
        return val;
      }
    };

    this.overflowX = function (val) {
      if (val !== undefined) {
        el.style.overflowX = val;
        return this;
      } else {
        val = el.style.overflowX;
        return val;
      }
    };

    this.overflowY = function (val) {
      if (val !== undefined) {
        el.style.overflowY = val;
        return this;
      } else {
        val = el.style.overflowY;
        return val;
      }
    };

    this.padding = function (val) {
      if (val !== undefined) {
        el.style.padding = val;
        return this;
      } else {
        val = el.style.padding;
        return val;
      }
    };

    this.paddingRight = function (val) {
      if (val !== undefined) {
        el.style.paddingRight = val;
        return this;
      } else {
        val = el.style.paddingRight;
        return val;
      }
    };

    this.paddingLeft = function (val) {
      if (val !== undefined) {
        el.style.paddingLeft = val;
        return this;
      } else {
        val = el.style.paddingLeft;
        return val;
      }
    };

    this.paddingTop = function (val) {
      if (val !== undefined) {
        el.style.paddingTop = val;
        return this;
      } else {
        val = el.style.paddingTop;
        return val;
      }
    };

    this.paddingBottom = function (val) {
      if (val !== undefined) {
        el.style.paddingBottom = val;
        return this;
      } else {
        val = el.style.paddingBottom;
        return val;
      }
    };

    this.position = function (val) {
      if (val !== undefined) {
        el.style.position = val;
        return this;
      } else {
        val = el.style.position;
        return val;
      }
    };

    this.right = function (val) {
      if (val !== undefined) {
        el.style.right = val;
        return this;
      } else {
        val = el.style.right;
        return val;
      }
    };

    this.top = function (val) {
      if (val !== undefined) {
        el.style.top = val;
        return this;
      } else {
        val = el.style.top;
        return val;
      }
    };

    this.transform = function (val) {
      this.el.style.transform = val;
      return this;
    }; //<<========= Transform Methods ======================>>


    this.turn = function (val) {
      this.el.style.transform = 'rotate(' + String(val) + 'deg)';
      return this;
    };

    this.turnX = function (val) {
      this.el.style.transform = 'rotateX(' + String(val) + 'deg)';
      return this;
    };

    this.turnY = function (val) {
      this.el.style.transform = 'rotateY(' + String(val) + 'deg)';
      return this;
    };

    this.turnZ = function (val) {
      this.el.style.transform = 'rotateZ(' + String(val) + 'deg)';
      return this;
    };

    this.textAlign = function (val) {
      if (val !== undefined) {
        el.style.textAlign = val;
        return this;
      } else {
        val = el.style.textAlign;
        return val;
      }
    };

    this.textDecoration = function (val) {
      if (val !== undefined) {
        el.style.textDecoration = val;
        return this;
      } else {
        val = el.style.textDecoration;
        return val;
      }
    };

    this.textShadow = function (val) {
      if (val !== undefined) {
        el.style.textShadow = val;
        return this;
      } else {
        val = el.style.textShadow;
        return val;
      }
    };

    this.verticalAlign = function (val) {
      if (val !== undefined) {
        el.style.verticalAlign = val;
        return this;
      } else {
        val = el.style.verticalAlign;
        return val;
      }
    };

    this.visibility = function (val) {
      if (val !== undefined) {
        el.style.visibility = val;
        return this;
      } else {
        val = el.style.visibility;
        return val;
      }
    };

    this.whiteSpace = function (val) {
      if (val !== undefined) {
        el.style.whiteSpace = val;
        return this;
      } else {
        val = el.style.whiteSpace;
        return val;
      }
    };

    this.width = function (val) {
      if (val !== undefined) {
        el.style.width = val;
        return this;
      } else {
        val = el.style.width;
        return val;
      }
    };

    this.wordSpacing = function (val) {
      if (val !== undefined) {
        el.style.wordSpacing = val;
        return this;
      } else {
        val = el.style.wordSpacing;
        return val;
      }
    };

    this.zIndex = function (val) {
      if (val !== undefined) {
        el.style.zIndex = val;
        return this;
      } else {
        val = el.style.zIndex;
        return val;
      }
    };

    this.alignContent = function (val) {
      if (browser.safari && browser.version >= 7) {
        if (val !== undefined) {
          el.style.WebkitAlignContent = val;
          return this;
        } else {
          val = el.style.WebkitAlignContent;
          return val;
        }
      } else {
        if (val !== undefined) {
          el.style.alignContent = val;
          return this;
        } else {
          val = el.style.alignContent;
          return val;
        }
      }
    };

    this.transformOrigin = function (val) {
      if (browser.webkit) {
        if (val !== undefined) {
          el.style.WebkitTransformOrigin = val;
          return this;
        } else {
          val = el.style.WebkitTransformOrigin;
          return val;
        }
      } else {
        if (val !== undefined) {
          el.style.transformOrigin = val;
          return this;
        } else {
          val = el.style.transformOrigin;
          return val;
        }
      }
    };

    this.transition = function (val) {
      if (browser.safari) {
        if (val !== undefined) {
          el.style.WebkitTransition = val;
          return this;
        } else {
          val = el.style.WebkitTransition;
          return val;
        }
      } else {
        if (val !== undefined) {
          el.style.transition = val;
          return this;
        } else {
          val = el.style.transition;
          return val;
        }
      }
    };

    this.transitionDuration = function (val) {
      if (browser.safari) {
        if (val !== undefined) {
          el.style.WebkitTransitionDuration = val;
          return this;
        } else {
          val = el.style.WebkitTransitionDuration;
          return val;
        }
      } else {
        if (val !== undefined) {
          el.style.transitionDuration = val;
          return this;
        } else {
          val = el.style.transitionDuration;
          return val;
        }
      }
    };

    this.animation = function (val) {
      if (browser.webkit) {
        if (val !== undefined) {
          el.style.WebkitAnimation = val;
          return this;
        } else {
          val = el.style.WebkitAnimation;
          return val;
        }
      } else {
        if (val !== undefined) {
          el.style.animation = val;
          return this;
        } else {
          val = el.style.animation;
          return val;
        }
      }
    };

    this.filter = function (val) {
      if (browser.webkit) {
        if (val !== undefined) {
          el.style.WebkitFilter = val;
          return this;
        } else {
          val = el.style.WebkitFilter;
          return val;
        }
      } else {
        if (val !== undefined) {
          el.style.filter = val;
          return this;
        } else {
          val = el.style.filter;
          return val;
        }
      }
    };

    this.flex = function (val) {
      if (browser.safari) {
        if (val !== undefined) {
          el.style.WebkitFlex = val;
          return this;
        } else {
          val = el.style.WebkitFlex;
          return val;
        }
      } else {
        if (val !== undefined) {
          el.style.flex = val;
          return this;
        } else {
          val = el.style.flex;
          return val;
        }
      }
    };

    this.perspective = function (val) {
      if (browser.webkit) {
        if (val !== undefined) {
          el.style.WebkitPerspective = val;
          return this;
        } else {
          val = el.style.WebkitPerspective;
          return val;
        }
      } else {
        if (val !== undefined) {
          el.style.perspective = val;
          return this;
        } else {
          val = el.style.perspective;
          return val;
        }
      }
    };

    this.perspectiveOrigin = function (val) {
      if (browser.webkit) {
        if (val !== undefined) {
          el.style.WebkitPerspectiveOrigin = val;
          return this;
        } else {
          val = el.style.WebkitPerspectiveOrigin;
          return val;
        }
      } else {
        if (val !== undefined) {
          el.style.perspectiveOrigin = val;
          return this;
        } else {
          val = el.style.perspectiveOrigin;
          return val;
        }
      }
    };

    this.transitionDelay = function (val) {
      if (browser.safari) {
        if (val !== undefined) {
          el.style.WebkitTransitionDelay = val;
          return this;
        } else {
          val = el.style.WebkitTransitionDelay;
          return val;
        }
      } else {
        if (val !== undefined) {
          el.style.transitionDelay = val;
          return this;
        } else {
          val = el.style.transitionDelay;
          return val;
        }
      }
    }; // Element object methods //

    /*This function is a wrapper that allows the developer to create an anonymous function that has
    access to the core element object and its' methods... Meaning, that methods not incuded in this library
    can still be used in a chain-like fashion.  # example:
    <'#header'/>
          .height('200px')
          .width('800px')
          .backgroundColor('red')
          .text('elements.js')
          .core(el=>
           {    el.lang = 'spanish';
                el.jackAss();
                el.nodeValue = this;
                el.normalize();   }
               )
          .put('body')
    */


    this.core = function (func) {
      var obj = arguments.length <= 1 || arguments[1] === undefined ? 'el' : arguments[1];
      if (obj === 'style') func(this.el.style);else if (obj === 'el') func(this.el);else (0, _logger.err)('Invalid Argument.');
      return this;
    };

    this.add = function (child) {
      child = DOM.el(child);
      this.el.appendChild(child);
      return this;
    };

    this.children = function (s) {
      var count = void 0,
          arr = [];

      if (s === 'all') {
        count = this.el.childNodes;
      } else {
        count = this.el.children;
      }

      for (var i = 0; i < count.length; i++) {
        arr.push(new Element(count[i]));
      }

      return new Element(arr);
    };

    this.child = function () {
      var count = void 0;

      if ((0, _utilities.isArray)(this.el.children)) {
        var _count = this.el.children;
        _count = _count[0];
      } else {
        var _count2 = this.el.children;
      }

      return new Element(count);
    };

    this.first = function (s) {
      //TEST:30 Make sure this works.
      var sib = s === 'node' ? this.el.firstChild : this.el.firstElementChild;
      return new Element(sib);
    };

    this.second = function (s) {
      //TEST:30 Make sure this works.
      var sib = s === 'node' ? this.el.firstChild.nextSibling : this.el.firstElementChild.nextElementSibling;
      return new Element(sib);
    };

    this.third = function (s) {
      var varb = el.firstElementChild.nextElementSibling,
          varb2 = el.firstChild.nextSibling,
          //TEST:30 Make sure this works.
      sib = s === 'node' ? varb2.nextSibling : varb.nextElementSibling;
      return new Element(sib);
    };

    this.last = function (s) {
      //TEST:30 Make sure this works.
      var sib = s === 'node' ? this.el.lastChild : this.el.lastElementChild;
      return new Element(sib);
    };

    this.id = function (val) {
      if (val !== undefined) {
        this.el.id = val;
        return this;
      } else {
        val = this.el.id;
        return val;
      }
    };

    this["class"] = function (val) {
      var mod = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];

      if (val !== undefined) {
        if (null !== mod) {
          if (mod === '+') {
            this.el.classList.add(val);
            return this;
          } else if (mod == '-') {
            this.el.classList.remove(val);
            return this;
          } else {
            (0, _logger.err)('Invalid Argument');
          }
        } else {
          this.el.className = val;
          return this;
        }
      } else {
        val = this.el.className;
        return val;
      }
    };

    this.x = function (elem) {
      var child = DOM.el(elem);
      this.el.removeChild(child);
      return this;
    };

    this.xClass = function () {
      var cb = arguments.length <= 0 || arguments[0] === undefined ? null : arguments[0];

      if (cb !== null) {
        cb();
      }

      this.el.className = '';
      return this;
    };

    this.html = function (val) {
      var mod = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];

      if (val !== undefined) {
        if (null !== mod) {
          if (mod === '+') {
            this.el.innerHTML += val;
            return this;
          } else {
            (0, _logger.err)('Invalid Argument');
          }
        } else {
          this.el.innerHTML = val;
          return this;
        }
      } else {
        val = this.el.innerHTML;
        return val;
      }
    };

    this.text = function (val) {
      var mod = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];

      if (val !== undefined) {
        if (null !== mod) {
          if (mod === '+') {
            this.el.textContent += val;
            return this;
          } else {
            (0, _logger.err)('Invalid Argument');
          }
        } else {
          this.el.textContent = val;
          return this;
        }
      } else {
        val = this.el.textContent;
        return val;
      }
    };

    this.lang = function (val) {
      if (val !== undefined) {
        this.el.lang = val;
        return this;
      } else {
        val = this.el.lang;
        return val;
      }
    };

    this.clone = function (deep) {
      var node = this.el.cloneNode(deep);
      return node;
    };

    this.sib = function (ord) {
      var r = void 0;

      if (ord === 'next') {
        r = this.el.nextElementSibling;
      } else if (ord === 'prev') {
        r = this.el.previousElementSibling;
      } else {
        (0, _logger.err)('Invalid argument.');
      }

      return new Element(r);
    };

    this.node = function (ord) {
      var r = void 0;

      if (ord === 'next') {
        r = this.el.nextSibling;
      } else if (ord === 'prev') {
        r = this.el.previousSibling;
      } else {
        (0, _logger.err)('Invalid argument.');
      }

      return new Element(r);
    };

    this.value = function (val) {
      if (val !== undefined) {
        this.el.nodeValue = val;
        return this;
      } else {
        val = this.el.nodeValue;
        return val;
      }
    };

    this.normalize = function () {
      this.el.normalize();
      return this;
    };

    this.toString = function () {
      var r = this.el.toString();
      return r;
    };

    this.tag = function () {
      var r = this.el.tagName;
      return r;
    };

    this.fromTop = function () {
      //TODO
      var r = this.el.offsetTop;
      return r;
    };

    this.fromLeft = function () {
      var r = this.el.offsetLeft;
      return r;
    };

    this.offset = function () {
      var off = {};
      off.top = this.el.offsetTop;
      off.left = this.el.offsetLeft;
      off.height = this.el.offsetHeight;
      off.width = this.el.offsetWidth;
      off.parent = this.el.offsetParent;
      return off;
    };

    this.scrolled = function (val) {
      if (val !== undefined) {
        el.scrollTop = val;
        return this;
      } else if (val === 0) {
        el.scrollTop = 0;
        return this;
      } else {
        val = el.scrollTop;
        return val;
      }
    };

    this.scrollLeft = function (val) {
      if (val !== undefined) {
        el.scrollLeft = val;
        return this;
      } else {
        val = el.scrollLeft;
        return val;
      }
    };

    this.scrollHeight = function (val) {
      if (val !== undefined) {
        el.scrollHeight = val;
        return this;
      } else {
        val = el.scrollHeight;
        return val;
      }
    };

    this.scrollWidth = function (val) {
      if (val !== undefined) {
        el.scrollWidth = val;
        return this;
      } else {
        val = el.scrollWidth;
        return val;
      }
    };

    this.title = function (val) {
      if (val !== undefined) {
        this.el.title = val;
        return this;
      } else {
        val = this.el.title;
        return val;
      }
    };

    this.put = function (mom) {
      DOM.put(this.el, mom);
      return this;
    };

    this.ma = function () {
      return new Element(this.el.parentNode);
    };

    this.fore = function (elem) {
      var ref = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];
      elem = (0, _utilities.queryDOM)(elem); //TEST:20 Make sure this works.

      ref === null ? elem.parentNode.insertBefore(this.el, elem) : this.el.parentNode.insertBefore(elem, this.el);
      return this;
    };

    this.aft = function (elem) {
      var ref = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];
      elem = (0, _utilities.queryDOM)(elem); //TEST:10 Make sure this works.

      ref === null ? elem.parentNode.insertBefore(this.el, elem.nextElementSibling) : this.el.parentNode.insertBefore(elem, this.el.nextElementSibling);
      return this;
    };

    this.on = function (ev, callback) {
      if (document.addEventListener) {
        events.on(ev, this.el, function (e) {
          return callback(e, new Element(el));
        });
      } else {
        events.on(ev, this.el, function (e) {
          return callback(e, new Element(el));
        });
      }

      return this;
    };

    this.off = function (ev, callback) {
      if (document.addEventListener) {
        events.off(ev, this.el, callback);
      } else {
        events.offIE(ev, this.el, callback);
      }

      return this;
    };

    this.once = function (ev, callback) {
      if (document.addEventListener) {
        events.once(ev, this.el, function (e) {
          return callback(e, new Element(el));
        });
      } else {
        events.onceIE(ev, this.el, function (e) {
          return callback(e, new Element(el));
        });
      }

      return this;
    }; // this.toggle = function(onFunc, offFunc) {                                 //NOTE: May be unnecessary.
    //   window.toggleFlag = true;
    //
    //   if (toggleFlag) {
    //     onFunc();
    //     toggleFlag = false;
    //   } else {
    //     offFunc();
    //     toggleFlag = true;
    //   }
    //   return this;
    // };


    this.size = function (height, width) {
      this.el.style.height = height;
      this.el.style.width = width;
      return this;
    };

    this.show = function () {
      var disp = arguments.length <= 0 || arguments[0] === undefined ? 'block' : arguments[0];
      this.el.style.display = disp;
      return this;
    };

    this.hide = function () {
      this.el.style.display = 'none';
      return this;
    };

    this.viz = function (val) {
      this.el.style.visibility = val;
      return this;
    }; //---------Event Methods-----------------//


    this.blur = function () {
      var cb = arguments.length <= 0 || arguments[0] === undefined ? null : arguments[0];

      if (this.el.addEventListener) {
        events.blur(this.el, cb);
      } else {
        events.blurIE(this.el, cb);
      }

      return this;
    };

    this.click = function () {
      var cb = arguments.length <= 0 || arguments[0] === undefined ? null : arguments[0];

      if (this.el.addEventListener) {
        events.click(this.el, cb);
      } else {
        events.clickIE(this.el, cb);
      }

      return this;
    };

    this.dblClick = function () {
      var cb = arguments.length <= 0 || arguments[0] === undefined ? null : arguments[0];

      if (this.el.addEventListener) {
        events.dblClick(this.el, cb);
      } else {
        events.dblClickIE(this.el, cb);
      }

      return this;
    };

    this.error = function () {
      var cb = arguments.length <= 0 || arguments[0] === undefined ? null : arguments[0];

      if (this.el.addEventListener) {
        events.error(this.el, cb);
      } else {
        events.errorIE(this.el, cb);
      }

      return this;
    };

    this.focus = function () {
      var cb = arguments.length <= 0 || arguments[0] === undefined ? null : arguments[0];

      if (this.el.addEventListener) {
        events.focus(this.el, cb);
      } else {
        events.focusIE(this.el, cb);
      }

      return this;
    };

    this.focusIn = function () {
      var cb = arguments.length <= 0 || arguments[0] === undefined ? null : arguments[0];

      if (this.el.addEventListener) {
        events.focusIn(this.el, cb);
      } else {
        events.focusInIE(this.el, cb);
      }

      return this;
    };

    this.focusOut = function () {
      var cb = arguments.length <= 0 || arguments[0] === undefined ? null : arguments[0];

      if (this.el.addEventListener) {
        events.focusOut(this.el, cb);
      } else {
        events.focusOut(this.el, cb);
      }

      return this;
    };

    this.keyUp = function () {
      var cb = arguments.length <= 0 || arguments[0] === undefined ? null : arguments[0];

      if (this.el.addEventListener) {
        events.keyUp(this.el, cb);
      } else {
        events.keyUpIE(this.el, cb);
      }

      return this;
    };

    this.keyDown = function () {
      var cb = arguments.length <= 0 || arguments[0] === undefined ? null : arguments[0];

      if (this.el.addEventListener) {
        events.keyDown(this.el, cb);
      } else {
        events.keyDownIE(this.el, cb);
      }

      return this;
    };

    this.load = function () {
      var cb = arguments.length <= 0 || arguments[0] === undefined ? null : arguments[0];

      if (this.el.addEventListener) {
        events.load(this.el, cb);
      } else {
        events.loadIE(this.el, cb);
      }

      return this;
    };

    this.unLoad = function () {
      var cb = arguments.length <= 0 || arguments[0] === undefined ? null : arguments[0];

      if (this.el.addEventListener) {
        events.unLoad(this.el, cb);
      } else {
        events.unLoadIE(this.el, cb);
      }

      return this;
    };

    this.mouse = function (sfx) {
      var cb = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];

      if (this.el.addEventListener) {
        events.mouse(sfx, this.el, cb);
      } else {
        events.mouseIE(sfx, this.el, cb);
      }

      return this;
    };

    this.resize = function () {
      var cb = arguments.length <= 0 || arguments[0] === undefined ? null : arguments[0];

      if (this.el.addEventListener) {
        events.resize(this.el, cb);
      } else {
        events.resizeIE(this.el, cb);
      }

      return this;
    };

    this.scroll = function () {
      var cb = arguments.length <= 0 || arguments[0] === undefined ? null : arguments[0];

      if (this.el.addEventListener) {
        events.scroll(this.el, cb);
      } else {
        events.scrollIE(this.el, cb);
      }

      return this;
    };

    this.select = function () {
      var cb = arguments.length <= 0 || arguments[0] === undefined ? null : arguments[0];

      if (this.el.addEventListener) {
        events.select(this.el, cb);
      } else {
        events.selectIE(this.el, cb);
      }

      return this;
    }; /////// Experimental Methods ////////


    this.every = function (eachFunc) {
      this.els.forEach(function (elem, i, a) {
        eachFunc(elem, a, i);
      });
      return this;
    };

    this.only = function (num, func) {
      var arr = arguments.length <= 2 || arguments[2] === undefined ? null : arguments[2];
      (0, _logger.log)(typeof onlyArr === 'undefined' ? 'undefined' : _typeof(onlyArr), 'yellow');

      if (null !== arr) {
        if (typeof onlyArr === 'undefined') {
          window.onlyArr = arr;
          window.eachCount = 1;
        } else {
          if (onlyArr !== arr) {
            window.eachCount = 1;
            window.onlyArr = arr;
          } else {
            eachCount++;
          }
        }
      }

      if (num === eachCount) {
        func();
        (0, _logger.log)(eachCount, ['red', 'bold']);
      } else {
        (0, _logger.log)(eachCount, ['blue', 'bold']);
      } // if (eachCount === onlyArr.length) {
      //   eachCount = '';
      // }


      (0, _logger.log)(eachCount, 'white');
      return this;
    };

    this.func = function (func) {
      var mod = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];

      if (null === mod) {
        func(this.el);
      } else if (mod === 'style') {
        func(this.el.style);
      }

      return this;
    }; //<<================Attribute Methods==================>>//


    this.attrib = function (attrib, val) {
      //TEST:0 Make sure this works
      var r = val !== undefined && val !== 'remove' ? (this.el.setAttribute(attrib, val), undefined) : attrib !== undefined && val !== 'remove' ? this.el.getAttribute(attrib) : (this.el.removeAttribute(attrib), undefined); // (r !== undefined) ?                                                     //TODO:10 See if you can make this work.
      //   return r
      // :
      //   return this;

      if (r !== undefined) {
        return r;
      } else {
        return this;
      }
    };

    this.src = function (val) {
      if (val !== undefined) {
        this.el.src = val;
        return this;
      } else {
        val = this.el.src;
        return val;
      }
    };

    this.alt = function (val) {
      if (val !== undefined) {
        this.el.alt = val;
        return this;
      } else {
        val = this.el.alt;
        return val;
      }
    };

    this.href = function (val) {
      if (val !== undefined) {
        this.el.href = val;
        return this;
      } else {
        val = this.el.href;
        return val;
      }
    };

    this.hash = function () {
      var _re = /\#.*/;

      var hash = _re.exec(el.href);

      return hash;
    };

    this.type = function (val) {
      if (val !== undefined) {
        this.el.type = val;
        return this;
      } else {
        val = this.el.type;
        return val;
      }
    };
  }

  ;
  /***/
},
/* 26 */

/***/
function (module, exports, __webpack_require__) {
  ;
  /*
  logger.js
  
  This file contains the code for the various logging functions
  of the library.
  
  Author: Eric James Foster
  License: ISC
  */

  var colors = __webpack_require__(27); //DONE:90 Add second argument for log ID purposes, figure best way to approach this.
  //Console.log alias function.                                                  //DONE:140 Make sure date is logging properly.


  var log = function log(text, style, tyme) {
    var colr = Array.isArray(style) ? style[0] : style,
        styl = Array.isArray(style) ? style[1] : null,
        tym = tyme || false;
    var time = new Date(),
        hours = time.getHours(),
        mins = time.getMinutes(),
        secs = time.getSeconds();

    if (secs <= 9) {
      secs = '0' + String(secs);
    }

    if (mins <= 9) {
      mins = '0' + String(mins);
    }

    var abbr = hours >= 12 ? 'pm' : 'am';
    var stan = hours >= 13 ? hours - 12 : hours; //DONE:40 Either fix singular hours, or choose alternate.

    if (stan === 0) {
      hours = stan + 12;
    } else {
      hours = stan;
    }

    time = hours + ':' + mins + ':' + secs + abbr;
    var t = tym ? time : '';

    if (typeof document === 'undefined') {
      return console.log(colors(text, {
        fg: colr,
        style: styl
      }) + '   '.repeat(10) + t);
    } else {
      var color = colr,
          bgColor = styl,
          css = 'background: ' + bgColor + '; color: ' + color;
      return console.log('%c' + text + '%s', css, '   '.repeat(10) + t);
    }
  }; //Console.error alias function.


  var err = function err(text, tyme) {
    var colr = 'red',
        styl = 'bold',
        tym = tyme || false;
    var time = new Date(),
        hours = time.getHours(),
        mins = time.getMinutes(),
        secs = time.getSeconds();

    if (secs <= 9) {
      secs = '0' + String(secs);
    }

    if (mins <= 9) {
      mins = '0' + String(mins);
    }

    var abbr = hours >= 12 ? 'pm' : 'am';
    var stan = hours >= 13 ? hours - 12 : hours;

    if (stan === 0) {
      hours = stan + 12;
    } else {
      hours = stan;
    }

    time = hours + ':' + mins + ':' + secs + abbr;
    var t = tym ? time : '';

    if (typeof document === 'undefined') {
      return console.log(colors(text, {
        fg: colr,
        style: styl
      }) + '   '.repeat(10) + t);
    } else {
      var color = colr,
          bgColor = '',
          css = 'background: ' + bgColor + '; color: ' + color;
      return console.error('%c' + text + '%s', css, '   '.repeat(10) + t);
    }
  }; //Console.error alias function.


  var error = function error(text) {
    return console.error(text);
  }; //Console.info alias function.


  var info = function info(text, tyme) {
    var colr = '#008cff',
        styl = 'bold',
        tym = tyme || false;
    var time = new Date(),
        hours = time.getHours(),
        mins = time.getMinutes(),
        secs = time.getSeconds();

    if (secs <= 9) {
      secs = '0' + String(secs);
    }

    if (mins <= 9) {
      mins = '0' + String(mins);
    }

    var abbr = hours >= 12 ? 'pm' : 'am';
    var stan = hours >= 13 ? hours - 12 : hours;

    if (stan === 0) {
      hours = stan + 12;
    } else {
      hours = stan;
    }

    time = hours + ':' + mins + ':' + secs + abbr;
    var t = tym ? time : '';

    if (typeof document === 'undefined') {
      colr = 'blueBright';
      return console.log(colors(text, {
        fg: colr,
        style: styl
      }) + '   '.repeat(10) + t);
    } else {
      var color = colr,
          bgColor = '',
          css = 'background: ' + bgColor + '; color: ' + color;
      return console.info('%c' + text + '%s', css, '   '.repeat(10) + t);
    }
  }; //Console.warn alias function.


  var warn = function warn(text, tyme) {
    var colr = 'orange',
        styl = 'bold',
        tym = tyme || false;
    var time = new Date(),
        hours = time.getHours(),
        mins = time.getMinutes(),
        secs = time.getSeconds();

    if (secs <= 9) {
      secs = '0' + String(secs);
    }

    if (mins <= 9) {
      mins = '0' + String(mins);
    }

    var abbr = hours >= 12 ? 'pm' : 'am';
    var stan = hours >= 13 ? hours - 12 : hours;

    if (stan === 0) {
      hours = stan + 12;
    } else {
      hours = stan;
    }

    time = hours + ':' + mins + ':' + secs + abbr;
    var t = tym ? time : '';

    if (typeof document === 'undefined') {
      colr = 'yellow';
      colr = 'blueBright';
      return console.log(colors(text, {
        fg: colr,
        style: styl
      }) + '   '.repeat(10) + t);
    } else {
      var color = colr,
          bgColor = '',
          css = 'background: ' + bgColor + '; color: ' + color;
      return console.warn('%c' + text + '%s', css, '   '.repeat(10) + t);
    }
  };

  var inspect = function inspect(obj) {
    return console.log(obj);
  };

  module.exports = {
    log: log,
    err: err,
    info: info,
    warn: warn,
    inspect: inspect
  };
  /***/
},
/* 27 */

/***/
function (module, exports, __webpack_require__) {
  ;

  var names = ['black', 'red', 'green', 'yellow', 'blue', 'magenta', 'cyan', 'white'];
  var namesBright = names.map(function (name) {
    return name + 'Bright';
  });
  var namesStyle = ['bold', 'dim', 'underline', 'blink', null, 'invert', 'hidden'];
  var RESET = '\x1b[0m';
  var Colors = {
    fg: {},
    bg: {},
    style: {}
  }; // generate foreground normal colors

  for (var i in names) {
    Colors.fg[names[i]] = +i + 30;
  } // generate foreground bright colors


  for (var i in namesBright) {
    Colors.fg[namesBright[i]] = +i + 90;
  } // generate background normal colors


  for (var i in names) {
    Colors.bg[names[i]] = +i + 40;
  } // generate background bright colors


  for (var i in namesBright) {
    Colors.bg[namesBright[i]] = +i + 100;
  } // generate style attributes


  for (var i in namesStyle) {
    if (!namesStyle[i]) continue;
    Colors.style[namesStyle[i]] = +i + 1;
  }

  function formatColor(color) {
    color = color || {};
    var fg = Colors.fg[color.fg] || 39;
    var bg = Colors.bg[color.bg] || 49;
    var style = Colors.style[color.style] || 0; //	var code = '\x1b';

    return '\x1b[' + style + ';' + fg + ';' + bg + 'm';
  }

  function colorize(str, colors) {
    if (!str || _typeof2(colors) !== 'object') return str;
    return formatColor(colors) + str + RESET;
  }

  module.exports = colorize;
  module.exports.colors = Colors;
  module.exports.names = names.concat(namesBright);
  module.exports.styles = namesStyle.filter(function (name) {
    return !!name;
  });
  /***/
},
/* 28 */

/***/
function (module, exports, __webpack_require__) {
  ;

  var _logger = __webpack_require__(26); //TODO:20 browser detection functionality, noop(), merge(), toggle().


  var isArray = function isArray(arr) {
    return Array.isArray(arr);
  };
  /*
  utilities.js
  
  This file contains various functions for the library, either public or not,
  that don't fit into any other module.
  
  Author: Eric James Foster
  License: ISC
  */


  var isElement = function isElement(el) {
    if (el.element) {
      return true;
    } else {
      return false;
    }
  };

  var isDOMElement = function isDOMElement(el) {
    return el.tagName ? true : false;
  };
  /*This function combines querySelector and querySelectorAll, and becomes a noop if 'el' is a variable. There is an optional 2nd argument 'mod', that
  accepts the string 'all' to modify behaviour of the function. By default, 'mod' is null. If the string 'all' is passed as the 2nd argument, the function
  will use querySelectorAll() instead of querySelector(), meaning an array will be returned if possible. */


  var queryDOM = function queryDOM(el) {
    var lm = void 0,
        lms = [];

    if (typeof el === 'string') {
      if (el.charAt(0) === '.') {
        el = el.substring(1, el.length);
        lm = document.getElementsByClassName(el);

        if (lm.length !== 0) {
          if (lm.length === 1) {
            lms = lm[0];
          } else {
            for (var i = 0; i < lm.length; i++) {
              lms.push(lm[i]);
            }
          }
        } else {
          return null;
        }
      } else if (el.charAt(0) !== '#' && el.indexOf('[') === -1 && el.indexOf(':') === -1 && el.indexOf(' ') === -1) {
        lm = document.getElementsByTagName(el);

        if (lm.length !== 0) {
          if (lm.length === 1) {
            lms = lm[0];
          } else {
            for (var j = 0; j < lm.length; j++) {
              lms.push(lm.item(j));
            }
          }
        } else {
          return null;
        }
      } else {
        lm = document.querySelectorAll(el);

        if (lm.length <= 1) {
          lm = undefined;
          lm = document.querySelector(el);
          return lm;
        } else {
          return lm;
        }
      }

      return lms;
    } else {
      return el;
    }
  };
  /*This function copies the prototype object of a superConstructor to the prototype object
  of a constructor. It functions just like nodes' util.inherits function, it copies methods only,
  not internal properties.*/


  var proto = function proto(constructer, superConstructer) {
    construct.prototype = Object.create(superConstructer.prototype);
    constructer.prototype.constructor = constructer;
    return constructer;
  };
  /*This convenience function sets imported module function names as global variables, so that
  the module variable doesn't need to preface every function.*/


  var functions = function functions(funcs, module) {
    //TEST:110 Test this with other node_modules.
    var context = module || this;

    if (Array.isArray(funcs)) {
      funcs.forEach(function (func) {
        var evil = new Function('window.' + func + ' = ' + 'this.' + func + ';');
        evil.call(context);
      }, context);
    } else {
      (function () {
        var evil = new Function('window.' + funcs + ' = ' + 'this.' + funcs + ';');
        evil.call(context);
      }).apply(context);
    }
  }; //This practically useless function will lock up the browser for a preset amount of time.


  var sleep = function sleep(milliseconds) {
    var start = new Date().getTime();

    while (true) {
      if (new Date().getTime() - start > milliseconds) {
        break;
      }
    }
  }; //This function will alternate function calls depending on the value of a global flag.


  function shifter(onFunc, offFunc) {
    window.toggleFlag = true;
    return function () {
      if (toggleFlag) {
        onFunc();
        toggleFlag = false;
      } else {
        offFunc();
        toggleFlag = true;
      }
    };
  }

  ; //Boolean function returns true if given function has given ancestor, and false otherwise. Checks 6 parents deep.

  function hasAncestor(l, ance) {
    var tick,
        ancestor,
        ancestors = [1, 2, 3, 4, 5];

    if (typeof ance === 'string') {
      ancestor = queryDOM(ance);
    } else {
      ancestor = ance;
    }

    ancestors[0] = l.parentNode;
    ancestors[1] = ancestors[0].parentNode;

    if (!!ancestors[1].parentNode) {
      ancestors[2] = ancestors[1].parentNode;
    }

    if (!!ancestors[2].parentNode) {
      ancestors[3] = ancestors[2].parentNode;
    }

    if (!!ancestors[3].parentNode) {
      ancestors[4] = ancestors[3].parentNode;
    } //For inspection....
    // var dir           = {};
    //     dir.ance      = ance;
    //     dir.l         = l;
    //     dir.ancestor  = ancestor;
    //     dir.ancestors = ancestors;
    //
    // console.log(dir);


    tick = 0;

    for (var i = 0; i < ancestors.length; i++) {
      if (ancestors[i] === ancestor) tick++;
    }

    if (tick > 0) return true;else return false;
  }

  ;

  function lookBehind(leftContextRE, matchRE, subject) {
    var returnMatch, match, leftContext;
    match = matchRE.exec(subject)[0];
    leftContext = subject.substring(0, subject.indexOf(match));

    if (leftContextRE.test(leftContext)) {
      returnMatch = match;
    } else {
      returnMatch = false;
    }

    return returnMatch;
  }

  ;

  function isMobile() {
    this.android = function () {
      return navigator.userAgent.match(/Android/i);
    };

    this.blackBerry = function () {
      return navigator.userAgent.match(/BlackBerry/i);
    }, this.iOS = function () {
      return navigator.userAgent.match(/iPhone|iPad|iPod/i);
    }, this.operaMini = function () {
      return navigator.userAgent.match(/Opera Mini/i);
    }, this.windowsMobile = function () {
      return navigator.userAgent.match(/IEMobile/i);
    }, this.any = function () {
      return this.android() || this.blackBerry() || this.iOS() || this.operaMini() || this.windowsMobile();
    };
    return this.any();
  }

  module.exports = {
    queryDOM: queryDOM,
    functions: functions,
    isArray: isArray,
    isElement: isElement,
    isDOMElement: isDOMElement,
    shifter: shifter,
    sleep: sleep,
    proto: proto,
    hasAncestor: hasAncestor,
    lookBehind: lookBehind,
    isMobile: isMobile
  };
  /***/
},
/* 29 */

/***/
function (module, exports, __webpack_require__) {
  ;

  var _logger = __webpack_require__(26);

  var _utilities = __webpack_require__(28);

  var utils = _interopRequireWildcard(_utilities);

  function _interopRequireWildcard(obj) {
    if (obj && obj.__esModule) {
      return obj;
    } else {
      var newObj = {};

      if (obj != null) {
        for (var key in obj) {
          if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
        }
      }

      newObj["default"] = obj;
      return newObj;
    }
  } //DONE:10 Complete X-Browser support for these 3 functions.

  /*
  events.js
  
  This file contains code for the librarys' convenience EventListener
  alias functions.
  
  Author: Eric James Foster
  License: ISC
  */


  var go = function go(cb) {
    return document.addEventListener('DOMContentLoaded', cb());
  };

  var goIE = function goIE(cb) {
    return document.attachEvent('onDOMContentLoaded', cb());
  }; //Function for setting event listeners.


  var on = function on(event, el, callback) {
    //TODO: allow arg 'el' to be an array.
    if (typeof el === 'string') {
      if (el[0] === '#') {
        el = el.slice(1);
        return document.getElementById(el).addEventListener(event, callback);
      } else if (el[0] === '.') {
        el = el.slice(1);
        return document.getElementsByClassName(el)[0].addEventListener(event, callback);
      } else {
        return document.getElementsByTagName(el).addEventListener(event, callback);
      }
    } else {
      return el.addEventListener(event, callback);
    }
  };

  var onIE = function onIE(event, el, callback) {
    if (typeof el === 'string') {
      if (el[0] === '#') {
        el = el.slice(1);
        return document.getElementById(el).attachEvent('on' + event, callback);
      } else if (el[0] === '.') {
        el = el.slice(1);
        return document.getElementsByClassName(el)[0].attachEvent('on' + event, callback);
      } else {
        return document.getElementsByTagName(el).attachEvent('on' + event, callback);
      }
    } else {
      return el.attachEvent('on' + event, callback);
    }
  }; //Function for removing event listeners.


  var off = function off(event, el, callback) {
    if (typeof el === 'string') {
      if (el[0] === '#') {
        el = el.slice(1);
        return document.getElementById(el).removeEventListener(event, callback);
      } else if (el[0] === '.') {
        el = el.slice(1);
        return document.getElementsByClassName(el)[0].removeEventListener(event, callback);
      } else {
        return document.getElementsByTagName(el).removeEventListener(event, callback);
      }
    } else {
      el.removeEventListener(event, callback);
    }
  }; //Function for removing event listeners.


  var offIE = function offIE(event, el, callback) {
    if (typeof el === 'string') {
      if (el[0] === '#') {
        el = el.slice(1);
        return document.getElementById(el).detachEvent('on' + event, callback);
      } else if (el[0] === '.') {
        el = el.slice(1);
        return document.getElementsByClassName(el)[0].detachEvent('on' + event, callback);
      } else {
        return document.getElementsByTagName(el).detachEvent('on' + event, callback);
      }
    } else {
      el.detachEvent('on' + event, callback);
    }
  };

  var once = function once(event, el, callback) {
    //DONE:60 Finish once function.
    var cb = callback; //DONE:80 Test once function.

    var callBack = function callBack(e) {
      cb(e);
      el.removeEventListener(event, callBack);
    };

    el = utils.queryDOM(el);
    return el.addEventListener(event, callBack);
  };

  var onceIE = function onceIE(event, el, callback) {
    var cb = callback; //DONE:90 Test onceIE function.

    var callBack = function callBack(e) {
      cb(e);
      el.detachEvent('on' + event, callBack);
    };

    el = utils.queryDOM(el);
    return el.attachEvent('on' + event, callBack);
  };

  function spark(evt, el) {
    var ev = new MouseEvent(evt, {
      bubbles: true,
      cancelable: true,
      view: window
    });
    el.dispatchEvent(ev);
  }

  function sparkIE(evt, el) {
    var ev = document.createEventObject();
    l = document.querySelector(el);
    evt.eventType = 'on' + evt;
    el.fireEvent('on' + evt, ev);
  }

  function blur(el) {
    var cb = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];

    if (cb === null) {
      var evt = new MouseEvent('blur', {
        bubbles: true,
        cancelable: true,
        view: window
      });
      el.dispatchEvent(evt);
    } else {
      el.addEventListener('blur', cb);
    }
  }

  function blurIE(el) {
    var cb = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];

    if (cb === null) {
      var evt = document.createEventObject();
      evt.eventType = 'onblur';
      el.fireEvent('on' + 'blur', evt);
    } else {
      el.attachEvent('on' + 'blur', cb);
    }
  }

  function click(el) {
    var cb = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];

    if (cb === null) {
      var evt = new MouseEvent('click', {
        bubbles: true,
        cancelable: true,
        view: window
      });
      el.dispatchEvent(evt);
    } else {
      el.addEventListener('click', cb);
    }
  }

  function clickIE(el) {
    var cb = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];

    if (cb === null) {
      var evt = document.createEventObject();
      evt.eventType = 'on' + 'click';
      el.fireEvent('on' + 'click', evt);
    } else {
      el.attachEvent('on' + 'click', cb);
    }
  }

  function dblClick(el) {
    var cb = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];

    if (cb === null) {
      var evt = new MouseEvent('dblclick', {
        bubbles: true,
        cancelable: true,
        view: window
      });
      el.dispatchEvent(evt);
    } else {
      el.addEventListener('dblclick', cb);
    }
  }

  function dblClickIE(el) {
    var cb = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];

    if (cb === null) {
      var evt = document.createEventObject();
      evt.eventType = 'ondblclick';
      el.fireEvent('on' + 'dblclick', evt);
    } else {
      el.attachEvent('on' + 'dblclick', cb);
    }
  }

  function error(el) {
    var cb = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];

    if (cb === null) {
      var evt = new MouseEvent('error', {
        bubbles: true,
        cancelable: true,
        view: window
      });
      el.dispatchEvent(evt);
    } else {
      el.addEventListener('error', cb);
    }
  }

  function errorIE(el) {
    var cb = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];

    if (cb === null) {
      var evt = document.createEventObject();
      evt.eventType = 'onerror';
      el.fireEvent('on' + 'error', evt);
    } else {
      el.attachEvent('on' + 'error', cb);
    }
  }

  function focus(el) {
    var cb = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];

    if (cb === null) {
      var evt = new MouseEvent('focus', {
        bubbles: true,
        cancelable: true,
        view: window
      });
      el.dispatchEvent(evt);
    } else {
      el.addEventListener('focus', cb);
    }
  }

  function focusIE(el) {
    var cb = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];

    if (cb === null) {
      var evt = document.createEventObject();
      evt.eventType = 'onfocus';
      el.fireEvent('on' + 'focus', evt);
    } else {
      el.attachEvent('on' + 'focus', cb);
    }
  }

  function focusIn(el) {
    var cb = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];

    if (cb === null) {
      var evt = new MouseEvent('focusin', {
        bubbles: true,
        cancelable: true,
        view: window
      });
      el.dispatchEvent(evt);
    } else {
      el.addEventListener('focusin', cb);
    }
  }

  function focusInIE(el) {
    var cb = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];

    if (cb === null) {
      var evt = document.createEventObject();
      evt.eventType = 'onfocusin';
      el.fireEvent('on' + 'focusin', evt);
    } else {
      el.attachEvent('on' + 'focusin', cb);
    }
  }

  function focusOut(el) {
    var cb = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];

    if (cb === null) {
      var evt = new MouseEvent('focusout', {
        bubbles: true,
        cancelable: true,
        view: window
      });
      el.dispatchEvent(evt);
    } else {
      el.addEventListener('focusout', cb);
    }
  }

  function focusOutIE(el) {
    var cb = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];

    if (cb === null) {
      var evt = document.createEventObject();
      evt.eventType = 'onfocusout';
      el.fireEvent('on' + 'focusout', evt);
    } else {
      el.attachEvent('on' + 'focusout', cb);
    }
  }

  function keyUp(el) {
    var cb = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];

    if (cb === null) {
      var evt = new MouseEvent('keyup', {
        bubbles: true,
        cancelable: true,
        view: window
      });
      el.dispatchEvent(evt);
    } else {
      el.addEventListener('keyup', cb);
    }
  }

  function keyUpIE(el) {
    var cb = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];

    if (cb === null) {
      var evt = document.createEventObject();
      evt.eventType = 'onkeyup';
      el.fireEvent('on' + 'keyup', evt);
    } else {
      el.attachEvent('on' + 'keyup', cb);
    }
  }

  function keyDown(el) {
    var cb = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];

    if (cb === null) {
      var evt = new MouseEvent('keydown', {
        bubbles: true,
        cancelable: true,
        view: window
      });
      el.dispatchEvent(evt);
    } else {
      el.addEventListener('keydown', cb);
    }
  }

  function keyDownIE(el) {
    var cb = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];

    if (cb === null) {
      var evt = document.createEventObject();
      evt.eventType = 'onkeydown';
      el.fireEvent('on' + 'keydown', evt);
    } else {
      el.attachEvent('on' + 'keydown', cb);
    }
  }

  function load(el) {
    var cb = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];

    if (cb === null) {
      var evt = new MouseEvent('load', {
        bubbles: true,
        cancelable: true,
        view: window
      });
      el.dispatchEvent(evt);
    } else {
      el.addEventListener('load', cb);
    }
  }

  function loadIE(el) {
    var cb = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];

    if (cb === null) {
      var evt = document.createEventObject();
      evt.eventType = 'onload';
      el.fireEvent('on' + 'load', evt);
    } else {
      el.attachEvent('on' + 'load', cb);
    }
  }

  function unLoad(el) {
    var cb = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];

    if (cb === null) {
      var evt = new MouseEvent('unload', {
        bubbles: true,
        cancelable: true,
        view: window
      });
      el.dispatchEvent(evt);
    } else {
      el.addEventListener('unload', cb);
    }
  }

  function unLoadIE(el) {
    var cb = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];

    if (cb === null) {
      var evt = document.createEventObject();
      evt.eventType = 'onunload';
      el.fireEvent('on' + 'unload', evt);
    } else {
      el.attachEvent('on' + 'unload', cb);
    }
  }

  function mouse(sufx, el) {
    var cb = arguments.length <= 2 || arguments[2] === undefined ? null : arguments[2]; //sufx is string, options are 'up', 'down', 'enter', 'leave', 'over', 'out' and 'move'.

    if (cb === null) {
      var evt = new MouseEvent('mouse' + sufx, {
        bubbles: true,
        cancelable: true,
        view: window
      });
      el.dispatchEvent(evt);
    } else {
      el.addEventListener('mouse' + sufx, cb);
    }
  }

  function mouseIE(sufx, el) {
    var cb = arguments.length <= 2 || arguments[2] === undefined ? null : arguments[2];

    if (cb === null) {
      var evt = document.createEventObject();
      evt.eventType = 'onmouse' + sufx;
      el.fireEvent('on' + 'mouse' + sufx, evt);
    } else {
      el.attachEvent('on' + 'mouse' + sufx, cb);
    }
  }

  function reSize(el) {
    var cb = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];

    if (cb === null) {
      var evt = new MouseEvent('resize', {
        bubbles: true,
        cancelable: true,
        view: window
      });
      el.dispatchEvent(evt);
    } else {
      el.addEventListener('resize', cb);
    }
  }

  function reSizeIE(el) {
    var cb = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];

    if (cb === null) {
      var evt = document.createEventObject();
      evt.eventType = 'onresize';
      el.fireEvent('on' + 'resize', evt);
    } else {
      el.attachEvent('on' + 'resize', cb);
    }
  }

  function scroll(el) {
    var cb = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];

    if (cb === null) {
      var evt = new MouseEvent('scroll', {
        bubbles: true,
        cancelable: true,
        view: window
      });
      el.dispatchEvent(evt);
    } else {
      el.addEventListener('scroll', cb);
    }
  }

  function scrollIE(el) {
    var cb = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];

    if (cb === null) {
      var evt = document.createEventObject();
      evt.eventType = 'onscroll';
      el.fireEvent('on' + 'scroll', evt);
    } else {
      el.attachEvent('on' + 'scroll', cb);
    }
  }

  function select(el) {
    var cb = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];

    if (cb === null) {
      var evt = new MouseEvent('select', {
        bubbles: true,
        cancelable: true,
        view: window
      });
      el.dispatchEvent(evt);
    } else {
      el.addEventListener('select', cb);
    }
  }

  function selectIE(el) {
    var cb = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];

    if (cb === null) {
      var evt = document.createEventObject();
      evt.eventType = 'onselect';
      el.fireEvent('on' + 'select', evt);
    } else {
      el.attachEvent('on' + 'select', cb);
    }
  }

  module.exports = {
    blur: blur,
    blurIE: blurIE,
    click: click,
    clickIE: clickIE,
    dblClick: dblClick,
    dblClickIE: dblClickIE,
    error: error,
    errorIE: errorIE,
    focus: focus,
    focusIE: focusIE,
    focusIn: focusIn,
    focusInIE: focusInIE,
    focusOut: focusOut,
    focusOutIE: focusOutIE,
    keyUp: keyUp,
    keyUpIE: keyUpIE,
    keyDown: keyDown,
    keyDownIE: keyDownIE,
    load: load,
    loadIE: loadIE,
    unLoad: unLoad,
    unLoadIE: unLoadIE,
    mouse: mouse,
    mouseIE: mouseIE,
    reSize: reSize,
    reSizeIE: reSizeIE,
    scroll: scroll,
    scrollIE: scrollIE,
    select: select,
    selectIE: selectIE,
    spark: spark,
    sparkIE: sparkIE,
    go: go,
    goIE: goIE,
    on: on,
    onIE: onIE,
    off: off,
    offIE: offIE,
    once: once,
    onceIE: onceIE
  };
  /***/
},
/* 30 */

/***/
function (module, exports, __webpack_require__) {
  ;

  var _element = __webpack_require__(25);

  var _element2 = _interopRequireDefault(_element);

  var _logger = __webpack_require__(26);

  var _utilities = __webpack_require__(28);

  var utils = _interopRequireWildcard(_utilities);

  function _interopRequireWildcard(obj) {
    if (obj && obj.__esModule) {
      return obj;
    } else {
      var newObj = {};

      if (obj != null) {
        for (var key in obj) {
          if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
        }
      }

      newObj["default"] = obj;
      return newObj;
    }
  }

  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
      "default": obj
    };
  } //TODO:0 Check out querySelector() method, see if it helps out.
  //DOING:0 go() DOMREady function, Class toggling method, aft(), fore(), size(), show(), hide().
  // ------------------- This function is now run straight from index.js---------------------------//
  //This function queries the dom, getting one element for each query (i.e. class/tags), creates
  //an Element object with it and returns it, so that it may be easily styled.
  // var dom = function(el) {
  //   el = utils.queryDOM(el);
  //
  //   return new Element(el);
  // };

  /*function for insterting template literals into the DOM.
  
  bones(`
  
  <html>
    <head></head>
    <body></body>
  </html>
  
  `);
  
  */


  var bones = function bones(tempLit) {
    var elem = arguments.length <= 1 || arguments[1] === undefined ? 'body' : arguments[1];
    elem = utils.queryDOM(elem);
    elem.innerHTML += tempLit;
    return elem;
  }; //Create element alias function.

  /*
  DOM.js
  
  This file contains the code for the elements.js librarys' DOM manipulation
  convenience functions.
  
  Author: Eric James Foster
  License: ISC
  */


  var make = function make(l, tag) {
    var t = tag || 'div',
        el = document.createElement(t);

    if (l[0] === '#') {
      l = l.slice(1);
      el.id = l;
      return new _element2["default"](el);
    } else if (l[0] === '.') {
      l = l.slice(1);
      el.className = l;
      return new _element2["default"](el);
    }
  };
  /*DOM querying alias function. Will return an array if there is more than one result. If there is
   only 1 it will NOT, even if the CSS Selector is a className or tagName.*/
  //NOTE: Now referencing queryDOM() function from index.js.


  var el = function el(_el) {
    return utils.queryDOM(_el);
  }; //------------------------------This function is not being used in the current build ---------------------------//
  //DOM querying function, same as above, but it will return an array if a tag or class name are given as argument.
  // var all = function(l) {
  //   return utils.queryDOM(el, 'all');
  // };
  //Function for appending elements to other elements.


  var put = function put(el, mom) {
    //DONE:120 Make sure this works.
    if (typeof el === 'string') {
      //IDEA:0 If el doesn't exist, create it and give it id/class.
      if (el[0] === '#') {
        el = el.slice(1);

        if (typeof mom === 'string') {
          if (mom[0] === '#') {
            //TEST:40 Test this function thoroughly.
            mom = mom.slice(1);
            return document.getElementById(mom).appendChild(document.getElementById(el));
          } else if (mom[0] === '.') {
            mom = mom.slice(1);
            return document.getElementsByClassName(mom)[0].appendChild(document.getElementById(el));
          } else {
            return document.getElementsByTagName(mom)[0].appendChild(document.getElementById(el));
          }
        } else {
          return mom.appendChild(document.getElementById(el));
        }
      } else if (el[0] === '.') {
        el = el.slice(1);

        if (typeof mom === 'string') {
          if (mom[0] === '#') {
            mom = mom.slice(1);
            return document.getElementById(mom).appendChild(document.getElementsByClassName(el)[0]);
          } else if (mom[0] === '.') {
            mom = mom.slice(1);
            return document.getElementsByClassName(mom)[0].appendChild(document.getElementsByClassName(el)[0]);
          } else {
            return document.getElementsByTagName(mom)[0].appendChild(document.getElementsByClassName(el)[0]);
          }
        } else {
          return mom.appendChild(document.getElementsByClassName(el)[0]);
        }
      } else {
        if (typeof mom === 'string') {
          if (mom[0] === '#') {
            mom = mom.slice(1);
            return document.getElementById(mom).appendChild(document.getElementsByTagName(el)[0]);
          } else if (mom[0] === '.') {
            mom = mom.slice(1);
            return document.getElementsByClassName(mom)[0].appendChild(document.getElementsByTagName(el)[0]);
          } else {
            return document.getElementsByTagName(mom)[0].appendChild(document.getElementsByTagName(el)[0]);
          }
        } else {
          return mom.appendChild(document.getElementsByTagName(el)[0]);
        }
      }
    } else {
      if (typeof mom === 'string') {
        if (mom[0] === '#') {
          mom = mom.slice(1);
          return document.getElementById(mom).appendChild(el);
        } else if (mom[0] === '.') {
          mom = mom.slice(1);
          return document.getElementsByClassName(mom)[0].appendChild(el);
        } else {
          return document.getElementsByTagName(mom)[0].appendChild(el);
        }
      } else {
        return mom.appendChild(el);
      }
    }
  }; //Function for deleting elements from the DOM tree.


  var kill = function kill(el) {
    if (typeof el === 'string') {
      if (el[0] === '#') {
        el = el.slice(1);
        return document.getElementById(el).parentNode.removeChild(document.getElementById(el));
      } else if (el[0] === '.') {
        el = el.slice(1);
        return document.getElementsByClassName(el)[0].parentNode.removeChild(document.getElementsByClassName(el)[0]);
      } else {
        return document.getElementsByTagName(el)[0].parentNode.removeChild(getElementsByTagName(el)[0]);
      }
    } else {
      return el.parentNode.removeChild(el);
    }
  }; //DOM function for inserting an element before a specified node.


  var fore = function fore(ref, elem) {
    return utils.queryDOM(ref).parentNode.insertBefore(utils.queryDOM(elem), utils.queryDOM(ref));
  }; //DOM function for inserting an element after a specified node.


  var aft = function aft(ref, elem) {
    ref = utils.queryDOM(ref);
    ref = ref.nextElementSibling;
    return ref.parentNode.insertBefore(utils.queryDOM(elem), ref);
  }; //DOM function for showing an element, or a list of elements.


  var show = function show(elem) {
    var disp = arguments.length <= 1 || arguments[1] === undefined ? 'block' : arguments[1];
    elem = utils.queryDOM(elem);

    if (Array.isArray(elem)) {
      elem.forEach(function (l) {
        l.style.display = disp;
      });
    } else {
      elem.style.display = disp;
    }
  }; //DOM function for hiding an element, or a list of elements.


  var hide = function hide(elem) {
    elem = utils.queryDOM(elem);

    if (Array.isArray(elem)) {
      elem.forEach(function (l) {
        l.style.display = 'none';
      });
    } else {
      elem.style.display = 'none';
    }
  }; //DOM function for setting height and width of an element. 's' is an object, with height and width as keys.


  var size = function size(elem, h, w) {
    elem = utils.queryDOM(elem);
    elem.style.height = h;
    elem.style.width = w;
    return elem;
  }; //function clones given node.ddeep is a boolean, if true, clone will include all descendants as well as node and its' attributes.


  var clone = function clone(elem, deep) {
    var node = elem.cloneNode(deep);
    return node;
  }; //Function for setting css style properties of elements.
  // var style = function(el) {
  //   if (el[0] === '#') {                                                      //DONE:110 Give this chaining functionality.
  //     el = el.slice(1);
  //     return document.getElementById(el).style;
  //   } else if (el[0] === '.') {
  //     el = el.slice(1);
  //     return document.getElementsByClassName(el)[0].style;
  //   } else {
  //     return document.getElementsByTagName(el)[0].style;
  //   }
  // };


  module.exports = {
    make: make,
    bones: bones,
    clone: clone,
    // all: all,
    put: put,
    kill: kill,
    fore: fore,
    aft: aft,
    show: show,
    hide: hide,
    size: size
  };
  /***/
},
/* 31 */

/***/
function (module, exports, __webpack_require__) {
  ;

  var _logger = __webpack_require__(26); //DONE:20 Complete X-Browser support for both functions.
  //This is an alias function for XMLHttpRequests.


  var xhr = function xhr(url, fd, method) {
    //DONE:80 Perfect this function.
    var formData; //DONE:100 Build FormData in function from object that user passes as an argument.

    if (fd) {
      //DONE:70 Need async ajax function
      if (Object.getOwnPropertyNames(fd).length === 0) {
        formData = fd; //log(Object.getOwnPropertyNames(fd).length);
      } else {
        formData = new FormData();

        for (var key in fd) {
          //TEST:50 Test this function.
          formData.append(key, fd[key]);
        }
      }
    } else {
      formData = null;
    } //log('fd'); log(formData);


    var m = method || 'get'; // var data = fd || null;

    var val;

    var ajax = function ajax() {
      var ajax = new XMLHttpRequest();

      ajax.onloadend = function () {
        if (ajax.status === 200) {
          val = this.response;
        }
      };

      ajax.open(m, url, false);
      ajax.send(formData);
    };

    ajax();
    return val;
  };
  /*
  httpRequests.js
  
  This file contains code for 2 HTTP request convenience functions, 1 synchronous,
  and the other asynchronous.
  
  Author: Eric James Foster
  License: ISC
  */
  //TODO:30 reWrite 'await' version of xhr().


  var ajax = function ajax(url, fd, callback, method) {
    //TEST:60 Test this function.
    var formData;

    if (fd) {
      if (Object.getOwnPropertyNames(fd).length === 0) {
        formData = fd; //log(Object.getOwnPropertyNames(fd).length);
      } else {
        formData = new FormData();

        for (var key in fd) {
          formData.append(key, fd[key]);
        }
      }
    } else {
      formData = null;
    } //log('fd'); log(formData);


    var m = method || 'get';

    if (formData !== null) {
      m = 'post';
    } // var data = fd;


    var val;
    var req = new XMLHttpRequest();

    req.onloadend = function () {
      if (req.status === 200) {
        var response = this.response;
        callback(response);
      }
    };

    req.open(m, url);
    req.send(formData);
  };

  module.exports = {
    ajax: ajax,
    xhr: xhr
  };
  /***/
},
/* 32 */

/***/
function (module, __webpack_exports__, __webpack_require__) {
  ;

  __webpack_require__.r(__webpack_exports__);
  /* harmony export (binding) */


  __webpack_require__.d(__webpack_exports__, "default", function () {
    return queryDOM;
  });
  /*
  ** el.js
  **
  ** This function combines querySelector and querySelectorAll, and becomes a
  ** noop if 'el' is a letiable. There is an optional 2nd argument 'mod', that
  ** is a boolean. By default, 'mod' is false. If true is passed as the 2nd argument,
  ** the function will use querySelectorAll() instead of querySelector(), meaning an
  ** array will be returned if possible.
  **
  ** Eric James Foster, Fostware LLC, MIT License.
  ***/

  /*This function combines querySelector and querySelectorAll, and becomes a noop if 'el' is a variable. There is an optional 2nd argument 'mod', that
  accepts the string 'all' to modify behaviour of the function. By default, 'mod' is null. If the string 'all' is passed as the 2nd argument, the function
  will use querySelectorAll() instead of querySelector(), meaning an array will be returned if possible. */


  function queryDOM(el) {
    var all = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false; //

    var lm,
        lms = [];

    if (typeof el === 'string') {
      if (el.charAt(0) === '.') {
        el = el.substring(1, el.length);
        lm = document.getElementsByClassName(el);

        if (lm.length !== 0) {
          if (lm.length === 1) {
            lms = lm[0];
          } else {
            for (var i = 0; i < lm.length; i++) {
              lms.push(lm[i]);
            }
          }
        } else {
          return null;
        }
      } else if (el.charAt(0) !== '#' && el.indexOf('[') === -1 && el.indexOf(':') === -1 && el.indexOf(' ') === -1) {
        lm = document.getElementsByTagName(el);

        if (lm.length !== 0) {
          if (lm.length === 1) {
            lms = lm[0];
          } else {
            for (var j = 0; j < lm.length; j++) {
              lms.push(lm.item(j));
            }
          }
        } else {
          return null;
        }
      } else {
        lm = document.querySelectorAll(el);

        if (lm.length <= 1) {
          lm = undefined;
          lm = document.querySelector(el);
          return lm;
        } else {
          return lm;
        }
      }

      return lms;
    } else {
      return el;
    }
  }
  /***/

},
/* 33 */

/***/
function (module, __webpack_exports__, __webpack_require__) {
  ;

  __webpack_require__.r(__webpack_exports__);
  /* harmony export (binding) */


  __webpack_require__.d(__webpack_exports__, "_log", function () {
    return _log;
  });
  /* harmony export (binding) */


  __webpack_require__.d(__webpack_exports__, "info", function () {
    return info;
  });
  /* harmony export (binding) */


  __webpack_require__.d(__webpack_exports__, "warn", function () {
    return warn;
  });
  /* harmony export (binding) */


  __webpack_require__.d(__webpack_exports__, "error", function () {
    return error;
  });
  /* harmony export (binding) */


  __webpack_require__.d(__webpack_exports__, "err", function () {
    return err;
  });
  /* harmony export (binding) */


  __webpack_require__.d(__webpack_exports__, "_dir", function () {
    return _dir;
  });
  /* harmony import */


  var clivi__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(27);
  /* harmony import */


  var clivi__WEBPACK_IMPORTED_MODULE_0___default =
  /*#__PURE__*/
  __webpack_require__.n(clivi__WEBPACK_IMPORTED_MODULE_0__);
  /*
  Logger.js
  
  This file contains the code for the various logging functions
  of the library.
  
  Author: Eric James Foster
  License: ISC
  */
  //Console.log alias function.


  var _log = function _log(text, style, tyme) {
    var colr = Array.isArray(style) ? style[0] : style,
        styl = Array.isArray(style) ? style[1] : null,
        tym = tyme || false;
    var time = new Date(),
        hours = time.getHours(),
        mins = time.getMinutes(),
        secs = time.getSeconds();

    if (secs <= 9) {
      secs = '0' + String(secs);
    }

    if (mins <= 9) {
      mins = '0' + String(mins);
    }

    var abbr = hours >= 12 ? 'pm' : 'am';
    var stan = hours >= 13 ? hours - 12 : hours;

    if (stan === 0) {
      hours = stan + 12;
    } else {
      hours = stan;
    }

    time = hours + ':' + mins + ':' + secs + abbr;
    var t = tym ? time : '';

    if (typeof document === 'undefined') {
      return console.log(clivi__WEBPACK_IMPORTED_MODULE_0___default()(text, {
        fg: colr,
        style: styl
      }) + '   '.repeat(10) + t);
    } else {
      var color = colr,
          bgColor = styl,
          css = 'background: ' + bgColor + '; color: ' + color;
      return console.log('%c' + text + '%s', css, '   '.repeat(10) + t);
    }
  }; //Console.error alias function.


  var err = function err(text, tyme) {
    var colr = 'red',
        styl = 'bold',
        tym = tyme || false;
    var time = new Date(),
        hours = time.getHours(),
        mins = time.getMinutes(),
        secs = time.getSeconds();

    if (secs <= 9) {
      secs = '0' + String(secs);
    }

    if (mins <= 9) {
      mins = '0' + String(mins);
    }

    var abbr = hours >= 12 ? 'pm' : 'am';
    var stan = hours >= 13 ? hours - 12 : hours;

    if (stan === 0) {
      hours = stan + 12;
    } else {
      hours = stan;
    }

    time = hours + ':' + mins + ':' + secs + abbr;
    var t = tym ? time : '';

    if (typeof document === 'undefined') {
      return console.log(clivi__WEBPACK_IMPORTED_MODULE_0___default()(text, {
        fg: colr,
        style: styl
      }) + '   '.repeat(10) + t);
    } else {
      var color = colr,
          bgColor = '',
          css = 'background: ' + bgColor + '; color: ' + color;
      return console.error('%c' + text + '%s', css, '   '.repeat(10) + t);
    }
  }; //Console.error alias function.


  var error = function error(text) {
    return console.error(text);
  }; //Console.info alias function.


  var info = function info(text, tyme) {
    var colr = '#008cff',
        styl = 'bold',
        tym = tyme || false;
    var time = new Date(),
        hours = time.getHours(),
        mins = time.getMinutes(),
        secs = time.getSeconds();

    if (secs <= 9) {
      secs = '0' + String(secs);
    }

    if (mins <= 9) {
      mins = '0' + String(mins);
    }

    var abbr = hours >= 12 ? 'pm' : 'am';
    var stan = hours >= 13 ? hours - 12 : hours;

    if (stan === 0) {
      hours = stan + 12;
    } else {
      hours = stan;
    }

    time = hours + ':' + mins + ':' + secs + abbr;
    var t = tym ? time : '';

    if (typeof document === 'undefined') {
      colr = 'blueBright';
      return console.log(clivi__WEBPACK_IMPORTED_MODULE_0___default()(text, {
        fg: colr,
        style: styl
      }) + '   '.repeat(10) + t);
    } else {
      var color = colr,
          bgColor = '',
          css = 'background: ' + bgColor + '; color: ' + color;
      return console.info('%c' + text + '%s', css, '   '.repeat(10) + t);
    }
  }; //Console.warn alias function.


  var warn = function warn(text, tyme) {
    var colr = 'orange',
        styl = 'bold',
        tym = tyme || false;
    var time = new Date(),
        hours = time.getHours(),
        mins = time.getMinutes(),
        secs = time.getSeconds();

    if (secs <= 9) {
      secs = '0' + String(secs);
    }

    if (mins <= 9) {
      mins = '0' + String(mins);
    }

    var abbr = hours >= 12 ? 'pm' : 'am';
    var stan = hours >= 13 ? hours - 12 : hours;

    if (stan === 0) {
      hours = stan + 12;
    } else {
      hours = stan;
    }

    time = hours + ':' + mins + ':' + secs + abbr;
    var t = tym ? time : '';

    if (typeof document === 'undefined') {
      colr = 'yellow';
      colr = 'blueBright';
      return console.log(clivi__WEBPACK_IMPORTED_MODULE_0___default()(text, {
        fg: colr,
        style: styl
      }) + '   '.repeat(10) + t);
    } else {
      var color = colr,
          bgColor = '',
          css = 'background: ' + bgColor + '; color: ' + color;
      return console.warn('%c' + text + '%s', css, '   '.repeat(10) + t);
    }
  };

  var _dir = function _dir(obj) {
    return console.dir(obj);
  };
  /***/

},
/* 34 */

/***/
function (module, __webpack_exports__, __webpack_require__) {
  ;

  __webpack_require__.r(__webpack_exports__);
  /* harmony export (binding) */


  __webpack_require__.d(__webpack_exports__, "Form", function () {
    return Form;
  });
  /* harmony import */


  var _Utilities_helpers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(4);
  /* harmony import */


  var _Utilities_Is__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(6);
  /* harmony import */


  var _Node__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(35);
  /* harmony import */


  var _Props_Props__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(38);
  /* harmony import */


  var _Events__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(37);
  /* harmony import */


  var _Flare_Flare__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(167);

  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  function _defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    return Constructor;
  }

  function _defineProperty(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }

    return obj;
  }
  /*
  Form.js
  
  Form is the virtual dom layer of a Valence app that interfaces
  with the actual DOM via the DOM API, making adjustments
  to the UI in an inexpensive and effecient manner...
  
  Eric James Foster, MIT License.
  */
  // Pull in utilities...
  // Get type validation...
  // Grab Node...
  // Get Props class...
  // Get Events...
  // Get Flare...
  // Globalize common utilities...
  // const log     = _.log
  // const dom     = _.dom


  var dir = console.dir; // Form Virtual DOM...

  var Form =
  /*#__PURE__*/
  function () {
    function Form(node, root) {
      _classCallCheck(this, Form); // The old DOM for diffing purposes...


      this.DOM = node;
      this.DOMString = String(this.DOM);
      this.propString = String(this.DOM.props); // The new DOM for diffing...

      this.newDOM = null; // If newDOM is set, set the following...

      if (this.newDOM) {
        this.newDOMString = String(this.newDOM);
        this.newPropString = String(this.newDOM.props);
      } // Get a reference to Valence's mount node...


      this.rootNode = root;
    } // Variable holds an array of flareComponent names..


    _createClass(Form, [{
      key: "_isStatefulComponent",
      // Computed property that resolves whether or not the given node is a component or not...
      value: function _isStatefulComponent(node) {
        return node.props.isStatefulComponent ? true : false;
      } // Method for updating an element and all of it's children recursively...

    }, {
      key: "updateDOM",
      value: function updateDOM(parent, newNode) {
        var oldNode = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
        var index = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0; // Get a reference to the current node and incoming props...

        var thisNode = parent.childNodes[index];
        var nextProps = newNode.props; // If this node is a component, check it's `shouldComponentUpdate` method to
        // confirm whether or not an update is necessary...

        if (this._isStatefulComponent(thisNode)) {
          if (!thisNode.type.shouldComponentUpdate(thisNode.props
          /*, this.state?*/
          )) {
            return;
          }
        } // Set newDOM...


        if (this.newDOM = null) {
          this.newDOM = newNode;
        } // If first pass, oldNode will need to be set...


        if (oldNode === null) {
          oldNode = this.DOM;
        } // Get diff length...


        var diff = function diff() {
          return Math.abs(newNode.children.length - oldNode.children.length);
        }; // newNode exist where there is no oldNode...


        if (!oldNode) {
          // Create a new node and append it to DOM...
          parent.appendChild(_Node__WEBPACK_IMPORTED_MODULE_2__["Node"].createNode(newNode)); // OldNode exists where there is no newNode...
        } else if (!newNode) {
          // If current node is a component, fire willUnmount event...
          if (this._isStatefulComponent(thisNode)) {
            _Events__WEBPACK_IMPORTED_MODULE_4__["Events"].fire('componentWillUnmount', thisNode, thisNode.props);
          } // Then remove the node...


          parent.removeChild(thisNode); // The node has changed, 'tag' or 'props', for example...
        } else if (this._changed) {
          parent.replaceChild(_Node__WEBPACK_IMPORTED_MODULE_2__["Node"].createNode(newNode), thisNode); // None of the above apply, and the node is not a textNode...
        } else if (!Object(_Utilities_Is__WEBPACK_IMPORTED_MODULE_1__["isString"])(newNode)) {
          // If newNode is  component, fire componentWillReceiveProps event with new props,
          // then update props...
          if (this._isStatefulComponent(thisNode)) {
            _Events__WEBPACK_IMPORTED_MODULE_4__["Events"].fire('componentWillReceiveProps', thisNode, thisNode.props);
          }

          _Props_Props__WEBPACK_IMPORTED_MODULE_3__["Props"].update(thisNode, newNode.props, oldNode.props); // Then children and their props...


          for (var i = 0; i < diff(); i++) {
            updateElement(thisNode, newNode.children[i], oldNode.children[i], i);
          }
        }

        this.DOM = newNode;
      } // A helper method representing the API of the virtual DOM...

    }, {
      key: "draw",
      // Method for rendering the virtual dom to real dom...
      value: function draw() {
        return _Node__WEBPACK_IMPORTED_MODULE_2__["Node"].createNode(this.DOM);
      }
    }, {
      key: "_changed",
      // Computed property that determines whether or not 2 nodes
      // have changed...
      get: function get() {
        // Compare DOMStrings...
        return this.newDOMString !== this.DOMString || this.newDOM.props.forceUpdate;
      }
    }, {
      key: "_propsChanged",
      get: function get() {
        // Compare PropStrings...
        return this.newPropString !== this.propString;
      }
    }], [{
      key: "x",
      value: function x(type, props) {
        for (var _len = arguments.length, children = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
          children[_key - 2] = arguments[_key];
        } // Return a new Node...


        return new _Node__WEBPACK_IMPORTED_MODULE_2__["Node"]({
          type: type,
          props: props,
          children: children
        });
      }
    }]);

    return Form;
  }();

  _defineProperty(Form, "_flareComponentNames", []);
  /***/

},
/* 35 */

/***/
function (module, __webpack_exports__, __webpack_require__) {
  ;

  __webpack_require__.r(__webpack_exports__);
  /* harmony export (binding) */


  __webpack_require__.d(__webpack_exports__, "Node", function () {
    return Node;
  });
  /* harmony import */


  var _Utilities_helpers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(4);
  /* harmony import */


  var _Utilities_Is__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(6);
  /* harmony import */


  var _Utilities_Loggers__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(33);
  /* harmony import */


  var _Element__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(36);
  /* harmony import */


  var _Component__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(40);
  /* harmony import */


  var _Props_Props__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(38);
  /* harmony import */


  var _Props_PropTypes__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(39);
  /* harmony import */


  var _Events__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(37);
  /* harmony import */


  var _Flare_Flare__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(167);

  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  function _defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    return Constructor;
  }

  function _defineProperty(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }

    return obj;
  }
  /*
  Node.js
  
  Form is the virtual dom layer of a Valence app that interfaces
  with the actual DOM via the DOM API, making adjustments
  to the UI in an inexpensive and effecient manner. This file houses
  the Node Class which is a basic virtual dom node
  
  Eric James Foster, MIT License.
  */
  // Get utilities...
  // Get needed validation functions...
  // Get logger...
  // Get Element class for createElement function...
  // Get Component class for createComponent function...
  // Get Props...
  // Get PropTypes...
  // Get Events...
  // Bring in Flare...
  // Globalize common utilities...


  var dir = _Utilities_Loggers__WEBPACK_IMPORTED_MODULE_2__["_dir"]; // Form Virtual DOM Node...

  var Node =
  /*#__PURE__*/
  function () {
    // Node type instance constructor...
    function Node(_ref) {
      var type = _ref.type,
          props = _ref.props,
          children = _ref.children;

      _classCallCheck(this, Node);

      this.type = type; // If no props, make sure an empty object is created...

      var _props = props || {};

      this.props = new _Props_Props__WEBPACK_IMPORTED_MODULE_5__["Props"](_props);
      this.children = children;
    } // Config options...


    _createClass(Node, null, [{
      key: "assume",
      value: function assume(userAssumptions) {
        this._assumptions = Object(_Utilities_helpers__WEBPACK_IMPORTED_MODULE_0__["combineObjects"])(this._assumptions, userAssumptions);
        return this._assumptions;
      } // An internal class method for processing component props...

    }, {
      key: "processNodeProps",
      value: function processNodeProps(props, ctor) {
        var type = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {}; // Get customPropNames for custom prop registration, and propNames for validation...

        var customPropNames = Object(_Utilities_helpers__WEBPACK_IMPORTED_MODULE_0__["extractCustomPropNames"])(Object(_Utilities_helpers__WEBPACK_IMPORTED_MODULE_0__["propNames"])(props)); // If user registered proptypes on the component, proceed with prop validation...

        if (type.propTypes) {
          var _propNames = _propNames(type.propTypes); // Validate that all supplied prop value types match that of registered propTypes...


          props = _Props_Props__WEBPACK_IMPORTED_MODULE_5__["Props"].validate(props, _propNames, type);
        } // Register custom element attributes...


        _Props_Props__WEBPACK_IMPORTED_MODULE_5__["Props"].registerCustom(ctor, customPropNames); // Register all element attributes as observedAttributes...


        _Props_Props__WEBPACK_IMPORTED_MODULE_5__["Props"].registerObserved(ctor, props); // Need to return both props and the constructor to the Caller's context


        return {
          props: props,
          ctor: ctor
        };
      } // Either create the given element, or if it's a component, define the element then
      // create it...

    }, {
      key: "createNode",
      value: function createNode(node) {
        //
        if (Object(_Utilities_Is__WEBPACK_IMPORTED_MODULE_1__["isString"])(node)) {
          // Create and return the given text node...
          return document.createTextNode(node);
        } else {
          // Declare tag var..
          var tagName, shadow, flareComponent, elementConstructor, props; // Determine if elem is an element or a Component...
          // If it's a function....

          if (Object(_Utilities_Is__WEBPACK_IMPORTED_MODULE_1__["isFunction"])(node.type)) {
            props = node.props, elementConstructor = node.type; // Convert the given function name to it's corresponding component tagname...

            tagName = Object(_Utilities_helpers__WEBPACK_IMPORTED_MODULE_0__["convertFuncNameToTagName"])(node.type.name, props.kebabCase !== undefined || props.kebab !== undefined ? props.kebabCase : this._assumptions.kebabCase); // Determine if it's a class...

            if (!Object(_Utilities_Is__WEBPACK_IMPORTED_MODULE_1__["isClass"])(node.type)) {
              // Add `isStatelessComponent` property so that the shim flags can be
              // reset after element creation...
              node.props.isStatelessComponent = true;

              if (Object(_Utilities_Is__WEBPACK_IMPORTED_MODULE_1__["isFlare"])(node)) {
                // Unpack flare component props... combine props...
                // Unpack component....
                flareComponent = node.type(props); // Set type to tag...

                node.type = tagName; // Push to global collection...

                valenceGlobals.flareComponents[node.type] = props; /// Combine the two props objects, merging them into one......

                props = Object(_Utilities_helpers__WEBPACK_IMPORTED_MODULE_0__["combineObjects"])(props, flareComponent.props); // Use the above to define Flare Component.. and also 'type' for the node...

                _Flare_Flare__WEBPACK_IMPORTED_MODULE_8__["Flare"].createComponent(tagName, flareComponent.el, flareComponent.taggedTempLit, props);

                node.props.isStatelessComponent = true;
              } else {
                /// Set up component creation, first arg..
                var component = [tagName, node.type]; // Extract shadow setting from Props if available...

                if (node.props.shadow) {
                  shadow = node.props.shadow;
                } // Return completed component...


                elementConstructor = _Component__WEBPACK_IMPORTED_MODULE_4__["default"].createComponent(component, node.props, node.children, shadow);
              }
            } else {
              // Add `isStatefulComponent` privateProp for update purposes...
              node.props.isStatefulComponent = true;
            } // Non-Flare component custom element definition....


            if (!Object(_Utilities_Is__WEBPACK_IMPORTED_MODULE_1__["isFlare"])(flareComponent)) {
              /* If we're dealing with a class, we need to be sure we're not using the shim when
              defining the component...*/
              if (Object(_Utilities_Is__WEBPACK_IMPORTED_MODULE_1__["isClass"])(node.type)) {
                window.useNativeShim = false;
                window.HTMLElement = window._HTMLElement;
              } // Process props......


              var processed = Node.processNodeProps(node.props, elementConstructor, node.type); // Using a try-catch here to be sure we are not trying to define WebComponents twice...

              try {
                // Use Custom elements API to define a custom tag/component...
                window.customElements.define(tagName, // Doing double duty here.. The ctor must be returned from this function anyhow,
                // so I'm dropping it in here to avoid redundancy...
                processed.ctor);
              } catch (e) {
                Object(_Utilities_Loggers__WEBPACK_IMPORTED_MODULE_2__["_log"])("Component ".concat(tagName, " already defined"), ['blue', 'white']);
              } // If the component is a class, we need to reset the shim flags.....


              if (Object(_Utilities_Is__WEBPACK_IMPORTED_MODULE_1__["isClass"])(node.type)) {
                window.useNativeShim = true;
                window.HTMLElement = window.HTMLElement_;
              } //FIXME: May not be using this at all....


              if (processed.props.rootNode) {
                // Create and dispatch event confirming definition of the root node.
                _Events__WEBPACK_IMPORTED_MODULE_7__["Events"].emit('rootNodeDefined'); // Set root node definition flag...


                window.rootNodeDefined = true;
              } // Set node.type to tagName of the component, and props to the amended props
              // object...


              node.props = processed.props;
              node.type = tagName;
            }
          } // Use DOM API (via Valence Element class) to create element and return it...


          return _Element__WEBPACK_IMPORTED_MODULE_3__["Element"].createElement(node);
        }
      }
    }]);

    return Node;
  }();

  _defineProperty(Node, "_assumptions", {
    kebabCase: true // An internal method that returns the combination of the CSS class's assumptions
    // this class's assumptions... It's ultimately the end of a line of merged config objects...

  });
  /***/

},
/* 36 */

/***/
function (module, __webpack_exports__, __webpack_require__) {
  ;

  __webpack_require__.r(__webpack_exports__);
  /* harmony export (binding) */


  __webpack_require__.d(__webpack_exports__, "Element", function () {
    return Element;
  });
  /* harmony import */


  var _Utilities_data__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(5);
  /* harmony import */


  var _Utilities_helpers__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(4);
  /* harmony import */


  var _Utilities_Is__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(6);
  /* harmony import */


  var _Events__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(37);
  /* harmony import */


  var _Props_Props__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(38);
  /* harmony import */


  var _Form_Node__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(35);

  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  function _defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    return Constructor;
  }
  /*
  Element.js
  
  Valence.js, a JavaScript library for building UI's, with an API
  resembling that of React, but uses Vanilla JS Web components
  under the hood...This file handles the framework's element
  creation and configuration...
  
  Eric James Foster, MIT License.
  */
  // Get data...
  // Get utilities...
  // Grab events...
  // Get Props class...
  // Get Node Class...
  // Globalize common _...


  var dir = console.dir;
  var log = _Utilities_helpers__WEBPACK_IMPORTED_MODULE_1__["log"];

  var Element =
  /*#__PURE__*/
  function () {
    function Element() {
      _classCallCheck(this, Element);
    }

    _createClass(Element, null, [{
      key: "createElement",
      // Create a Valence element...
      value: function createElement(_ref) {
        var type = _ref.type,
            _ref$props = _ref.props,
            props = _ref$props === void 0 ? {} : _ref$props,
            children = _ref.children; // Pre-declare inner functions...

        var makeDOMElement, setProps, addEventListeners, appendChildren, elem; // Create a new DOM element...

        makeDOMElement = function makeDOMElement(tagName) {
          if (Reflect.has(valenceGlobals.flareComponents, tagName)) {
            // Flip the required switches...
            window.useNativeShim = false;
            window.HTMLElement = window._HTMLElement;
          } // Create a new element given the tag name, and
          // store for sending through the pipe......


          elem = document.createElement(tagName); // If we just created a Flare Component element...

          if (Reflect.has(valenceGlobals.flareComponents, tagName)) {
            // Emit an event that cues Flare to set props on the newly created element...
            _Events__WEBPACK_IMPORTED_MODULE_3__["Events"].emit(tagName, {
              element: elem
            });
          } //log('new Element', ['orange', 'bold']);log(tagName)

          /* If `Reflect` programmatic library constructed component, reset native-shim flag,
          and also reset window.HTMLElement to the nativeShim.js patched version...
          */


          if (props.isStatelessComponent) {
            window.useNativeShim = true;
            window.HTMLElement = window.HTMLElement_; // Push tagname to global collection..

            window.valenceGlobals.statelessComponents.push(tagName);
          } // Send the created element through the pipe...


          return elem;
        }; // Set given attributes on the created element....


        setProps = function setProps(elem) {
          if (props) {
            /* If setting props on user defined (stateful) component, fire willRecieveProps
            event..*/
            if (props.isStatefulComponent) {
              _Events__WEBPACK_IMPORTED_MODULE_3__["Events"].fire('componentWillReceiveProps', elem, props);
            }
            /* The ref function is defined in jsx markup as a prop in curlies, and When
             * we get to this point in the definition of the ref'd element, we access the
             * function via props and execute it, injecting the brand new element instance
             * that we just created in the function above. This will complete the purpose
             * of the ref function, which is to pass the reference into a variable, but in
             * the context in which it was defined, the component definition...
             */


            if (props.ref) {
              props.ref(elem);
            } // Set props and return the element to the pipe...


            return _Props_Props__WEBPACK_IMPORTED_MODULE_4__["Props"].set(elem, props);
          }
        }; // Add event listener(s) to element...


        addEventListeners = function addEventListeners(elem) {
          _Utilities_helpers__WEBPACK_IMPORTED_MODULE_1__["propNames"](props).forEach(function (name) {
            if (_Utilities_Is__WEBPACK_IMPORTED_MODULE_2__["Is"].eventListener(name)) {
              elem.addEventListener(_Utilities_helpers__WEBPACK_IMPORTED_MODULE_1__["sansON"](name), props[name]);
            }
          }, elem);

          return elem;
        }; // Add elements children to the DOM.....


        appendChildren = function appendChildren(elem) {
          // Determine if elem is a string or a Component...
          if (children) {
            // Append children...
            children.map(_Form_Node__WEBPACK_IMPORTED_MODULE_5__["Node"].createNode, _Form_Node__WEBPACK_IMPORTED_MODULE_5__["Node"]).forEach(elem.appendChild, elem);
          } // Return the element...


          dir(elem);
          return elem;
        }; // Connected to each other with the higher-order function piper, the following will
        // return the requested element...


        return _Utilities_helpers__WEBPACK_IMPORTED_MODULE_1__["piper"](makeDOMElement, setProps, addEventListeners, appendChildren)(type);
      }
    }]);

    return Element;
  }();
  /***/

},
/* 37 */

/***/
function (module, __webpack_exports__, __webpack_require__) {
  ;

  __webpack_require__.r(__webpack_exports__);
  /* harmony export (binding) */


  __webpack_require__.d(__webpack_exports__, "Events", function () {
    return Events;
  });
  /* harmony import */


  var _Utilities_helpers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(4);

  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  function _defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    return Constructor;
  }
  /*
  Dispatch.js
  
  Dispatch is the custom event creation and dispatch class behind
  the Valence component lifecycle methods...
  
  Eric James Foster, MIT License.
  */
  // Globalize log function...


  var log = _Utilities_helpers__WEBPACK_IMPORTED_MODULE_0__["log"];

  var Events =
  /*#__PURE__*/
  function () {
    function Events() {
      _classCallCheck(this, Events);
    }

    _createClass(Events, null, [{
      key: "fire",
      // Using emerging js reflection to create a single method for dispatching
      // lifecycle event callbacks...
      value: function fire(event, target) {
        var detail = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
        var lifecycleEvent = Reflect.construct(CustomEvent, [event, {
          'detail': detail
        }]);
        return target.dispatchEvent(lifecycleEvent);
      } // Creating a second Event dispatching method for dispatching non-lifecycle events, and
      // custom events with dynamic event strings...

    }, {
      key: "emit",
      value: function emit(eventOrTag) {
        var detail = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {}; // Determine whether first arg is an event string or a tagname...

        if (_Utilities_helpers__WEBPACK_IMPORTED_MODULE_0__["included"]('-', eventOrTag)) {
          // If tagname, create a listener for a custom flare event.
          var customEventString = _Utilities_helpers__WEBPACK_IMPORTED_MODULE_0__["uniqueCustomEventString"](eventOrTag); // Instantiate custom event...


          var ev = new CustomEvent(customEventString, {
            'detail': detail
          }); // Dispatch the event...

          document.dispatchEvent(ev);
        } else {
          // Instantiate custom event...
          var _ev = new CustomEvent(eventOrTag, {
            'detail': detail
          }); // Dispatch the event...


          document.dispatchEvent(_ev);
        }
      } // A static helper method for developing event listener functions...

    }, {
      key: "listen",
      value: function listen(eventOrTag, cb) {
        // Determine whether first arg is an event string or a tagname...
        if (_Utilities_helpers__WEBPACK_IMPORTED_MODULE_0__["included"]('-', eventOrTag)) {
          // If tagname, create a listener for a custom flare event.
          var customEventString = _Utilities_helpers__WEBPACK_IMPORTED_MODULE_0__["uniqueCustomEventString"](eventOrTag); // Add listener...


          document.addEventListener(customEventString, function (e) {
            cb(e);
          });
        } else {
          // Add listener with given event string...
          document.addEventListener(eventOrTag, function (e) {
            cb(e);
          });
        }
      } // Static class method for registering event listener callback methods on
      // a given HTMLElement...

    }, {
      key: "registerCallbacks",
      value: function registerCallbacks(ctor, eListeners) {
        if (eListeners.length < 1) {
          return;
        } else {
          eListeners.forEach(function (eListener) {
            ctor.prototype[eListener[1]] = eListener[2];
          }, ctor);
        }

        return ctor;
      }
    }]);

    return Events;
  }();
  /***/

},
/* 38 */

/***/
function (module, __webpack_exports__, __webpack_require__) {
  ;

  __webpack_require__.r(__webpack_exports__);
  /* harmony export (binding) */


  __webpack_require__.d(__webpack_exports__, "Props", function () {
    return Props;
  });
  /* harmony import */


  var _Utilities_helpers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(4);
  /* harmony import */


  var _Utilities_Is__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(6);
  /* harmony import */


  var _PropTypes__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(39);

  function _objectSpread(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i] != null ? arguments[i] : {};
      var ownKeys = Object.keys(source);

      if (typeof Object.getOwnPropertySymbols === 'function') {
        ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) {
          return Object.getOwnPropertyDescriptor(source, sym).enumerable;
        }));
      }

      ownKeys.forEach(function (key) {
        _defineProperty(target, key, source[key]);
      });
    }

    return target;
  }

  function _defineProperty(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }

    return obj;
  }

  function _typeof(obj) {
    if (typeof Symbol === "function" && _typeof2(Symbol.iterator) === "symbol") {
      _typeof = function _typeof(obj) {
        return _typeof2(obj);
      };
    } else {
      _typeof = function _typeof(obj) {
        return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : _typeof2(obj);
      };
    }

    return _typeof(obj);
  }

  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  function _defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    return Constructor;
  }
  /*
  Props.js
  
  Valence, a JavaScript library for building UI's, with an API
  resembling that of React, but uses Vanilla JS Web components
  under the hood...This file handles  element
  property (props) creation, assignment etc...
  
  Eric James Foster, MIT License.
  */
  // Get utilities...
  //Get PropTypes...


  var dir = console.dir;
  var log = _Utilities_helpers__WEBPACK_IMPORTED_MODULE_0__["log"];

  var Props =
  /*#__PURE__*/
  function () {
    function Props(props) {
      _classCallCheck(this, Props);

      var propPairs = Object.entries(props);
      var ppLength = propPairs.length;
      var i = 0;

      while (ppLength > 0) {
        this[propPairs[i][0]] = propPairs[i][1];
        ppLength--;
        i++;
      }
    } // An internal method for applying the default props when none are supplied...


    _createClass(Props, null, [{
      key: "_applyDefault",
      value: function _applyDefault(defaultProps, propName) {
        return defaultProps[propName];
      } // An object to hold prop types for type checking purposes...

    }, {
      key: "validate",
      value: function validate(props, propNames, component) {
        var _this = this; // Cycle through props, comparing it's value type with it's expected propType...


        var validatedProps = propNames.reduce(function (propsObj, propName) {
          // Store types, default props, prop value and value type...
          var types = null,
              defProps = null,
              propValue = props[propName],
              valueType = _typeof(propValue); // Don't want to attempt to access propTypes or defaultProps if they don't exist.
          // but if they do, store them...


          if (component.propTypes[propName]) {
            types = component.propTypes[propName].types;
          }

          if (component.defaultProps) {
            defProps = component.defaultProps;
          } // If prop is undefined...


          if (propValue === undefined) {
            // but propType specifies `required`...
            if (_Utilities_Is__WEBPACK_IMPORTED_MODULE_1__["Is"].requiredProp(types)) {
              // If we have defaultProp...
              if (defProps) {
                // Apply it to props object...
                propValue = _this._applyDefault(defProps, propName);
                return _objectSpread({}, propsObj, _defineProperty({}, propName, propValue)); // Else, output warning to the console, and pass undefined prop to props object...
              } else {
                console.warn("Warning: Failed PropType: Required prop `".concat(propName, "` is undefined."));
                return _objectSpread({}, propsObj, _defineProperty({}, propName, propValue));
              }
            }
            /*else (who cares) {}*/
            // Or, if value type is not among propTypes' specified types...

          } else if (types.indexOf(valueType) === -1) {
            // output warning to console, and add our value to the props object....
            console.warn("Warning: Failed PropType: Prop `".concat(propName, "` was given a value of type `").concat(valueType, "`, expected `").concat(types[0], "`."));
            return _objectSpread({}, propsObj, _defineProperty({}, propName, propValue)); // Else, everything is just as it should be. Add value to props object...
          } else {
            return _objectSpread({}, propsObj, _defineProperty({}, propName, propValue));
          }
        }, {}); // Return the props object...

        return _objectSpread({}, props, validatedProps);
      } // A simple boolean for determining if prop is custom or not...

    }, {
      key: "_isPrivateProp",
      value: function _isPrivateProp(name) {
        return _Utilities_Is__WEBPACK_IMPORTED_MODULE_1__["Is"].eventListener(name) || name === 'forceUpdate' || name === 'isStatefulComponent' || name === 'isStatelessComponent' || name === 'ref' || name === 'noChild' || name === 'rootNode' || name === 'Flare' || name === 'flare' || name === 'label' || name === 'content' || name === 'cleanHTML' || name === 'kebabCase';
      } // Method for updating props...

    }, {
      key: "update",
      value: function update(elem, newProps) {
        var _this2 = this;

        var oldProps = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
        var updateProp; // Check if the given prop on the given element needs updated or not,
        // and update, add or remove it...

        updateProp = function updateProp(elem, name, newVal, oldVal) {
          if (!newVal) {
            _this2.remove(elem, name, oldVal);
          } else if (!oldVal || newVal !== oldVal) {
            _this2.set(elem, name, newVal);
          }
        }; // Combine old and new props into 1 new object...


        var props = _Utilities_helpers__WEBPACK_IMPORTED_MODULE_0__["combineObjects"](newProps, oldProps); // Get an array of unique props keys and use it to iterate through
        // both objects comparing for differences and update requirements...


        Object.keys(props).forEach(function (name) {
          updateProp(elem, name, newProps[name], oldProps[name]);
        });
      } // Set given attributes on the created element....

    }, {
      key: "set",
      value: function set(elem, props) {
        var _this3 = this;

        var setProp, setBooleanProp; // A function for setting boolean properties on elements...

        setBooleanProp = function setBooleanProp(elem, name, value) {
          if (value) {
            elem.setAttribute(name, value);
            elem[name] = true;
          } else {
            elem[name] = false;
          }
        }; // A function for setting props...


        setProp = function setProp(elem, name, value) {
          if (_this3._isPrivateProp(name)) {
            return;
          } else if (name === 'className') {
            elem.setAttribute('class', value);
          } else if (_Utilities_Is__WEBPACK_IMPORTED_MODULE_1__["Is"]["boolean"](value)) {
            setBooleanProp(elem, name, value);
          } else {
            elem.setAttribute(name, value);
          }
        }; // Remove event listeners from attributes...


        var propsArray = _Utilities_helpers__WEBPACK_IMPORTED_MODULE_0__["propsArray"](props); // Determine if elem is a string or a Component...


        if (propsArray.length > 0) {
          // dir(filteredProps)
          // Add attributes to element...
          var _iteratorNormalCompletion = true;
          var _didIteratorError = false;
          var _iteratorError = undefined;

          try {
            for (var _iterator = propsArray[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
              var prop = _step.value;
              setProp(elem, prop[0], prop[1]);
            }
          } catch (err) {
            _didIteratorError = true;
            _iteratorError = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion && _iterator["return"] != null) {
                _iterator["return"]();
              }
            } finally {
              if (_didIteratorError) {
                throw _iteratorError;
              }
            }
          }
        } // Return element...


        return elem;
      } // Method for setting up a list of observed attributes. These attributes
      // will trigger the attributesChangedCallback method on the custom
      // element when changed in any way...

    }, {
      key: "registerObserved",
      value: function registerObserved(ctor, propNames) {
        Object.defineProperties(ctor.prototype, {
          observedAttributes: {
            get: function get() {
              return propNames;
            },
            enumerable: true,
            configurable: true
          }
        });
      } // Method for setting custom attributes of custom elements...

    }, {
      key: "registerCustom",
      value: function registerCustom(ctor, propNames) {
        propNames.forEach(function (prop) {
          if (!Boolean(ctor.prototype.observedAttributes) || !prop in ctor.prototype.observedAttributes) {
            Object.defineProperties(ctor.prototype, _defineProperty({}, prop, {
              get: function get() {
                return this.getAttribute(prop);
              },
              set: function set(val) {
                if (val) {
                  this.setAttribute(prop, val);
                } else {
                  this.removeAttribute(prop);
                }
              },
              enumerable: true,
              configurable: true
            }));
          }
        }, ctor);
        return ctor;
      } // A method for removing Properties...

    }, {
      key: "remove",
      value: function remove(elem, name, value) {
        // A function for removing boolean properties...
        var removeBooleanProp = function removeBooleanProp(elem, name) {
          elem.removeAttribute(name);
          elem[name] = false;
        }; // Remove Properties...


        if (this._isPrivateProp(name)) {
          return;
        } else if (name === 'classname') {
          elem.removeAttribute('class');
        } else if (_Utilities_Is__WEBPACK_IMPORTED_MODULE_1__["Is"]["boolean"](value)) {
          removeBooleanProp(elem, name);
        } else {
          elem.removeAttribute(name);
        }
      }
    }]);

    return Props;
  }();
  /***/

},
/* 39 */

/***/
function (module, __webpack_exports__, __webpack_require__) {
  ;

  __webpack_require__.r(__webpack_exports__);
  /* harmony export (binding) */


  __webpack_require__.d(__webpack_exports__, "PropTypes", function () {
    return PropTypes;
  });

  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  function _defineProperty(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }

    return obj;
  }
  /*
  PropTypes.js
  
  Valence, a JavaScript library for building UI's, with an API
  resembling that of React, but uses Vanilla JS Web components
  under the hood...This file handles property type-checking
  functionality...
  
  Eric James Foster, MIT License.
  */


  var PropTypes = function PropTypes() {
    _classCallCheck(this, PropTypes);
  };

  _defineProperty(PropTypes, "boolean", {
    types: ['boolean', 'undefined'],
    isRequired: {
      types: ['boolean']
    }
  });

  _defineProperty(PropTypes, "number", {
    types: ['number', 'undefined'],
    isRequired: {
      types: ['number']
    }
  });

  _defineProperty(PropTypes, "string", {
    types: ['string', 'undefined'],
    isRequired: {
      types: ['string']
    }
  });

  _defineProperty(PropTypes, "symbol", {
    types: ['symbol', 'undefined'],
    isRequired: {
      types: ['symbol']
    }
  });

  _defineProperty(PropTypes, "object", {
    types: ['object', 'undefined'],
    isRequired: {
      types: ['number']
    }
  });

  _defineProperty(PropTypes, "array", {
    types: ['array', 'undefined'],
    isRequired: {
      types: ['array']
    }
  });
  /***/

},
/* 40 */

/***/
function (module, __webpack_exports__, __webpack_require__) {
  ;

  __webpack_require__.r(__webpack_exports__);
  /* harmony import */


  var _Utilities_helpers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(4);
  /* harmony import */


  var _Utilities_Loggers__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(33);
  /* harmony import */


  var _Utilities_Is__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(6);
  /* harmony import */


  var _Utilities_DOM_el__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(32);
  /* harmony import */


  var _Form_Node__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(35);
  /* harmony import */


  var _Utilities_data__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(5);
  /* harmony import */


  var _Events__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(37);
  /* harmony import */


  var dompurify__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(41);
  /* harmony import */


  var dompurify__WEBPACK_IMPORTED_MODULE_7___default =
  /*#__PURE__*/
  __webpack_require__.n(dompurify__WEBPACK_IMPORTED_MODULE_7__);
  /* harmony import */


  var stylis__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(42);
  /* harmony import */


  var stylis__WEBPACK_IMPORTED_MODULE_8___default =
  /*#__PURE__*/
  __webpack_require__.n(stylis__WEBPACK_IMPORTED_MODULE_8__);
  /* harmony import */


  var _Flare_CSS__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(43);

  function _typeof(obj) {
    if (typeof Symbol === "function" && _typeof2(Symbol.iterator) === "symbol") {
      _typeof = function _typeof(obj) {
        return _typeof2(obj);
      };
    } else {
      _typeof = function _typeof(obj) {
        return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : _typeof2(obj);
      };
    }

    return _typeof(obj);
  }

  function _objectSpread(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i] != null ? arguments[i] : {};
      var ownKeys = Object.keys(source);

      if (typeof Object.getOwnPropertySymbols === 'function') {
        ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) {
          return Object.getOwnPropertyDescriptor(source, sym).enumerable;
        }));
      }

      ownKeys.forEach(function (key) {
        _defineProperty(target, key, source[key]);
      });
    }

    return target;
  }

  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  function _defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    return Constructor;
  }

  function _possibleConstructorReturn(self, call) {
    if (call && (_typeof(call) === "object" || typeof call === "function")) {
      return call;
    }

    return _assertThisInitialized(self);
  }

  function _assertThisInitialized(self) {
    if (self === void 0) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }

    return self;
  }

  function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function");
    }

    subClass.prototype = Object.create(superClass && superClass.prototype, {
      constructor: {
        value: subClass,
        writable: true,
        configurable: true
      }
    });
    if (superClass) _setPrototypeOf(subClass, superClass);
  }

  function _wrapNativeSuper(Class) {
    var _cache = typeof Map === "function" ? new Map() : undefined;

    _wrapNativeSuper = function _wrapNativeSuper(Class) {
      if (Class === null || !_isNativeFunction(Class)) return Class;

      if (typeof Class !== "function") {
        throw new TypeError("Super expression must either be null or a function");
      }

      if (typeof _cache !== "undefined") {
        if (_cache.has(Class)) return _cache.get(Class);

        _cache.set(Class, Wrapper);
      }

      function Wrapper() {
        return _construct(Class, arguments, _getPrototypeOf(this).constructor);
      }

      Wrapper.prototype = Object.create(Class.prototype, {
        constructor: {
          value: Wrapper,
          enumerable: false,
          writable: true,
          configurable: true
        }
      });
      return _setPrototypeOf(Wrapper, Class);
    };

    return _wrapNativeSuper(Class);
  }

  function isNativeReflectConstruct() {
    if (typeof Reflect === "undefined" || !Reflect.construct) return false;
    if (Reflect.construct.sham) return false;
    if (typeof Proxy === "function") return true;

    try {
      Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));
      return true;
    } catch (e) {
      return false;
    }
  }

  function _construct(Parent, args, Class) {
    if (isNativeReflectConstruct()) {
      _construct = Reflect.construct;
    } else {
      _construct = function _construct(Parent, args, Class) {
        var a = [null];
        a.push.apply(a, args);
        var Constructor = Function.bind.apply(Parent, a);
        var instance = new Constructor();
        if (Class) _setPrototypeOf(instance, Class.prototype);
        return instance;
      };
    }

    return _construct.apply(null, arguments);
  }

  function _isNativeFunction(fn) {
    return Function.toString.call(fn).indexOf("[native code]") !== -1;
  }

  function _setPrototypeOf(o, p) {
    _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
      o.__proto__ = p;
      return o;
    };

    return _setPrototypeOf(o, p);
  }

  function _getPrototypeOf(o) {
    _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
      return o.__proto__ || Object.getPrototypeOf(o);
    };
    return _getPrototypeOf(o);
  }

  function _defineProperty(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }

    return obj;
  }
  /*
  Component.js
  
  This file handles component creation and
  functionality, including life cycle methods and
  state management....
  
  Eric James Foster, MIT License.
  */
  // Get utilities...
  // Get loggers...
  // Get type validation...
  // Get DOM querying function....
  // Get Node class...
  // Get data...
  // Get Events...
  // Get DOMPurify for HTML sanitization....
  // Bring in stylis and plugins for CSS preprocessing...
  // Get CSS parser...
  // Stylis configuration options...


  stylis__WEBPACK_IMPORTED_MODULE_8___default.a.set({
    global: false,
    cascade: true,
    keyframe: false,
    prefix: true,
    compress: false,
    semicolon: false
  }); // Globalize common utility functions...

  var dir = _Utilities_Loggers__WEBPACK_IMPORTED_MODULE_1__["_dir"];
  var log = _Utilities_Loggers__WEBPACK_IMPORTED_MODULE_1__["_log"];
  var el = _Utilities_DOM_el__WEBPACK_IMPORTED_MODULE_3__["default"];

  var Component =
  /*#__PURE__*/
  function (_HTMLElement) {
    _inherits(Component, _HTMLElement); // Instance vars....
    // Ctor...


    function Component() {
      var _this;

      _classCallCheck(this, Component);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(Component).call(this)); // Internal state...

      _defineProperty(_assertThisInitialized(_this), "state", null);

      _defineProperty(_assertThisInitialized(_this), "props", null);

      _defineProperty(_assertThisInitialized(_this), "_state", null);

      _defineProperty(_assertThisInitialized(_this), "_style", null);

      _this._state = {
        mounted: false // Public state...

      };
      _this.state = {}; // // Properties...

      _this.props = _this.observedAttributes; // Set lifecycle listeners...

      _Utilities_data__WEBPACK_IMPORTED_MODULE_5__["DATA"].ComponentLifecycleEvents.forEach(function (ev) {
        _this.addEventListener(ev, function (e) {
          _this[e.type](e.detail);
        });
      }, _assertThisInitialized(_this)); // Dispatch componentWillMount event...
      // Events.fire('componentWillMount', this)
      // this.componentWillMount()


      return _this;
    }
    /*
     * Public API...
     * * * * * * * *
     */
    // Class method for immutably setting component state...


    _createClass(Component, [{
      key: "setState",
      value: function setState(obj) {
        // Convert incoming object to array of entries to be manipulated by array.reduce...
        var newStateArray = Object.entries(obj); // Combine old/new state and set on state object...

        this.state = newStateArray.reduce(function (newState, stateEntry) {
          return _objectSpread({}, newState, _defineProperty({}, stateEntry[0], stateEntry[1]));
        }, this.state); // Now that state is reset, trigger a render cycle...

        this._update(); // Return state object...


        return this.state;
      }
      /*
       * The following methods are callbacks for various component
       * lifecycle events, and are intended to be overridden when
       * components are defined by the user...
       */
      // This method is for doing any necessary setting up just before the component
      // mounts. The event is fired just before it's constructor returns, see above...

    }, {
      key: "componentWillMount",
      value: function componentWillMount() {
        log('componentWillMount', ['white', 'blue']);
        return;
      } // This method is for doing any component work just after mounting occurs. It is
      // called by this.connectedCallback() (see below)...

    }, {
      key: "componentDidMount",
      value: function componentDidMount() {
        log('componentDidMount', ['white', 'blue']);
        return;
      } // This event is fired just before an imminent unmounting of a
      // component occurs. The event is fired in Valence.js at Valence.unMount()
      // line 140 & also in Form.js at Form.updateElement(), line 107...

    }, {
      key: "componentWillUnmount",
      value: function componentWillUnmount() {
        log('componentWillUnmount', ['white', 'red']);
        return;
      } // This method is called by this.disconnectedCallback() (see below), just after unmounting...

    }, {
      key: "componentDidUnmount",
      value: function componentDidUnmount() {
        log('componentDidUnmount', ['white', 'red']);
        return;
      } // This callback is called just before the component recieves props. The event
      // is fired in Element.js at Element.createElement(), line 60, when the
      // component is created, and also in Form.js at Form.updateElement(), line 127,
      // when the component is updating...

    }, {
      key: "componentWillReceiveProps",
      value: function componentWillReceiveProps(nextProps) {
        log('componentDidRecieveProps', ['white', 'orange']);
        return;
      } // This callback is called just after the component confirms an update should
      // take place with `shouldComponentUpdate`, and just before the update occurs. It's
      // corresponding event is fired in this._update(), line 62...

    }, {
      key: "componentWillUpdate",
      value: function componentWillUpdate(nextProps) {
        log('componentWillUpdate', ['white', 'green']);
        return;
      } // This callback is called just after the component completes the update process.
      // It's corresponding event is fired in this._update(), line 70...

    }, {
      key: "componentDidUpdate",
      value: function componentDidUpdate(props) {
        log('componentWillUpdate', ['white', 'green']);
        return;
      }
    }, {
      key: "shouldComponentUpdate",
      value: function shouldComponentUpdate(nextProps, nextState, name, oldVal, newVal) {
        log('componentShouldUpdate', ['white', 'yellow']);
        return true;
      }
      /* This method is called by connectedCallback, and can be used to do any work
      once the element is connected...*/
      //   propsCallback() {
      // // To be overridden......
      //     return
      //   }

      /* This method is called by attributesChangedCallback, and can be used to do any work
      once attributes change...*/

    }, {
      key: "onChange",
      value: function onChange() {
        // To be overridden......
        return;
      } // Component render method...

    }, {
      key: "render",
      value: function render() {
        // Must be overridden with returned markup...
        return; // ...Markup Here....
      }
      /*
      *** Component Authoring Methods.....
      **********************************>>>>>
      */
      // An Instance method for setting attributes of custom elements...

    }, {
      key: "registerProps",
      value: function registerProps(props) {
        var _this2 = this; // Convert props object to array....


        Object.entries(props).forEach(function (prop) {
          // Set the default prop value on it's instance variable...
          _this2["_".concat(prop[0])] = prop[1]["default"]; // Define the props as HTML attributes...

          Object.defineProperties(_this2, _defineProperty({}, prop[0], {
            get: function get() {
              return this["_".concat(prop[0])];
            },
            set: function set(val) {
              if (val) {
                this.setAttribute(prop[0], val);
                this["_".concat(prop[0])] = val;
              } else {
                this.removeAttribute(prop[0]);
              }
            },
            enumerable: true,
            configurable: true
          }));
        });
      } // An instance method for updating element props with user defined props....

    }, {
      key: "applyUserProps",
      value: function applyUserProps(observed) {
        for (var _i = 0, _Object$keys = Object.keys(observed); _i < _Object$keys.length; _i++) {
          var prop = _Object$keys[_i];

          if (prop in this) {
            /* Seem to be having an issue here with the this.gutters props/attribute. It
            seems that we are unable to change the property from the default value to anything
            falsey. I was not able to figure out exactly why, but I did find a workaround,
            Below we are going directly to the backing variable, an instance var that all
            the props need in order to set a default value. The getter for the prop returns
            this value, whose name is in the format `_ + propName`. */
            this["_".concat(prop)] = observed[prop];
          }
        }
      } // Instance method for Component authors that aids in ShadowDOM creation....

    }, {
      key: "shadowCaster",
      value: function shadowCaster(userOptions) {
        var options = {
          mode: 'open',
          slot: true
        },
            _combineObjects = Object(_Utilities_helpers__WEBPACK_IMPORTED_MODULE_0__["combineObjects"])(options, userOptions),
            mode = _combineObjects.mode,
            slot = _combineObjects.slot,
            shadowRoot = this.attachShadow({
          mode: mode
        }); // If a slot is truthy


        if (slot) {
          // Create a slot element...
          var slotEl = document.createElement('slot'); // If slot is an object, and has a name... pass it on to the element...

          if (slot.name) {
            slotEl.name = slot.name;
          } // Append the slot to this element...


          shadowRoot.appendChild(slotEl);
        }

        return shadowRoot;
      } // Instance method for Component authors that aids in slot element creation....

    }, {
      key: "addSlots",
      value: function addSlots(root) {
        var slots = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false; // If an object is passed in....

        if (slots) {
          Object.values.forEach(function (val) {
            // Get a slot...
            var slot = document.createElement('slot'); // Give it a name...

            slot.name = val; // Attach slot to root....

            root.appendChild(slot);
          });
        } else {
          root.appendChild(document.createElement('slot'));
        } // Return the root....


        return root;
      } // Instance method for Component authors that aids in adding styles to componentsn....

    }, {
      key: "addStyles",
      value: function addStyles(root, styles) {
        // Create style el....
        var style = document.createElement('style'); // Process styles and append to style el...

        style.innerHTML = stylis__WEBPACK_IMPORTED_MODULE_8___default()('', styles); // Append style el to shadow root...

        root.appendChild(style); // Return the root...

        return style;
      }
      /* A private method for appending a CSS rule or an array of CSS rules to the default stylesheet,
      one by one.*/

    }, {
      key: "insertRules",
      value: function insertRules(ttl, style) {
        // Separate the ttl into individual rules....
        var rules = _Flare_CSS__WEBPACK_IMPORTED_MODULE_9__["CSS"].separateStyleRules(ttl); // log('RULES');dir(rules)


        if (Object(_Utilities_Is__WEBPACK_IMPORTED_MODULE_2__["isArray"])(rules)) {
          // Insert rules...
          rules.forEach(function (rule) {
            style.sheet.insertRule(rule);
          });
        } else {
          // Insert rule..
          style.sheet.insertRule(rules);
        }
      } // Instance method for processing css with stylis...

    }, {
      key: "processStyles",
      value: function processStyles(css) {
        return stylis__WEBPACK_IMPORTED_MODULE_8___default()(':host', css);
      } // Helper method for adding classes to the component's classList....

    }, {
      key: "addClass",
      value: function addClass(class_) {
        return this.classList.add(class_);
      } // Helper method for removing classes from the component's classList....

    }, {
      key: "removeClass",
      value: function removeClass(class_) {
        return this.classList.remove(class_);
      }
      /*
       * Private Methods....
       * * * * * * * * * * *
       */
      //FIXME: Figure out how to add nextProps here.....VVVV **DONE?**
      // Private class method for diffing and patching the dom...

    }, {
      key: "_update",
      value: function _update() {
        if (this.shouldComponentUpdate(this.props, this.state)) {
          // Fire componentWillUpdate event...
          _Events__WEBPACK_IMPORTED_MODULE_6__["Events"].fire('componentWillUpdate', this, {
            'nextProps': this.props,
            'state': this.state
          }); // Update the component tree...


          this.form.updateDOM(this.render(this.props)); // Fire componentDidUpdate event...

          _Events__WEBPACK_IMPORTED_MODULE_6__["Events"].fire('componentDidUpdate', this, {
            'props': this.props,
            'state': this.state
          });
        }
      } // A private method for appending the child nodes of a component...

    }, {
      key: "_appendChildren",
      value: function _appendChildren(props) {
        /* Declare regexp that will help is determine whether or not the render() method
        has been overridden or not.... We also need the method's source code to inspect....*/
        var renderRE = /...Markup Here..../g,
            renderFuncSource = this.render.toString(); // Set props on a class variable...
        // this.props = props

        /* If we don't get a match with the regexp, then the method has been overridden
        with markup that needs appended ....*/

        if (!renderRE.test(renderFuncSource)) {
          return this.appendChild(_Form_Node__WEBPACK_IMPORTED_MODULE_4__["Node"].createNode(this.render(this.props)));
        }
      } // Used as an internal cue for updating, this method is built into the custom
      // elements v1 API...

    }, {
      key: "attributesChangedCallback",
      value: function attributesChangedCallback(name, oldVal, newVal) {
        console.info("the attribute \"".concat(name, "\" changed from \"").concat(olVal, "\" to \"").concat(newVal, "\".")); // Call propsChangedCallback.....

        onChange(name, oldVal, newVal); // Confirm an update with sCU(), then trigger a diff and patch cycle...

        if (this.shouldComponentUpdate(null, null, name, oldVal, newVal)) {
          this._update(this.render(this.props));
        }
      } // Used internally for post-mount operations, this method is built into the custom
      // elements v1 API...

    }, {
      key: "connectedCallback",
      value: function connectedCallback() {
        /* Technically the component is already mounted here, but it's DOM tree has yet
         * to be added. This is the closest point in the component lifecycle that I can
         * get thus far to a component will mount event.. As you can see below, once
         * the component's children are added, we consider it to be fully `mounted`
         * and fire it's `didMount` event....
         */
        // Call willMount callback...
        this.componentWillMount(); // Append the component's children...

        this._appendChildren(); // Initialize event listeners...
        // this._initializeEvents()
        // Do any prop related work here...
        // this.propsCallback()
        // Call didMount callback...


        this.componentDidMount();
      } // Used internally for post-unmount operations, this method is built into the custom
      // elements v1 API...

    }, {
      key: "disconnectedCallback",
      value: function disconnectedCallback() {
        this.componentDidUnmount();
      } // A static public method used internally to create a Valence component...

    }], [{
      key: "createComponent",
      value: function createComponent(component, props, children) {
        // Pre-declare inner functions, mainly for style considerations...
        var appendChildren,
            reflect,
            shadowBool,
            tagName = component[2]; // Create the DOM tree for the component....

        appendChildren = function appendChildren(elem) {
          var shadow = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false; // If elem is a shadowRoot, give it a slot...

          if (shadow) {
            var slot = document.createElement('slot');
            elem.appendChild(slot);
          } // Append nodes...


          return elem.appendChild(_Form_Node__WEBPACK_IMPORTED_MODULE_4__["Node"].createNode(component[1](props)));
        }; // NO LONGER IN USE... CURRENTLY USING BUILT IN JS REFLECT CLASS....
        // Using a metaprogramming technique called reflection via javascript's evaluation
        // function to create dynamic element registration.... Will check out es6's new
        // metaprogramming features (Reflect, Symbols and Proxy) to see If this can be
        // accomplished without using eval... *** DONE ***


        reflect = function reflect(code) {
          // But for now...
          return eval(code);
        }; // Return boolean value for shadow...


        shadowBool = function shadowBool(arr) {
          return arr.reduce(function (shadow, keyVal, index) {
            return keyVal.indexOf('shadow') == -1 ? shadow : index;
          }, false);
        };
        /*
        ==== Define custom element/web component...
        ====================================================================>>>
        * Doing a bit of finagling with the native-shim to make things work
        * here.. When a web component is defined in a manner as below,
        * the shim cannot be used, and we must be using a native implementation
        * of HTMLElement. The following 2 lines accomplish both. Both must
        * be reset (the shim and patched HTMLElement used) in order for es6
        * class definition of custom elements to work.. and they are
        * just after every custom element's call to HTMLElement from
        * document.createElement() for element instantiation.........
        */


        window.useNativeShim = false;
        window.HTMLElement = window._HTMLElement;

        var _HTMLComponent,
            eListeners = [],
            customProps = [],
            shadow,
            obj; // Get attribute names and Listeners...


        if (props) {
          obj = Object(_Utilities_helpers__WEBPACK_IMPORTED_MODULE_0__["processData"])(Object(_Utilities_helpers__WEBPACK_IMPORTED_MODULE_0__["propsArray"])(props)); // Store attribute and Listener pairs...

          customProps = obj.props;
          eListeners = obj.eventListeners; // Determine if shadow option is set or not...

          shadow = shadowBool(customProps) !== false ? customProps[shadowBool(customProps)][1] : // This is the default setting for Valence component shadow dom....
          false;
        } // Declare self here so that it may be used in this scope, below
        // the ctor definition...


        var self; // Define constructor of the custom element....

        _HTMLComponent = function HTMLComponent() {
          //Self will function as `this` for this constructor... Determine the type of element
          //to construct and go...
          self = Reflect.construct(HTMLElement, [], _HTMLComponent); // Use `self` as this to add props to the constructor...

          if (shadow && !props.noChild) {
            // Create shadow root and pass it in to append children function...
            var shadowRoot = self.attachShadow({
              mode: 'open'
            });
            appendChildren(shadowRoot, true);
          } // Add event listeners...


          if (eListeners.length > 0) {
            eListeners.forEach(function (entry) {
              return self.addEventListener(entry[0], self[entry[1]]);
            }, self);
          }

          return self;
        }; // Add superclass prototype...


        _HTMLComponent.prototype = Object.create(HTMLElement.prototype); // Add constructor...

        _HTMLComponent.prototype.constructor = _HTMLComponent; // Register event listener methods..

        _Events__WEBPACK_IMPORTED_MODULE_6__["Events"].registerCallbacks(_HTMLComponent, eListeners); // console.dir(HTMLComponent)
        // Add connectedCallback method appending children if shadow is false...


        _HTMLComponent.prototype.connectedCallback = function () {
          if (!shadow && !props.noChild) {
            appendChildren(self);
          } // Check for cleanHTML prop....


          if (props.cleanHTML) {
            //log('DOMPURIFY', 'yellow')// log(DOMPurify.sanitize('<img src=x onerror=alert(1)//>'))
            self.insertAdjacentHTML('afterbegin', dompurify__WEBPACK_IMPORTED_MODULE_7___default.a.sanitize(props.cleanHTML));
          }
        }; // Return the component constructor...


        return _HTMLComponent;
      } // End of Class....

    }]);

    return Component;
  }(_wrapNativeSuper(HTMLElement));
  /* harmony default export */


  __webpack_exports__["default"] = Component; // // An instance method for updating element props with user defined props....
  //   applyUserProps(observed) {
  //     log('###########################IN_COMPONENTDIDMOUNT##################################################', ['yellow', 'blue'])
  //     dir(this)
  //     for (let prop of Object.keys(observed)) {
  //       if (prop in this) {
  //         log(`prop: ${String(prop)}`, ['tomato', 'white'])
  //         log(`${String(prop)} = ${this[prop]}`, 'orange')
  //         log(`will be: ${observed[prop]}`)
  // /* Seem to be having an issue here with the this.gutters props/attribute. It
  // seems that we are unable to change the property from the default value to anything
  // falsey. I was not able to figure out exactly why, but I did find a workaround,
  // Below we are going directly to the backing variable, an instance var that all
  // the props need in order to set a default value. The getter for the prop returns
  // this value, whose name is in the format `_ + propName`. */
  //         this[`_${prop}`] = observed[prop]
  //         // if (String(prop) == 'gutters' && this[prop] == '15px') {
  //         //   log('hi there', 'green')
  //         //   this['_gutters'] = !true
  //         // }
  //         log(`${String(prop)}: ${this[prop]}`, 'yellow')
  //         log(`_${String(prop)}: ${this["_" + prop]}`, 'yellow')
  //       }
  //     }
  //   }

  /***/
},
/* 41 */

/***/
function (module, exports, __webpack_require__) {
  (function (global, factory) {
    true ? module.exports = factory() : undefined;
  })(this, function () {
    'use strict';

    var freeze$1 = Object.freeze || function (x) {
      return x;
    };

    var html = freeze$1(['a', 'abbr', 'acronym', 'address', 'area', 'article', 'aside', 'audio', 'b', 'bdi', 'bdo', 'big', 'blink', 'blockquote', 'body', 'br', 'button', 'canvas', 'caption', 'center', 'cite', 'code', 'col', 'colgroup', 'content', 'data', 'datalist', 'dd', 'decorator', 'del', 'details', 'dfn', 'dir', 'div', 'dl', 'dt', 'element', 'em', 'fieldset', 'figcaption', 'figure', 'font', 'footer', 'form', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'head', 'header', 'hgroup', 'hr', 'html', 'i', 'img', 'input', 'ins', 'kbd', 'label', 'legend', 'li', 'main', 'map', 'mark', 'marquee', 'menu', 'menuitem', 'meter', 'nav', 'nobr', 'ol', 'optgroup', 'option', 'output', 'p', 'pre', 'progress', 'q', 'rp', 'rt', 'ruby', 's', 'samp', 'section', 'select', 'shadow', 'small', 'source', 'spacer', 'span', 'strike', 'strong', 'style', 'sub', 'summary', 'sup', 'table', 'tbody', 'td', 'template', 'textarea', 'tfoot', 'th', 'thead', 'time', 'tr', 'track', 'tt', 'u', 'ul', 'var', 'video', 'wbr']); // SVG

    var svg = freeze$1(['svg', 'a', 'altglyph', 'altglyphdef', 'altglyphitem', 'animatecolor', 'animatemotion', 'animatetransform', 'audio', 'canvas', 'circle', 'clippath', 'defs', 'desc', 'ellipse', 'filter', 'font', 'g', 'glyph', 'glyphref', 'hkern', 'image', 'line', 'lineargradient', 'marker', 'mask', 'metadata', 'mpath', 'path', 'pattern', 'polygon', 'polyline', 'radialgradient', 'rect', 'stop', 'style', 'switch', 'symbol', 'text', 'textpath', 'title', 'tref', 'tspan', 'video', 'view', 'vkern']);
    var svgFilters = freeze$1(['feBlend', 'feColorMatrix', 'feComponentTransfer', 'feComposite', 'feConvolveMatrix', 'feDiffuseLighting', 'feDisplacementMap', 'feDistantLight', 'feFlood', 'feFuncA', 'feFuncB', 'feFuncG', 'feFuncR', 'feGaussianBlur', 'feMerge', 'feMergeNode', 'feMorphology', 'feOffset', 'fePointLight', 'feSpecularLighting', 'feSpotLight', 'feTile', 'feTurbulence']);
    var mathMl = freeze$1(['math', 'menclose', 'merror', 'mfenced', 'mfrac', 'mglyph', 'mi', 'mlabeledtr', 'mmultiscripts', 'mn', 'mo', 'mover', 'mpadded', 'mphantom', 'mroot', 'mrow', 'ms', 'mspace', 'msqrt', 'mstyle', 'msub', 'msup', 'msubsup', 'mtable', 'mtd', 'mtext', 'mtr', 'munder', 'munderover']);
    var text = freeze$1(['#text']);

    var freeze$2 = Object.freeze || function (x) {
      return x;
    };

    var html$1 = freeze$2(['accept', 'action', 'align', 'alt', 'autocomplete', 'background', 'bgcolor', 'border', 'cellpadding', 'cellspacing', 'checked', 'cite', 'class', 'clear', 'color', 'cols', 'colspan', 'coords', 'crossorigin', 'datetime', 'default', 'dir', 'disabled', 'download', 'enctype', 'face', 'for', 'headers', 'height', 'hidden', 'high', 'href', 'hreflang', 'id', 'integrity', 'ismap', 'label', 'lang', 'list', 'loop', 'low', 'max', 'maxlength', 'media', 'method', 'min', 'multiple', 'name', 'noshade', 'novalidate', 'nowrap', 'open', 'optimum', 'pattern', 'placeholder', 'poster', 'preload', 'pubdate', 'radiogroup', 'readonly', 'rel', 'required', 'rev', 'reversed', 'role', 'rows', 'rowspan', 'spellcheck', 'scope', 'selected', 'shape', 'size', 'sizes', 'span', 'srclang', 'start', 'src', 'srcset', 'step', 'style', 'summary', 'tabindex', 'title', 'type', 'usemap', 'valign', 'value', 'width', 'xmlns']);
    var svg$1 = freeze$2(['accent-height', 'accumulate', 'additive', 'alignment-baseline', 'ascent', 'attributename', 'attributetype', 'azimuth', 'basefrequency', 'baseline-shift', 'begin', 'bias', 'by', 'class', 'clip', 'clip-path', 'clip-rule', 'color', 'color-interpolation', 'color-interpolation-filters', 'color-profile', 'color-rendering', 'cx', 'cy', 'd', 'dx', 'dy', 'diffuseconstant', 'direction', 'display', 'divisor', 'dur', 'edgemode', 'elevation', 'end', 'fill', 'fill-opacity', 'fill-rule', 'filter', 'flood-color', 'flood-opacity', 'font-family', 'font-size', 'font-size-adjust', 'font-stretch', 'font-style', 'font-variant', 'font-weight', 'fx', 'fy', 'g1', 'g2', 'glyph-name', 'glyphref', 'gradientunits', 'gradienttransform', 'height', 'href', 'id', 'image-rendering', 'in', 'in2', 'k', 'k1', 'k2', 'k3', 'k4', 'kerning', 'keypoints', 'keysplines', 'keytimes', 'lang', 'lengthadjust', 'letter-spacing', 'kernelmatrix', 'kernelunitlength', 'lighting-color', 'local', 'marker-end', 'marker-mid', 'marker-start', 'markerheight', 'markerunits', 'markerwidth', 'maskcontentunits', 'maskunits', 'max', 'mask', 'media', 'method', 'mode', 'min', 'name', 'numoctaves', 'offset', 'operator', 'opacity', 'order', 'orient', 'orientation', 'origin', 'overflow', 'paint-order', 'path', 'pathlength', 'patterncontentunits', 'patterntransform', 'patternunits', 'points', 'preservealpha', 'preserveaspectratio', 'r', 'rx', 'ry', 'radius', 'refx', 'refy', 'repeatcount', 'repeatdur', 'restart', 'result', 'rotate', 'scale', 'seed', 'shape-rendering', 'specularconstant', 'specularexponent', 'spreadmethod', 'stddeviation', 'stitchtiles', 'stop-color', 'stop-opacity', 'stroke-dasharray', 'stroke-dashoffset', 'stroke-linecap', 'stroke-linejoin', 'stroke-miterlimit', 'stroke-opacity', 'stroke', 'stroke-width', 'style', 'surfacescale', 'tabindex', 'targetx', 'targety', 'transform', 'text-anchor', 'text-decoration', 'text-rendering', 'textlength', 'type', 'u1', 'u2', 'unicode', 'values', 'viewbox', 'visibility', 'version', 'vert-adv-y', 'vert-origin-x', 'vert-origin-y', 'width', 'word-spacing', 'wrap', 'writing-mode', 'xchannelselector', 'ychannelselector', 'x', 'x1', 'x2', 'xmlns', 'y', 'y1', 'y2', 'z', 'zoomandpan']);
    var mathMl$1 = freeze$2(['accent', 'accentunder', 'align', 'bevelled', 'close', 'columnsalign', 'columnlines', 'columnspan', 'denomalign', 'depth', 'dir', 'display', 'displaystyle', 'fence', 'frame', 'height', 'href', 'id', 'largeop', 'length', 'linethickness', 'lspace', 'lquote', 'mathbackground', 'mathcolor', 'mathsize', 'mathvariant', 'maxsize', 'minsize', 'movablelimits', 'notation', 'numalign', 'open', 'rowalign', 'rowlines', 'rowspacing', 'rowspan', 'rspace', 'rquote', 'scriptlevel', 'scriptminsize', 'scriptsizemultiplier', 'selection', 'separator', 'separators', 'stretchy', 'subscriptshift', 'supscriptshift', 'symmetric', 'voffset', 'width', 'xmlns']);
    var xml = freeze$2(['xlink:href', 'xml:id', 'xlink:title', 'xml:space', 'xmlns:xlink']);
    var hasOwnProperty = Object.hasOwnProperty;
    var setPrototypeOf = Object.setPrototypeOf;

    var _ref$1 = typeof Reflect !== 'undefined' && Reflect;

    var apply$1 = _ref$1.apply;

    if (!apply$1) {
      apply$1 = function apply(fun, thisValue, args) {
        return fun.apply(thisValue, args);
      };
    }
    /* Add properties to a lookup table */


    function addToSet(set, array) {
      if (setPrototypeOf) {
        // Make 'in' and truthy checks like Boolean(set.constructor)
        // independent of any properties defined on Object.prototype.
        // Prevent prototype setters from intercepting set as a this value.
        setPrototypeOf(set, null);
      }

      var l = array.length;

      while (l--) {
        var element = array[l];

        if (typeof element === 'string') {
          var lcElement = element.toLowerCase();

          if (lcElement !== element) {
            // Config presets (e.g. tags.js, attrs.js) are immutable.
            if (!Object.isFrozen(array)) {
              array[l] = lcElement;
            }

            element = lcElement;
          }
        }

        set[element] = true;
      }

      return set;
    }
    /* Shallow clone an object */


    function clone(object) {
      var newObject = {};
      var property = void 0;

      for (property in object) {
        if (apply$1(hasOwnProperty, object, [property])) {
          newObject[property] = object[property];
        }
      }

      return newObject;
    }

    var seal = Object.seal || function (x) {
      return x;
    };

    var MUSTACHE_EXPR = seal(/\{\{[\s\S]*|[\s\S]*\}\}/gm); // Specify template detection regex for SAFE_FOR_TEMPLATES mode

    var ERB_EXPR = seal(/<%[\s\S]*|[\s\S]*%>/gm);
    var DATA_ATTR = seal(/^data-[\-\w.\u00B7-\uFFFF]/); // eslint-disable-line no-useless-escape

    var ARIA_ATTR = seal(/^aria-[\-\w]+$/); // eslint-disable-line no-useless-escape

    var IS_ALLOWED_URI = seal(/^(?:(?:(?:f|ht)tps?|mailto|tel|callto|cid|xmpp):|[^a-z]|[a-z+.\-]+(?:[^a-z+.\-:]|$))/i // eslint-disable-line no-useless-escape
    );
    var IS_SCRIPT_OR_DATA = seal(/^(?:\w+script|data):/i);
    var ATTR_WHITESPACE = seal(/[\u0000-\u0020\u00A0\u1680\u180E\u2000-\u2029\u205f\u3000]/g // eslint-disable-line no-control-regex
    );

    var _typeof = typeof Symbol === "function" && _typeof2(Symbol.iterator) === "symbol" ? function (obj) {
      return _typeof2(obj);
    } : function (obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : _typeof2(obj);
    };

    function _toConsumableArray(arr) {
      if (Array.isArray(arr)) {
        for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {
          arr2[i] = arr[i];
        }

        return arr2;
      } else {
        return Array.from(arr);
      }
    }

    var _ref = typeof Reflect !== 'undefined' && Reflect;

    var apply = _ref.apply;
    var arraySlice = Array.prototype.slice;
    var freeze = Object.freeze;

    var getGlobal = function getGlobal() {
      return typeof window === 'undefined' ? null : window;
    };

    if (!apply) {
      apply = function apply(fun, thisValue, args) {
        return fun.apply(thisValue, args);
      };
    }
    /**
     * Creates a no-op policy for internal use only.
     * Don't export this function outside this module!
     * @param {?TrustedTypePolicyFactory} trustedTypes The policy factory.
     * @param {Document} document The document object (to determine policy name suffix)
     * @return {?TrustedTypePolicy} The policy created (or null, if Trusted Types
     * are not supported).
     */


    var _createTrustedTypesPolicy = function _createTrustedTypesPolicy(trustedTypes, document) {
      if ((typeof trustedTypes === 'undefined' ? 'undefined' : _typeof(trustedTypes)) !== 'object' || typeof trustedTypes.createPolicy !== 'function') {
        return null;
      } // Allow the callers to control the unique policy name
      // by adding a data-tt-policy-suffix to the script element with the DOMPurify.
      // Policy creation with duplicate names throws in Trusted Types.


      var suffix = null;
      var ATTR_NAME = 'data-tt-policy-suffix';

      if (document.currentScript && document.currentScript.hasAttribute(ATTR_NAME)) {
        suffix = document.currentScript.getAttribute(ATTR_NAME);
      }

      var policyName = 'dompurify' + (suffix ? '#' + suffix : '');

      try {
        return trustedTypes.createPolicy(policyName, {
          createHTML: function createHTML(html$$1) {
            return html$$1;
          }
        });
      } catch (error) {
        // Policy creation failed (most likely another DOMPurify script has
        // already run). Skip creating the policy, as this will only cause errors
        // if TT are enforced.
        console.warn('TrustedTypes policy ' + policyName + ' could not be created.');
        return null;
      }
    };

    function createDOMPurify() {
      var window = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : getGlobal();

      var DOMPurify = function DOMPurify(root) {
        return createDOMPurify(root);
      };
      /**
       * Version label, exposed for easier checks
       * if DOMPurify is up to date or not
       */


      DOMPurify.version = '1.0.10';
      /**
       * Array of elements that DOMPurify removed during sanitation.
       * Empty if nothing was removed.
       */

      DOMPurify.removed = [];

      if (!window || !window.document || window.document.nodeType !== 9) {
        // Not running in a browser, provide a factory function
        // so that you can pass your own Window
        DOMPurify.isSupported = false;
        return DOMPurify;
      }

      var originalDocument = window.document;
      var useDOMParser = false;
      var removeTitle = false;
      var document = window.document;
      var DocumentFragment = window.DocumentFragment,
          HTMLTemplateElement = window.HTMLTemplateElement,
          Node = window.Node,
          NodeFilter = window.NodeFilter,
          _window$NamedNodeMap = window.NamedNodeMap,
          NamedNodeMap = _window$NamedNodeMap === undefined ? window.NamedNodeMap || window.MozNamedAttrMap : _window$NamedNodeMap,
          Text = window.Text,
          Comment = window.Comment,
          DOMParser = window.DOMParser,
          TrustedTypes = window.TrustedTypes; // As per issue #47, the web-components registry is inherited by a
      // new document created via createHTMLDocument. As per the spec
      // (http://w3c.github.io/webcomponents/spec/custom/#creating-and-passing-registries)
      // a new empty registry is used when creating a template contents owner
      // document, so we use that as our parent document to ensure nothing
      // is inherited.

      if (typeof HTMLTemplateElement === 'function') {
        var template = document.createElement('template');

        if (template.content && template.content.ownerDocument) {
          document = template.content.ownerDocument;
        }
      }

      var trustedTypesPolicy = _createTrustedTypesPolicy(TrustedTypes, originalDocument);

      var emptyHTML = trustedTypesPolicy ? trustedTypesPolicy.createHTML('') : '';
      var _document = document,
          implementation = _document.implementation,
          createNodeIterator = _document.createNodeIterator,
          getElementsByTagName = _document.getElementsByTagName,
          createDocumentFragment = _document.createDocumentFragment;
      var importNode = originalDocument.importNode;
      var hooks = {};
      /**
       * Expose whether this browser supports running the full DOMPurify.
       */

      DOMPurify.isSupported = implementation && typeof implementation.createHTMLDocument !== 'undefined' && document.documentMode !== 9;
      var MUSTACHE_EXPR$$1 = MUSTACHE_EXPR,
          ERB_EXPR$$1 = ERB_EXPR,
          DATA_ATTR$$1 = DATA_ATTR,
          ARIA_ATTR$$1 = ARIA_ATTR,
          IS_SCRIPT_OR_DATA$$1 = IS_SCRIPT_OR_DATA,
          ATTR_WHITESPACE$$1 = ATTR_WHITESPACE;
      var IS_ALLOWED_URI$$1 = IS_ALLOWED_URI;
      /**
       * We consider the elements and attributes below to be safe. Ideally
       * don't add any new ones but feel free to remove unwanted ones.
       */

      /* allowed element names */

      var ALLOWED_TAGS = null;
      var DEFAULT_ALLOWED_TAGS = addToSet({}, [].concat(_toConsumableArray(html), _toConsumableArray(svg), _toConsumableArray(svgFilters), _toConsumableArray(mathMl), _toConsumableArray(text)));
      /* Allowed attribute names */

      var ALLOWED_ATTR = null;
      var DEFAULT_ALLOWED_ATTR = addToSet({}, [].concat(_toConsumableArray(html$1), _toConsumableArray(svg$1), _toConsumableArray(mathMl$1), _toConsumableArray(xml)));
      /* Explicitly forbidden tags (overrides ALLOWED_TAGS/ADD_TAGS) */

      var FORBID_TAGS = null;
      /* Explicitly forbidden attributes (overrides ALLOWED_ATTR/ADD_ATTR) */

      var FORBID_ATTR = null;
      /* Decide if ARIA attributes are okay */

      var ALLOW_ARIA_ATTR = true;
      /* Decide if custom data attributes are okay */

      var ALLOW_DATA_ATTR = true;
      /* Decide if unknown protocols are okay */

      var ALLOW_UNKNOWN_PROTOCOLS = false;
      /* Output should be safe for jQuery's $() factory? */

      var SAFE_FOR_JQUERY = false;
      /* Output should be safe for common template engines.
       * This means, DOMPurify removes data attributes, mustaches and ERB
       */

      var SAFE_FOR_TEMPLATES = false;
      /* Decide if document with <html>... should be returned */

      var WHOLE_DOCUMENT = false;
      /* Track whether config is already set on this instance of DOMPurify. */

      var SET_CONFIG = false;
      /* Decide if all elements (e.g. style, script) must be children of
       * document.body. By default, browsers might move them to document.head */

      var FORCE_BODY = false;
      /* Decide if a DOM `HTMLBodyElement` should be returned, instead of a html
       * string (or a TrustedHTML object if Trusted Types are supported).
       * If `WHOLE_DOCUMENT` is enabled a `HTMLHtmlElement` will be returned instead
       */

      var RETURN_DOM = false;
      /* Decide if a DOM `DocumentFragment` should be returned, instead of a html
       * string  (or a TrustedHTML object if Trusted Types are supported) */

      var RETURN_DOM_FRAGMENT = false;
      /* If `RETURN_DOM` or `RETURN_DOM_FRAGMENT` is enabled, decide if the returned DOM
       * `Node` is imported into the current `Document`. If this flag is not enabled the
       * `Node` will belong (its ownerDocument) to a fresh `HTMLDocument`, created by
       * DOMPurify. */

      var RETURN_DOM_IMPORT = false;
      /* Output should be free from DOM clobbering attacks? */

      var SANITIZE_DOM = true;
      /* Keep element content when removing element? */

      var KEEP_CONTENT = true;
      /* If a `Node` is passed to sanitize(), then performs sanitization in-place instead
       * of importing it into a new Document and returning a sanitized copy */

      var IN_PLACE = false;
      /* Allow usage of profiles like html, svg and mathMl */

      var USE_PROFILES = {};
      /* Tags to ignore content of when KEEP_CONTENT is true */

      var FORBID_CONTENTS = addToSet({}, ['audio', 'head', 'math', 'script', 'style', 'template', 'svg', 'video']);
      /* Tags that are safe for data: URIs */

      var DATA_URI_TAGS = addToSet({}, ['audio', 'video', 'img', 'source', 'image']);
      /* Attributes safe for values like "javascript:" */

      var URI_SAFE_ATTRIBUTES = addToSet({}, ['alt', 'class', 'for', 'id', 'label', 'name', 'pattern', 'placeholder', 'summary', 'title', 'value', 'style', 'xmlns']);
      /* Keep a reference to config to pass to hooks */

      var CONFIG = null;
      /* Ideally, do not touch anything below this line */

      /* ______________________________________________ */

      var formElement = document.createElement('form');
      /**
       * _parseConfig
       *
       * @param  {Object} cfg optional config literal
       */
      // eslint-disable-next-line complexity

      var _parseConfig = function _parseConfig(cfg) {
        if (CONFIG && CONFIG === cfg) {
          return;
        }
        /* Shield configuration object from tampering */


        if (!cfg || (typeof cfg === 'undefined' ? 'undefined' : _typeof(cfg)) !== 'object') {
          cfg = {};
        }
        /* Set configuration parameters */


        ALLOWED_TAGS = 'ALLOWED_TAGS' in cfg ? addToSet({}, cfg.ALLOWED_TAGS) : DEFAULT_ALLOWED_TAGS;
        ALLOWED_ATTR = 'ALLOWED_ATTR' in cfg ? addToSet({}, cfg.ALLOWED_ATTR) : DEFAULT_ALLOWED_ATTR;
        FORBID_TAGS = 'FORBID_TAGS' in cfg ? addToSet({}, cfg.FORBID_TAGS) : {};
        FORBID_ATTR = 'FORBID_ATTR' in cfg ? addToSet({}, cfg.FORBID_ATTR) : {};
        USE_PROFILES = 'USE_PROFILES' in cfg ? cfg.USE_PROFILES : false;
        ALLOW_ARIA_ATTR = cfg.ALLOW_ARIA_ATTR !== false; // Default true

        ALLOW_DATA_ATTR = cfg.ALLOW_DATA_ATTR !== false; // Default true

        ALLOW_UNKNOWN_PROTOCOLS = cfg.ALLOW_UNKNOWN_PROTOCOLS || false; // Default false

        SAFE_FOR_JQUERY = cfg.SAFE_FOR_JQUERY || false; // Default false

        SAFE_FOR_TEMPLATES = cfg.SAFE_FOR_TEMPLATES || false; // Default false

        WHOLE_DOCUMENT = cfg.WHOLE_DOCUMENT || false; // Default false

        RETURN_DOM = cfg.RETURN_DOM || false; // Default false

        RETURN_DOM_FRAGMENT = cfg.RETURN_DOM_FRAGMENT || false; // Default false

        RETURN_DOM_IMPORT = cfg.RETURN_DOM_IMPORT || false; // Default false

        FORCE_BODY = cfg.FORCE_BODY || false; // Default false

        SANITIZE_DOM = cfg.SANITIZE_DOM !== false; // Default true

        KEEP_CONTENT = cfg.KEEP_CONTENT !== false; // Default true

        IN_PLACE = cfg.IN_PLACE || false; // Default false

        IS_ALLOWED_URI$$1 = cfg.ALLOWED_URI_REGEXP || IS_ALLOWED_URI$$1;

        if (SAFE_FOR_TEMPLATES) {
          ALLOW_DATA_ATTR = false;
        }

        if (RETURN_DOM_FRAGMENT) {
          RETURN_DOM = true;
        }
        /* Parse profile info */


        if (USE_PROFILES) {
          ALLOWED_TAGS = addToSet({}, [].concat(_toConsumableArray(text)));
          ALLOWED_ATTR = [];

          if (USE_PROFILES.html === true) {
            addToSet(ALLOWED_TAGS, html);
            addToSet(ALLOWED_ATTR, html$1);
          }

          if (USE_PROFILES.svg === true) {
            addToSet(ALLOWED_TAGS, svg);
            addToSet(ALLOWED_ATTR, svg$1);
            addToSet(ALLOWED_ATTR, xml);
          }

          if (USE_PROFILES.svgFilters === true) {
            addToSet(ALLOWED_TAGS, svgFilters);
            addToSet(ALLOWED_ATTR, svg$1);
            addToSet(ALLOWED_ATTR, xml);
          }

          if (USE_PROFILES.mathMl === true) {
            addToSet(ALLOWED_TAGS, mathMl);
            addToSet(ALLOWED_ATTR, mathMl$1);
            addToSet(ALLOWED_ATTR, xml);
          }
        }
        /* Merge configuration parameters */


        if (cfg.ADD_TAGS) {
          if (ALLOWED_TAGS === DEFAULT_ALLOWED_TAGS) {
            ALLOWED_TAGS = clone(ALLOWED_TAGS);
          }

          addToSet(ALLOWED_TAGS, cfg.ADD_TAGS);
        }

        if (cfg.ADD_ATTR) {
          if (ALLOWED_ATTR === DEFAULT_ALLOWED_ATTR) {
            ALLOWED_ATTR = clone(ALLOWED_ATTR);
          }

          addToSet(ALLOWED_ATTR, cfg.ADD_ATTR);
        }

        if (cfg.ADD_URI_SAFE_ATTR) {
          addToSet(URI_SAFE_ATTRIBUTES, cfg.ADD_URI_SAFE_ATTR);
        }
        /* Add #text in case KEEP_CONTENT is set to true */


        if (KEEP_CONTENT) {
          ALLOWED_TAGS['#text'] = true;
        }
        /* Add html, head and body to ALLOWED_TAGS in case WHOLE_DOCUMENT is true */


        if (WHOLE_DOCUMENT) {
          addToSet(ALLOWED_TAGS, ['html', 'head', 'body']);
        }
        /* Add tbody to ALLOWED_TAGS in case tables are permitted, see #286 */


        if (ALLOWED_TAGS.table) {
          addToSet(ALLOWED_TAGS, ['tbody']);
        } // Prevent further manipulation of configuration.
        // Not available in IE8, Safari 5, etc.


        if (freeze) {
          freeze(cfg);
        }

        CONFIG = cfg;
      };
      /**
       * _forceRemove
       *
       * @param  {Node} node a DOM node
       */


      var _forceRemove = function _forceRemove(node) {
        DOMPurify.removed.push({
          element: node
        });

        try {
          node.parentNode.removeChild(node);
        } catch (error) {
          node.outerHTML = emptyHTML;
        }
      };
      /**
       * _removeAttribute
       *
       * @param  {String} name an Attribute name
       * @param  {Node} node a DOM node
       */


      var _removeAttribute = function _removeAttribute(name, node) {
        try {
          DOMPurify.removed.push({
            attribute: node.getAttributeNode(name),
            from: node
          });
        } catch (error) {
          DOMPurify.removed.push({
            attribute: null,
            from: node
          });
        }

        node.removeAttribute(name);
      };
      /**
       * _initDocument
       *
       * @param  {String} dirty a string of dirty markup
       * @return {Document} a DOM, filled with the dirty markup
       */


      var _initDocument = function _initDocument(dirty) {
        /* Create a HTML document */
        var doc = void 0;
        var leadingWhitespace = void 0;

        if (FORCE_BODY) {
          dirty = '<remove></remove>' + dirty;
        } else {
          /* If FORCE_BODY isn't used, leading whitespace needs to be preserved manually */
          var matches = dirty.match(/^[\s]+/);
          leadingWhitespace = matches && matches[0];

          if (leadingWhitespace) {
            dirty = dirty.slice(leadingWhitespace.length);
          }
        }
        /* Use DOMParser to workaround Firefox bug (see comment below) */


        if (useDOMParser) {
          try {
            doc = new DOMParser().parseFromString(dirty, 'text/html');
          } catch (error) {}
        }
        /* Remove title to fix a mXSS bug in older MS Edge */


        if (removeTitle) {
          addToSet(FORBID_TAGS, ['title']);
        }
        /* Otherwise use createHTMLDocument, because DOMParser is unsafe in
        Safari (see comment below) */


        if (!doc || !doc.documentElement) {
          doc = implementation.createHTMLDocument('');
          var _doc = doc,
              body = _doc.body;
          body.parentNode.removeChild(body.parentNode.firstElementChild);
          body.outerHTML = trustedTypesPolicy ? trustedTypesPolicy.createHTML(dirty) : dirty;
        }

        if (leadingWhitespace) {
          doc.body.insertBefore(document.createTextNode(leadingWhitespace), doc.body.childNodes[0] || null);
        }
        /* Work on whole document or just its body */


        return getElementsByTagName.call(doc, WHOLE_DOCUMENT ? 'html' : 'body')[0];
      }; // Firefox uses a different parser for innerHTML rather than
      // DOMParser (see https://bugzilla.mozilla.org/show_bug.cgi?id=1205631)
      // which means that you *must* use DOMParser, otherwise the output may
      // not be safe if used in a document.write context later.
      //
      // So we feature detect the Firefox bug and use the DOMParser if necessary.
      //
      // MS Edge, in older versions, is affected by an mXSS behavior. The second
      // check tests for the behavior and fixes it if necessary.


      if (DOMPurify.isSupported) {
        (function () {
          try {
            var doc = _initDocument('<svg><p><style><img src="</style><img src=x onerror=1//">');

            if (doc.querySelector('svg img')) {
              useDOMParser = true;
            }
          } catch (error) {}
        })();

        (function () {
          try {
            var doc = _initDocument('<x/><title>&lt;/title&gt;&lt;img&gt;');

            if (doc.querySelector('title').innerHTML.match(/<\/title/)) {
              removeTitle = true;
            }
          } catch (error) {}
        })();
      }
      /**
       * _createIterator
       *
       * @param  {Document} root document/fragment to create iterator for
       * @return {Iterator} iterator instance
       */


      var _createIterator = function _createIterator(root) {
        return createNodeIterator.call(root.ownerDocument || root, root, NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_COMMENT | NodeFilter.SHOW_TEXT, function () {
          return NodeFilter.FILTER_ACCEPT;
        }, false);
      };
      /**
       * _isClobbered
       *
       * @param  {Node} elm element to check for clobbering attacks
       * @return {Boolean} true if clobbered, false if safe
       */


      var _isClobbered = function _isClobbered(elm) {
        if (elm instanceof Text || elm instanceof Comment) {
          return false;
        }

        if (typeof elm.nodeName !== 'string' || typeof elm.textContent !== 'string' || typeof elm.removeChild !== 'function' || !(elm.attributes instanceof NamedNodeMap) || typeof elm.removeAttribute !== 'function' || typeof elm.setAttribute !== 'function') {
          return true;
        }

        return false;
      };
      /**
       * _isNode
       *
       * @param  {Node} obj object to check whether it's a DOM node
       * @return {Boolean} true is object is a DOM node
       */


      var _isNode = function _isNode(obj) {
        return (typeof Node === 'undefined' ? 'undefined' : _typeof(Node)) === 'object' ? obj instanceof Node : obj && (typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) === 'object' && typeof obj.nodeType === 'number' && typeof obj.nodeName === 'string';
      };
      /**
       * _executeHook
       * Execute user configurable hooks
       *
       * @param  {String} entryPoint  Name of the hook's entry point
       * @param  {Node} currentNode node to work on with the hook
       * @param  {Object} data additional hook parameters
       */


      var _executeHook = function _executeHook(entryPoint, currentNode, data) {
        if (!hooks[entryPoint]) {
          return;
        }

        hooks[entryPoint].forEach(function (hook) {
          hook.call(DOMPurify, currentNode, data, CONFIG);
        });
      };
      /**
       * _sanitizeElements
       *
       * @protect nodeName
       * @protect textContent
       * @protect removeChild
       *
       * @param   {Node} currentNode to check for permission to exist
       * @return  {Boolean} true if node was killed, false if left alive
       */
      // eslint-disable-next-line complexity


      var _sanitizeElements = function _sanitizeElements(currentNode) {
        var content = void 0;
        /* Execute a hook if present */

        _executeHook('beforeSanitizeElements', currentNode, null);
        /* Check if element is clobbered or can clobber */


        if (_isClobbered(currentNode)) {
          _forceRemove(currentNode);

          return true;
        }
        /* Now let's check the element's type and name */


        var tagName = currentNode.nodeName.toLowerCase();
        /* Execute a hook if present */

        _executeHook('uponSanitizeElement', currentNode, {
          tagName: tagName,
          allowedTags: ALLOWED_TAGS
        });
        /* Remove element if anything forbids its presence */


        if (!ALLOWED_TAGS[tagName] || FORBID_TAGS[tagName]) {
          /* Keep content except for black-listed elements */
          if (KEEP_CONTENT && !FORBID_CONTENTS[tagName] && typeof currentNode.insertAdjacentHTML === 'function') {
            try {
              var htmlToInsert = currentNode.innerHTML;
              currentNode.insertAdjacentHTML('AfterEnd', trustedTypesPolicy ? trustedTypesPolicy.createHTML(htmlToInsert) : htmlToInsert);
            } catch (error) {}
          }

          _forceRemove(currentNode);

          return true;
        }
        /* Remove in case a noscript/noembed XSS is suspected */


        if (tagName === 'noscript' && currentNode.innerHTML.match(/<\/noscript/i)) {
          _forceRemove(currentNode);

          return true;
        }

        if (tagName === 'noembed' && currentNode.innerHTML.match(/<\/noembed/i)) {
          _forceRemove(currentNode);

          return true;
        }
        /* Convert markup to cover jQuery behavior */


        if (SAFE_FOR_JQUERY && !currentNode.firstElementChild && (!currentNode.content || !currentNode.content.firstElementChild) && /</g.test(currentNode.textContent)) {
          DOMPurify.removed.push({
            element: currentNode.cloneNode()
          });

          if (currentNode.innerHTML) {
            currentNode.innerHTML = currentNode.innerHTML.replace(/</g, '&lt;');
          } else {
            currentNode.innerHTML = currentNode.textContent.replace(/</g, '&lt;');
          }
        }
        /* Sanitize element content to be template-safe */


        if (SAFE_FOR_TEMPLATES && currentNode.nodeType === 3) {
          /* Get the element's text content */
          content = currentNode.textContent;
          content = content.replace(MUSTACHE_EXPR$$1, ' ');
          content = content.replace(ERB_EXPR$$1, ' ');

          if (currentNode.textContent !== content) {
            DOMPurify.removed.push({
              element: currentNode.cloneNode()
            });
            currentNode.textContent = content;
          }
        }
        /* Execute a hook if present */


        _executeHook('afterSanitizeElements', currentNode, null);

        return false;
      };
      /**
       * _isValidAttribute
       *
       * @param  {string} lcTag Lowercase tag name of containing element.
       * @param  {string} lcName Lowercase attribute name.
       * @param  {string} value Attribute value.
       * @return {Boolean} Returns true if `value` is valid, otherwise false.
       */
      // eslint-disable-next-line complexity


      var _isValidAttribute = function _isValidAttribute(lcTag, lcName, value) {
        /* Make sure attribute cannot clobber */
        if (SANITIZE_DOM && (lcName === 'id' || lcName === 'name') && (value in document || value in formElement)) {
          return false;
        }
        /* Allow valid data-* attributes: At least one character after "-"
            (https://html.spec.whatwg.org/multipage/dom.html#embedding-custom-non-visible-data-with-the-data-*-attributes)
            XML-compatible (https://html.spec.whatwg.org/multipage/infrastructure.html#xml-compatible and http://www.w3.org/TR/xml/#d0e804)
            We don't need to check the value; it's always URI safe. */


        if (ALLOW_DATA_ATTR && DATA_ATTR$$1.test(lcName)) {// This attribute is safe
        } else if (ALLOW_ARIA_ATTR && ARIA_ATTR$$1.test(lcName)) {// This attribute is safe

          /* Otherwise, check the name is permitted */
        } else if (!ALLOWED_ATTR[lcName] || FORBID_ATTR[lcName]) {
          return false;
          /* Check value is safe. First, is attr inert? If so, is safe */
        } else if (URI_SAFE_ATTRIBUTES[lcName]) {// This attribute is safe

          /* Check no script, data or unknown possibly unsafe URI
            unless we know URI values are safe for that attribute */
        } else if (IS_ALLOWED_URI$$1.test(value.replace(ATTR_WHITESPACE$$1, ''))) {// This attribute is safe

          /* Keep image data URIs alive if src/xlink:href is allowed */

          /* Further prevent gadget XSS for dynamically built script tags */
        } else if ((lcName === 'src' || lcName === 'xlink:href') && lcTag !== 'script' && value.indexOf('data:') === 0 && DATA_URI_TAGS[lcTag]) {// This attribute is safe

          /* Allow unknown protocols: This provides support for links that
            are handled by protocol handlers which may be unknown ahead of
            time, e.g. fb:, spotify: */
        } else if (ALLOW_UNKNOWN_PROTOCOLS && !IS_SCRIPT_OR_DATA$$1.test(value.replace(ATTR_WHITESPACE$$1, ''))) {// This attribute is safe

          /* Check for binary attributes */
          // eslint-disable-next-line no-negated-condition
        } else if (!value) {// Binary attributes are safe at this point

          /* Anything else, presume unsafe, do not add it back */
        } else {
          return false;
        }

        return true;
      };
      /**
       * _sanitizeAttributes
       *
       * @protect attributes
       * @protect nodeName
       * @protect removeAttribute
       * @protect setAttribute
       *
       * @param  {Node} currentNode to sanitize
       */


      var _sanitizeAttributes = function _sanitizeAttributes(currentNode) {
        var attr = void 0;
        var value = void 0;
        var lcName = void 0;
        var idAttr = void 0;
        var l = void 0;
        /* Execute a hook if present */

        _executeHook('beforeSanitizeAttributes', currentNode, null);

        var attributes = currentNode.attributes;
        /* Check if we have attributes; if not we might have a text node */

        if (!attributes) {
          return;
        }

        var hookEvent = {
          attrName: '',
          attrValue: '',
          keepAttr: true,
          allowedAttributes: ALLOWED_ATTR
        };
        l = attributes.length;
        /* Go backwards over all attributes; safely remove bad ones */

        while (l--) {
          attr = attributes[l];
          var _attr = attr,
              name = _attr.name,
              namespaceURI = _attr.namespaceURI;
          value = attr.value.trim();
          lcName = name.toLowerCase();
          /* Execute a hook if present */

          hookEvent.attrName = lcName;
          hookEvent.attrValue = value;
          hookEvent.keepAttr = true;

          _executeHook('uponSanitizeAttribute', currentNode, hookEvent);

          value = hookEvent.attrValue;
          /* Remove attribute */
          // Safari (iOS + Mac), last tested v8.0.5, crashes if you try to
          // remove a "name" attribute from an <img> tag that has an "id"
          // attribute at the time.

          if (lcName === 'name' && currentNode.nodeName === 'IMG' && attributes.id) {
            idAttr = attributes.id;
            attributes = apply(arraySlice, attributes, []);

            _removeAttribute('id', currentNode);

            _removeAttribute(name, currentNode);

            if (attributes.indexOf(idAttr) > l) {
              currentNode.setAttribute('id', idAttr.value);
            }
          } else if ( // This works around a bug in Safari, where input[type=file]
          // cannot be dynamically set after type has been removed
          currentNode.nodeName === 'INPUT' && lcName === 'type' && value === 'file' && (ALLOWED_ATTR[lcName] || !FORBID_ATTR[lcName])) {
            continue;
          } else {
            // This avoids a crash in Safari v9.0 with double-ids.
            // The trick is to first set the id to be empty and then to
            // remove the attribute
            if (name === 'id') {
              currentNode.setAttribute(name, '');
            }

            _removeAttribute(name, currentNode);
          }
          /* Did the hooks approve of the attribute? */


          if (!hookEvent.keepAttr) {
            continue;
          }
          /* Sanitize attribute content to be template-safe */


          if (SAFE_FOR_TEMPLATES) {
            value = value.replace(MUSTACHE_EXPR$$1, ' ');
            value = value.replace(ERB_EXPR$$1, ' ');
          }
          /* Is `value` valid for this attribute? */


          var lcTag = currentNode.nodeName.toLowerCase();

          if (!_isValidAttribute(lcTag, lcName, value)) {
            continue;
          }
          /* Handle invalid data-* attribute set by try-catching it */


          try {
            if (namespaceURI) {
              currentNode.setAttributeNS(namespaceURI, name, value);
            } else {
              /* Fallback to setAttribute() for browser-unrecognized namespaces e.g. "x-schema". */
              currentNode.setAttribute(name, value);
            }

            DOMPurify.removed.pop();
          } catch (error) {}
        }
        /* Execute a hook if present */


        _executeHook('afterSanitizeAttributes', currentNode, null);
      };
      /**
       * _sanitizeShadowDOM
       *
       * @param  {DocumentFragment} fragment to iterate over recursively
       */


      var _sanitizeShadowDOM = function _sanitizeShadowDOM(fragment) {
        var shadowNode = void 0;

        var shadowIterator = _createIterator(fragment);
        /* Execute a hook if present */


        _executeHook('beforeSanitizeShadowDOM', fragment, null);

        while (shadowNode = shadowIterator.nextNode()) {
          /* Execute a hook if present */
          _executeHook('uponSanitizeShadowNode', shadowNode, null);
          /* Sanitize tags and elements */


          if (_sanitizeElements(shadowNode)) {
            continue;
          }
          /* Deep shadow DOM detected */


          if (shadowNode.content instanceof DocumentFragment) {
            _sanitizeShadowDOM(shadowNode.content);
          }
          /* Check attributes, sanitize if necessary */


          _sanitizeAttributes(shadowNode);
        }
        /* Execute a hook if present */


        _executeHook('afterSanitizeShadowDOM', fragment, null);
      };
      /**
       * Sanitize
       * Public method providing core sanitation functionality
       *
       * @param {String|Node} dirty string or DOM node
       * @param {Object} configuration object
       */
      // eslint-disable-next-line complexity


      DOMPurify.sanitize = function (dirty, cfg) {
        var body = void 0;
        var importedNode = void 0;
        var currentNode = void 0;
        var oldNode = void 0;
        var returnNode = void 0;
        /* Make sure we have a string to sanitize.
          DO NOT return early, as this will return the wrong type if
          the user has requested a DOM object rather than a string */

        if (!dirty) {
          dirty = '<!-->';
        }
        /* Stringify, in case dirty is an object */


        if (typeof dirty !== 'string' && !_isNode(dirty)) {
          // eslint-disable-next-line no-negated-condition
          if (typeof dirty.toString !== 'function') {
            throw new TypeError('toString is not a function');
          } else {
            dirty = dirty.toString();

            if (typeof dirty !== 'string') {
              throw new TypeError('dirty is not a string, aborting');
            }
          }
        }
        /* Check we can run. Otherwise fall back or ignore */


        if (!DOMPurify.isSupported) {
          if (_typeof(window.toStaticHTML) === 'object' || typeof window.toStaticHTML === 'function') {
            if (typeof dirty === 'string') {
              return window.toStaticHTML(dirty);
            }

            if (_isNode(dirty)) {
              return window.toStaticHTML(dirty.outerHTML);
            }
          }

          return dirty;
        }
        /* Assign config vars */


        if (!SET_CONFIG) {
          _parseConfig(cfg);
        }
        /* Clean up removed elements */


        DOMPurify.removed = [];

        if (IN_PLACE) {
          /* No special handling necessary for in-place sanitization */
        } else if (dirty instanceof Node) {
          /* If dirty is a DOM element, append to an empty document to avoid
             elements being stripped by the parser */
          body = _initDocument('<!-->');
          importedNode = body.ownerDocument.importNode(dirty, true);

          if (importedNode.nodeType === 1 && importedNode.nodeName === 'BODY') {
            /* Node is already a body, use as is */
            body = importedNode;
          } else {
            // eslint-disable-next-line unicorn/prefer-node-append
            body.appendChild(importedNode);
          }
        } else {
          /* Exit directly if we have nothing to do */
          if (!RETURN_DOM && !SAFE_FOR_TEMPLATES && !WHOLE_DOCUMENT && dirty.indexOf('<') === -1) {
            return trustedTypesPolicy ? trustedTypesPolicy.createHTML(dirty) : dirty;
          }
          /* Initialize the document to work on */


          body = _initDocument(dirty);
          /* Check we have a DOM node from the data */

          if (!body) {
            return RETURN_DOM ? null : emptyHTML;
          }
        }
        /* Remove first element node (ours) if FORCE_BODY is set */


        if (body && FORCE_BODY) {
          _forceRemove(body.firstChild);
        }
        /* Get node iterator */


        var nodeIterator = _createIterator(IN_PLACE ? dirty : body);
        /* Now start iterating over the created document */


        while (currentNode = nodeIterator.nextNode()) {
          /* Fix IE's strange behavior with manipulated textNodes #89 */
          if (currentNode.nodeType === 3 && currentNode === oldNode) {
            continue;
          }
          /* Sanitize tags and elements */


          if (_sanitizeElements(currentNode)) {
            continue;
          }
          /* Shadow DOM detected, sanitize it */


          if (currentNode.content instanceof DocumentFragment) {
            _sanitizeShadowDOM(currentNode.content);
          }
          /* Check attributes, sanitize if necessary */


          _sanitizeAttributes(currentNode);

          oldNode = currentNode;
        }

        oldNode = null;
        /* If we sanitized `dirty` in-place, return it. */

        if (IN_PLACE) {
          return dirty;
        }
        /* Return sanitized string or DOM */


        if (RETURN_DOM) {
          if (RETURN_DOM_FRAGMENT) {
            returnNode = createDocumentFragment.call(body.ownerDocument);

            while (body.firstChild) {
              // eslint-disable-next-line unicorn/prefer-node-append
              returnNode.appendChild(body.firstChild);
            }
          } else {
            returnNode = body;
          }

          if (RETURN_DOM_IMPORT) {
            /* AdoptNode() is not used because internal state is not reset
                   (e.g. the past names map of a HTMLFormElement), this is safe
                   in theory but we would rather not risk another attack vector.
                   The state that is cloned by importNode() is explicitly defined
                   by the specs. */
            returnNode = importNode.call(originalDocument, returnNode, true);
          }

          return returnNode;
        }

        var serializedHTML = WHOLE_DOCUMENT ? body.outerHTML : body.innerHTML;
        /* Sanitize final string template-safe */

        if (SAFE_FOR_TEMPLATES) {
          serializedHTML = serializedHTML.replace(MUSTACHE_EXPR$$1, ' ');
          serializedHTML = serializedHTML.replace(ERB_EXPR$$1, ' ');
        }

        return trustedTypesPolicy ? trustedTypesPolicy.createHTML(serializedHTML) : serializedHTML;
      };
      /**
       * Public method to set the configuration once
       * setConfig
       *
       * @param {Object} cfg configuration object
       */


      DOMPurify.setConfig = function (cfg) {
        _parseConfig(cfg);

        SET_CONFIG = true;
      };
      /**
       * Public method to remove the configuration
       * clearConfig
       *
       */


      DOMPurify.clearConfig = function () {
        CONFIG = null;
        SET_CONFIG = false;
      };
      /**
       * Public method to check if an attribute value is valid.
       * Uses last set config, if any. Otherwise, uses config defaults.
       * isValidAttribute
       *
       * @param  {string} tag Tag name of containing element.
       * @param  {string} attr Attribute name.
       * @param  {string} value Attribute value.
       * @return {Boolean} Returns true if `value` is valid. Otherwise, returns false.
       */


      DOMPurify.isValidAttribute = function (tag, attr, value) {
        /* Initialize shared config vars if necessary. */
        if (!CONFIG) {
          _parseConfig({});
        }

        var lcTag = tag.toLowerCase();
        var lcName = attr.toLowerCase();
        return _isValidAttribute(lcTag, lcName, value);
      };
      /**
       * AddHook
       * Public method to add DOMPurify hooks
       *
       * @param {String} entryPoint entry point for the hook to add
       * @param {Function} hookFunction function to execute
       */


      DOMPurify.addHook = function (entryPoint, hookFunction) {
        if (typeof hookFunction !== 'function') {
          return;
        }

        hooks[entryPoint] = hooks[entryPoint] || [];
        hooks[entryPoint].push(hookFunction);
      };
      /**
       * RemoveHook
       * Public method to remove a DOMPurify hook at a given entryPoint
       * (pops it from the stack of hooks if more are present)
       *
       * @param {String} entryPoint entry point for the hook to remove
       */


      DOMPurify.removeHook = function (entryPoint) {
        if (hooks[entryPoint]) {
          hooks[entryPoint].pop();
        }
      };
      /**
       * RemoveHooks
       * Public method to remove all DOMPurify hooks at a given entryPoint
       *
       * @param  {String} entryPoint entry point for the hooks to remove
       */


      DOMPurify.removeHooks = function (entryPoint) {
        if (hooks[entryPoint]) {
          hooks[entryPoint] = [];
        }
      };
      /**
       * RemoveAllHooks
       * Public method to remove all DOMPurify hooks
       *
       */


      DOMPurify.removeAllHooks = function () {
        hooks = {};
      };

      return DOMPurify;
    }

    var purify = createDOMPurify();
    return purify;
  });
  /***/

},
/* 42 */

/***/
function (module, exports, __webpack_require__) {
  /*
   *          __        ___
   *    _____/ /___  __/ (_)____
   *   / ___/ __/ / / / / / ___/
   *  (__  ) /_/ /_/ / / (__  )
   * /____/\__/\__, /_/_/____/
   *          /____/
   *
   * light - weight css preprocessor @licence MIT
   */
  (function (factory) {
    /* eslint-disable */
    true ? module['exports'] = factory(null) : undefined;
  })(
  /** @param {*=} options */
  function factory(options) {
    /* eslint-disable */
    'use strict';
    /**
     * Notes
     *
     * The ['<method name>'] pattern is used to support closure compiler
     * the jsdoc signatures are also used to the same effect
     *
     * ----
     *
     * int + int + int === n4 [faster]
     *
     * vs
     *
     * int === n1 && int === n2 && int === n3
     *
     * ----
     *
     * switch (int) { case ints...} [faster]
     *
     * vs
     *
     * if (int == 1 && int === 2 ...)
     *
     * ----
     *
     * The (first*n1 + second*n2 + third*n3) format used in the property parser
     * is a simple way to hash the sequence of characters
     * taking into account the index they occur in
     * since any number of 3 character sequences could produce duplicates.
     *
     * On the other hand sequences that are directly tied to the index of the character
     * resolve a far more accurate measure, it's also faster
     * to evaluate one condition in a switch statement
     * than three in an if statement regardless of the added math.
     *
     * This allows the vendor prefixer to be both small and fast.
     */

    var nullptn = /^\0+/g;
    /* matches leading null characters */

    var formatptn = /[\0\r\f]/g;
    /* matches new line, null and formfeed characters */

    var colonptn = /: */g;
    /* splits animation rules */

    var cursorptn = /zoo|gra/;
    /* assert cursor varient */

    var transformptn = /([,: ])(transform)/g;
    /* vendor prefix transform, older webkit */

    var animationptn = /,+\s*(?![^(]*[)])/g;
    /* splits multiple shorthand notation animations */

    var propertiesptn = / +\s*(?![^(]*[)])/g;
    /* animation properties */

    var elementptn = / *[\0] */g;
    /* selector elements */

    var selectorptn = /,\r+?/g;
    /* splits selectors */

    var andptn = /([\t\r\n ])*\f?&/g;
    /* match & */

    var escapeptn = /:global\(((?:[^\(\)\[\]]*|\[.*\]|\([^\(\)]*\))*)\)/g;
    /* matches :global(.*) */

    var invalidptn = /\W+/g;
    /* removes invalid characters from keyframes */

    var keyframeptn = /@(k\w+)\s*(\S*)\s*/;
    /* matches @keyframes $1 */

    var plcholdrptn = /::(place)/g;
    /* match ::placeholder varient */

    var readonlyptn = /:(read-only)/g;
    /* match :read-only varient */

    var beforeptn = /\s+(?=[{\];=:>])/g;
    /* matches \s before ] ; = : */

    var afterptn = /([[}=:>])\s+/g;
    /* matches \s after characters [ } = : */

    var tailptn = /(\{[^{]+?);(?=\})/g;
    /* matches tail semi-colons ;} */

    var whiteptn = /\s{2,}/g;
    /* matches repeating whitespace */

    var pseudoptn = /([^\(])(:+) */g;
    /* pseudo element */

    var writingptn = /[svh]\w+-[tblr]{2}/;
    /* match writing mode property values */

    var gradientptn = /([\w-]+t\()/g;
    /* match *gradient property */

    var supportsptn = /\(\s*(.*)\s*\)/g;
    /* match supports (groups) */

    var propertyptn = /([\s\S]*?);/g;
    /* match properties leading semicolon */

    var selfptn = /-self|flex-/g;
    /* match flex- and -self in align-self: flex-*; */

    var pseudofmt = /[^]*?(:[rp][el]a[\w-]+)[^]*/;
    /* extrats :readonly or :placholder from selector */

    var trimptn = /[ \t]+$/;
    /* match tail whitspace */

    var dimensionptn = /stretch|:\s*\w+\-(?:conte|avail)/;
    /* match max/min/fit-content, fill-available */

    var imgsrcptn = /([^-])(image-set\()/;
    /* vendors */

    var webkit = '-webkit-';
    var moz = '-moz-';
    var ms = '-ms-';
    /* character codes */

    var SEMICOLON = 59;
    /* ; */

    var CLOSEBRACES = 125;
    /* } */

    var OPENBRACES = 123;
    /* { */

    var OPENPARENTHESES = 40;
    /* ( */

    var CLOSEPARENTHESES = 41;
    /* ) */

    var OPENBRACKET = 91;
    /* [ */

    var CLOSEBRACKET = 93;
    /* ] */

    var NEWLINE = 10;
    /* \n */

    var CARRIAGE = 13;
    /* \r */

    var TAB = 9;
    /* \t */

    var AT = 64;
    /* @ */

    var SPACE = 32;
    /*   */

    var AND = 38;
    /* & */

    var DASH = 45;
    /* - */

    var UNDERSCORE = 95;
    /* _ */

    var STAR = 42;
    /* * */

    var COMMA = 44;
    /* , */

    var COLON = 58;
    /* : */

    var SINGLEQUOTE = 39;
    /* ' */

    var DOUBLEQUOTE = 34;
    /* " */

    var FOWARDSLASH = 47;
    /* / */

    var GREATERTHAN = 62;
    /* > */

    var PLUS = 43;
    /* + */

    var TILDE = 126;
    /* ~ */

    var NULL = 0;
    /* \0 */

    var FORMFEED = 12;
    /* \f */

    var VERTICALTAB = 11;
    /* \v */

    /* special identifiers */

    var KEYFRAME = 107;
    /* k */

    var MEDIA = 109;
    /* m */

    var SUPPORTS = 115;
    /* s */

    var PLACEHOLDER = 112;
    /* p */

    var READONLY = 111;
    /* o */

    var IMPORT = 105;
    /* <at>i */

    var CHARSET = 99;
    /* <at>c */

    var DOCUMENT = 100;
    /* <at>d */

    var PAGE = 112;
    /* <at>p */

    var column = 1;
    /* current column */

    var line = 1;
    /* current line numebr */

    var pattern = 0;
    /* :pattern */

    var cascade = 1;
    /* #id h1 h2 vs h1#id h2#id  */

    var prefix = 1;
    /* vendor prefix */

    var escape = 1;
    /* escape :global() pattern */

    var compress = 0;
    /* compress output */

    var semicolon = 0;
    /* no/semicolon option */

    var preserve = 0;
    /* preserve empty selectors */

    /* empty reference */

    var array = [];
    /* plugins */

    var plugins = [];
    var plugged = 0;
    var should = null;
    /* plugin context */

    var POSTS = -2;
    var PREPS = -1;
    var UNKWN = 0;
    var PROPS = 1;
    var BLCKS = 2;
    var ATRUL = 3;
    /* plugin newline context */

    var unkwn = 0;
    /* keyframe animation */

    var keyed = 1;
    var key = '';
    /* selector namespace */

    var nscopealt = '';
    var nscope = '';
    /**
     * Compile
     *
     * @param {Array<string>} parent
     * @param {Array<string>} current
     * @param {string} body
     * @param {number} id
     * @param {number} depth
     * @return {string}
     */

    function compile(parent, current, body, id, depth) {
      var bracket = 0;
      /* brackets [] */

      var comment = 0;
      /* comments /* // or /* */

      var parentheses = 0;
      /* functions () */

      var quote = 0;
      /* quotes '', "" */

      var first = 0;
      /* first character code */

      var second = 0;
      /* second character code */

      var code = 0;
      /* current character code */

      var tail = 0;
      /* previous character code */

      var trail = 0;
      /* character before previous code */

      var peak = 0;
      /* previous non-whitespace code */

      var counter = 0;
      /* count sequence termination */

      var context = 0;
      /* track current context */

      var atrule = 0;
      /* track @at-rule context */

      var pseudo = 0;
      /* track pseudo token index */

      var caret = 0;
      /* current character index */

      var format = 0;
      /* control character formating context */

      var insert = 0;
      /* auto semicolon insertion */

      var invert = 0;
      /* inverted selector pattern */

      var length = 0;
      /* generic length address */

      var eof = body.length;
      /* end of file(length) */

      var eol = eof - 1;
      /* end of file(characters) */

      var _char2 = '';
      /* current character */

      var chars = '';
      /* current buffer of characters */

      var child = '';
      /* next buffer of characters */

      var out = '';
      /* compiled body */

      var children = '';
      /* compiled children */

      var flat = '';
      /* compiled leafs */

      var selector;
      /* generic selector address */

      var result;
      /* generic address */
      // ...build body

      while (caret < eof) {
        code = body.charCodeAt(caret); // eof varient

        if (caret === eol) {
          // last character + noop context, add synthetic padding for noop context to terminate
          if (comment + quote + parentheses + bracket !== 0) {
            if (comment !== 0) {
              code = comment === FOWARDSLASH ? NEWLINE : FOWARDSLASH;
            }

            quote = parentheses = bracket = 0;
            eof++;
            eol++;
          }
        }

        if (comment + quote + parentheses + bracket === 0) {
          // eof varient
          if (caret === eol) {
            if (format > 0) {
              chars = chars.replace(formatptn, '');
            }

            if (chars.trim().length > 0) {
              switch (code) {
                case SPACE:
                case TAB:
                case SEMICOLON:
                case CARRIAGE:
                case NEWLINE:
                  {
                    break;
                  }

                default:
                  {
                    chars += body.charAt(caret);
                  }
              }

              code = SEMICOLON;
            }
          } // auto semicolon insertion


          if (insert === 1) {
            switch (code) {
              // false flags
              case OPENBRACES:
              case CLOSEBRACES:
              case SEMICOLON:
              case DOUBLEQUOTE:
              case SINGLEQUOTE:
              case OPENPARENTHESES:
              case CLOSEPARENTHESES:
              case COMMA:
                {
                  insert = 0;
                }
              // ignore

              case TAB:
              case CARRIAGE:
              case NEWLINE:
              case SPACE:
                {
                  break;
                }
              // valid

              default:
                {
                  insert = 0;
                  length = caret;
                  first = code;
                  caret--;
                  code = SEMICOLON;

                  while (length < eof) {
                    switch (body.charCodeAt(length++)) {
                      case NEWLINE:
                      case CARRIAGE:
                      case SEMICOLON:
                        {
                          ++caret;
                          code = first;
                          length = eof;
                          break;
                        }

                      case COLON:
                        {
                          if (format > 0) {
                            ++caret;
                            code = first;
                          }
                        }

                      case OPENBRACES:
                        {
                          length = eof;
                        }
                    }
                  }
                }
            }
          } // token varient


          switch (code) {
            case OPENBRACES:
              {
                chars = chars.trim();
                first = chars.charCodeAt(0);
                counter = 1;
                length = ++caret;

                while (caret < eof) {
                  switch (code = body.charCodeAt(caret)) {
                    case OPENBRACES:
                      {
                        counter++;
                        break;
                      }

                    case CLOSEBRACES:
                      {
                        counter--;
                        break;
                      }

                    case FOWARDSLASH:
                      {
                        switch (second = body.charCodeAt(caret + 1)) {
                          // /*, //
                          case STAR:
                          case FOWARDSLASH:
                            {
                              caret = delimited(second, caret, eol, body);
                            }
                        }

                        break;
                      }
                    // given "[" === 91 & "]" === 93 hence forth 91 + 1 + 1 === 93

                    case OPENBRACKET:
                      {
                        code++;
                      }
                    // given "(" === 40 & ")" === 41 hence forth 40 + 1 === 41

                    case OPENPARENTHESES:
                      {
                        code++;
                      }
                    // quote tail delimiter is identical to the head delimiter hence noop,
                    // fallthrough clauses have been shifted to the correct tail delimiter

                    case DOUBLEQUOTE:
                    case SINGLEQUOTE:
                      {
                        while (caret++ < eol) {
                          if (body.charCodeAt(caret) === code) {
                            break;
                          }
                        }
                      }
                  }

                  if (counter === 0) {
                    break;
                  }

                  caret++;
                }

                child = body.substring(length, caret);

                if (first === NULL) {
                  first = (chars = chars.replace(nullptn, '').trim()).charCodeAt(0);
                }

                switch (first) {
                  // @at-rule
                  case AT:
                    {
                      if (format > 0) {
                        chars = chars.replace(formatptn, '');
                      }

                      second = chars.charCodeAt(1);

                      switch (second) {
                        case DOCUMENT:
                        case MEDIA:
                        case SUPPORTS:
                        case DASH:
                          {
                            selector = current;
                            break;
                          }

                        default:
                          {
                            selector = array;
                          }
                      }

                      child = compile(current, selector, child, second, depth + 1);
                      length = child.length; // preserve empty @at-rule

                      if (preserve > 0 && length === 0) {
                        length = chars.length;
                      } // execute plugins, @at-rule context


                      if (plugged > 0) {
                        selector = select(array, chars, invert);
                        result = proxy(ATRUL, child, selector, current, line, column, length, second, depth, id);
                        chars = selector.join('');

                        if (result !== void 0) {
                          if ((length = (child = result.trim()).length) === 0) {
                            second = 0;
                            child = '';
                          }
                        }
                      }

                      if (length > 0) {
                        switch (second) {
                          case SUPPORTS:
                            {
                              chars = chars.replace(supportsptn, supports);
                            }

                          case DOCUMENT:
                          case MEDIA:
                          case DASH:
                            {
                              child = chars + '{' + child + '}';
                              break;
                            }

                          case KEYFRAME:
                            {
                              chars = chars.replace(keyframeptn, '$1 $2' + (keyed > 0 ? key : ''));
                              child = chars + '{' + child + '}';

                              if (prefix === 1 || prefix === 2 && vendor('@' + child, 3)) {
                                child = '@' + webkit + child + '@' + child;
                              } else {
                                child = '@' + child;
                              }

                              break;
                            }

                          default:
                            {
                              child = chars + child;

                              if (id === PAGE) {
                                child = (out += child, '');
                              }
                            }
                        }
                      } else {
                        child = '';
                      }

                      break;
                    }
                  // selector

                  default:
                    {
                      child = compile(current, select(current, chars, invert), child, id, depth + 1);
                    }
                }

                children += child; // reset

                context = 0;
                insert = 0;
                pseudo = 0;
                format = 0;
                invert = 0;
                atrule = 0;
                chars = '';
                child = '';
                code = body.charCodeAt(++caret);
                break;
              }

            case CLOSEBRACES:
            case SEMICOLON:
              {
                chars = (format > 0 ? chars.replace(formatptn, '') : chars).trim();

                if ((length = chars.length) > 1) {
                  // monkey-patch missing colon
                  if (pseudo === 0) {
                    first = chars.charCodeAt(0); // first character is a letter or dash, buffer has a space character

                    if (first === DASH || first > 96 && first < 123) {
                      length = (chars = chars.replace(' ', ':')).length;
                    }
                  } // execute plugins, property context


                  if (plugged > 0) {
                    if ((result = proxy(PROPS, chars, current, parent, line, column, out.length, id, depth, id)) !== void 0) {
                      if ((length = (chars = result.trim()).length) === 0) {
                        chars = '\0\0';
                      }
                    }
                  }

                  first = chars.charCodeAt(0);
                  second = chars.charCodeAt(1);

                  switch (first) {
                    case NULL:
                      {
                        break;
                      }

                    case AT:
                      {
                        if (second === IMPORT || second === CHARSET) {
                          flat += chars + body.charAt(caret);
                          break;
                        }
                      }

                    default:
                      {
                        if (chars.charCodeAt(length - 1) === COLON) {
                          break;
                        }

                        out += property(chars, first, second, chars.charCodeAt(2));
                      }
                  }
                } // reset


                context = 0;
                insert = 0;
                pseudo = 0;
                format = 0;
                invert = 0;
                chars = '';
                code = body.charCodeAt(++caret);
                break;
              }
          }
        } // parse characters


        switch (code) {
          case CARRIAGE:
          case NEWLINE:
            {
              // auto insert semicolon
              if (comment + quote + parentheses + bracket + semicolon === 0) {
                // valid non-whitespace characters that
                // may precede a newline
                switch (peak) {
                  case CLOSEPARENTHESES:
                  case SINGLEQUOTE:
                  case DOUBLEQUOTE:
                  case AT:
                  case TILDE:
                  case GREATERTHAN:
                  case STAR:
                  case PLUS:
                  case FOWARDSLASH:
                  case DASH:
                  case COLON:
                  case COMMA:
                  case SEMICOLON:
                  case OPENBRACES:
                  case CLOSEBRACES:
                    {
                      break;
                    }

                  default:
                    {
                      // current buffer has a colon
                      if (pseudo > 0) {
                        insert = 1;
                      }
                    }
                }
              } // terminate line comment


              if (comment === FOWARDSLASH) {
                comment = 0;
              } else if (cascade + context === 0 && id !== KEYFRAME && chars.length > 0) {
                format = 1;
                chars += '\0';
              } // execute plugins, newline context


              if (plugged * unkwn > 0) {
                proxy(UNKWN, chars, current, parent, line, column, out.length, id, depth, id);
              } // next line, reset column position


              column = 1;
              line++;
              break;
            }

          case SEMICOLON:
          case CLOSEBRACES:
            {
              if (comment + quote + parentheses + bracket === 0) {
                column++;
                break;
              }
            }

          default:
            {
              // increment column position
              column++; // current character

              _char2 = body.charAt(caret); // remove comments, escape functions, strings, attributes and prepare selectors

              switch (code) {
                case TAB:
                case SPACE:
                  {
                    if (quote + bracket + comment === 0) {
                      switch (tail) {
                        case COMMA:
                        case COLON:
                        case TAB:
                        case SPACE:
                          {
                            _char2 = '';
                            break;
                          }

                        default:
                          {
                            if (code !== SPACE) {
                              _char2 = ' ';
                            }
                          }
                      }
                    }

                    break;
                  }
                // escape breaking control characters

                case NULL:
                  {
                    _char2 = '\\0';
                    break;
                  }

                case FORMFEED:
                  {
                    _char2 = '\\f';
                    break;
                  }

                case VERTICALTAB:
                  {
                    _char2 = '\\v';
                    break;
                  }
                // &

                case AND:
                  {
                    // inverted selector pattern i.e html &
                    if (quote + comment + bracket === 0 && cascade > 0) {
                      invert = 1;
                      format = 1;
                      _char2 = '\f' + _char2;
                    }

                    break;
                  }
                // ::p<l>aceholder, l
                // :read-on<l>y, l

                case 108:
                  {
                    if (quote + comment + bracket + pattern === 0 && pseudo > 0) {
                      switch (caret - pseudo) {
                        // ::placeholder
                        case 2:
                          {
                            if (tail === PLACEHOLDER && body.charCodeAt(caret - 3) === COLON) {
                              pattern = tail;
                            }
                          }
                        // :read-only

                        case 8:
                          {
                            if (trail === READONLY) {
                              pattern = trail;
                            }
                          }
                      }
                    }

                    break;
                  }
                // :<pattern>

                case COLON:
                  {
                    if (quote + comment + bracket === 0) {
                      pseudo = caret;
                    }

                    break;
                  }
                // selectors

                case COMMA:
                  {
                    if (comment + parentheses + quote + bracket === 0) {
                      format = 1;
                      _char2 += '\r';
                    }

                    break;
                  }
                // quotes

                case DOUBLEQUOTE:
                case SINGLEQUOTE:
                  {
                    if (comment === 0) {
                      quote = quote === code ? 0 : quote === 0 ? code : quote;
                    }

                    break;
                  }
                // attributes

                case OPENBRACKET:
                  {
                    if (quote + comment + parentheses === 0) {
                      bracket++;
                    }

                    break;
                  }

                case CLOSEBRACKET:
                  {
                    if (quote + comment + parentheses === 0) {
                      bracket--;
                    }

                    break;
                  }
                // functions

                case CLOSEPARENTHESES:
                  {
                    if (quote + comment + bracket === 0) {
                      parentheses--;
                    }

                    break;
                  }

                case OPENPARENTHESES:
                  {
                    if (quote + comment + bracket === 0) {
                      if (context === 0) {
                        switch (tail * 2 + trail * 3) {
                          // :matches
                          case 533:
                            {
                              break;
                            }
                          // :global, :not, :nth-child etc...

                          default:
                            {
                              counter = 0;
                              context = 1;
                            }
                        }
                      }

                      parentheses++;
                    }

                    break;
                  }

                case AT:
                  {
                    if (comment + parentheses + quote + bracket + pseudo + atrule === 0) {
                      atrule = 1;
                    }

                    break;
                  }
                // block/line comments

                case STAR:
                case FOWARDSLASH:
                  {
                    if (quote + bracket + parentheses > 0) {
                      break;
                    }

                    switch (comment) {
                      // initialize line/block comment context
                      case 0:
                        {
                          switch (code * 2 + body.charCodeAt(caret + 1) * 3) {
                            // //
                            case 235:
                              {
                                comment = FOWARDSLASH;
                                break;
                              }
                            // /*

                            case 220:
                              {
                                length = caret;
                                comment = STAR;
                                break;
                              }
                          }

                          break;
                        }
                      // end block comment context

                      case STAR:
                        {
                          if (code === FOWARDSLASH && tail === STAR && length + 2 !== caret) {
                            // /*<!> ... */, !
                            if (body.charCodeAt(length + 2) === 33) {
                              out += body.substring(length, caret + 1);
                            }

                            _char2 = '';
                            comment = 0;
                          }
                        }
                    }
                  }
              } // ignore comment blocks


              if (comment === 0) {
                // aggressive isolation mode, divide each individual selector
                // including selectors in :not function but excluding selectors in :global function
                if (cascade + quote + bracket + atrule === 0 && id !== KEYFRAME && code !== SEMICOLON) {
                  switch (code) {
                    case COMMA:
                    case TILDE:
                    case GREATERTHAN:
                    case PLUS:
                    case CLOSEPARENTHESES:
                    case OPENPARENTHESES:
                      {
                        if (context === 0) {
                          // outside of an isolated context i.e nth-child(<...>)
                          switch (tail) {
                            case TAB:
                            case SPACE:
                            case NEWLINE:
                            case CARRIAGE:
                              {
                                _char2 = _char2 + '\0';
                                break;
                              }

                            default:
                              {
                                _char2 = '\0' + _char2 + (code === COMMA ? '' : '\0');
                              }
                          }

                          format = 1;
                        } else {
                          // within an isolated context, sleep untill it's terminated
                          switch (code) {
                            case OPENPARENTHESES:
                              {
                                // :globa<l>(
                                if (pseudo + 7 === caret && tail === 108) {
                                  pseudo = 0;
                                }

                                context = ++counter;
                                break;
                              }

                            case CLOSEPARENTHESES:
                              {
                                if ((context = --counter) === 0) {
                                  format = 1;
                                  _char2 += '\0';
                                }

                                break;
                              }
                          }
                        }

                        break;
                      }

                    case TAB:
                    case SPACE:
                      {
                        switch (tail) {
                          case NULL:
                          case OPENBRACES:
                          case CLOSEBRACES:
                          case SEMICOLON:
                          case COMMA:
                          case FORMFEED:
                          case TAB:
                          case SPACE:
                          case NEWLINE:
                          case CARRIAGE:
                            {
                              break;
                            }

                          default:
                            {
                              // ignore in isolated contexts
                              if (context === 0) {
                                format = 1;
                                _char2 += '\0';
                              }
                            }
                        }
                      }
                  }
                } // concat buffer of characters


                chars += _char2; // previous non-whitespace character code

                if (code !== SPACE && code !== TAB) {
                  peak = code;
                }
              }
            }
        } // tail character codes


        trail = tail;
        tail = code; // visit every character

        caret++;
      }

      length = out.length; // preserve empty selector

      if (preserve > 0) {
        if (length === 0 && children.length === 0 && current[0].length === 0 === false) {
          if (id !== MEDIA || current.length === 1 && (cascade > 0 ? nscopealt : nscope) === current[0]) {
            length = current.join(',').length + 2;
          }
        }
      }

      if (length > 0) {
        // cascade isolation mode?
        selector = cascade === 0 && id !== KEYFRAME ? isolate(current) : current; // execute plugins, block context

        if (plugged > 0) {
          result = proxy(BLCKS, out, selector, parent, line, column, length, id, depth, id);

          if (result !== void 0 && (out = result).length === 0) {
            return flat + out + children;
          }
        }

        out = selector.join(',') + '{' + out + '}';

        if (prefix * pattern !== 0) {
          if (prefix === 2 && !vendor(out, 2)) pattern = 0;

          switch (pattern) {
            // ::read-only
            case READONLY:
              {
                out = out.replace(readonlyptn, ':' + moz + '$1') + out;
                break;
              }
            // ::placeholder

            case PLACEHOLDER:
              {
                out = out.replace(plcholdrptn, '::' + webkit + 'input-$1') + out.replace(plcholdrptn, '::' + moz + '$1') + out.replace(plcholdrptn, ':' + ms + 'input-$1') + out;
                break;
              }
          }

          pattern = 0;
        }
      }

      return flat + out + children;
    }
    /**
     * Select
     *
     * @param {Array<string>} parent
     * @param {string} current
     * @param {number} invert
     * @return {Array<string>}
     */


    function select(parent, current, invert) {
      var selectors = current.trim().split(selectorptn);
      var out = selectors;
      var length = selectors.length;
      var l = parent.length;

      switch (l) {
        // 0-1 parent selectors
        case 0:
        case 1:
          {
            for (var i = 0, selector = l === 0 ? '' : parent[0] + ' '; i < length; ++i) {
              out[i] = scope(selector, out[i], invert, l).trim();
            }

            break;
          }
        // >2 parent selectors, nested

        default:
          {
            for (var i = 0, j = 0, out = []; i < length; ++i) {
              for (var k = 0; k < l; ++k) {
                out[j++] = scope(parent[k] + ' ', selectors[i], invert, l).trim();
              }
            }
          }
      }

      return out;
    }
    /**
     * Scope
     *
     * @param {string} parent
     * @param {string} current
     * @param {number} invert
     * @param {number} level
     * @return {string}
     */


    function scope(parent, current, invert, level) {
      var selector = current;
      var code = selector.charCodeAt(0); // trim leading whitespace

      if (code < 33) {
        code = (selector = selector.trim()).charCodeAt(0);
      }

      switch (code) {
        // &
        case AND:
          {
            switch (cascade + level) {
              case 0:
              case 1:
                {
                  if (parent.trim().length === 0) {
                    break;
                  }
                }

              default:
                {
                  return selector.replace(andptn, '$1' + parent.trim());
                }
            }

            break;
          }
        // :

        case COLON:
          {
            switch (selector.charCodeAt(1)) {
              // g in :global
              case 103:
                {
                  if (escape > 0 && cascade > 0) {
                    return selector.replace(escapeptn, '$1').replace(andptn, '$1' + nscope);
                  }

                  break;
                }

              default:
                {
                  // :hover
                  return parent.trim() + selector.replace(andptn, '$1' + parent.trim());
                }
            }
          }

        default:
          {
            // html &
            if (invert * cascade > 0 && selector.indexOf('\f') > 0) {
              return selector.replace(andptn, (parent.charCodeAt(0) === COLON ? '' : '$1') + parent.trim());
            }
          }
      }

      return parent + selector;
    }
    /**
     * Property
     *
     * @param {string} input
     * @param {number} first
     * @param {number} second
     * @param {number} third
     * @return {string}
     */


    function property(input, first, second, third) {
      var index = 0;
      var out = input + ';';
      var hash = first * 2 + second * 3 + third * 4;
      var cache; // animation: a, n, i characters

      if (hash === 944) {
        return animation(out);
      } else if (prefix === 0 || prefix === 2 && !vendor(out, 1)) {
        return out;
      } // vendor prefix


      switch (hash) {
        // text-decoration/text-size-adjust/text-shadow/text-align/text-transform: t, e, x
        case 1015:
          {
            // text-shadow/text-align/text-transform, a
            return out.charCodeAt(10) === 97 ? webkit + out + out : out;
          }
        // filter/fill f, i, l

        case 951:
          {
            // filter, t
            return out.charCodeAt(3) === 116 ? webkit + out + out : out;
          }
        // color/column, c, o, l

        case 963:
          {
            // column, n
            return out.charCodeAt(5) === 110 ? webkit + out + out : out;
          }
        // box-decoration-break, b, o, x

        case 1009:
          {
            if (out.charCodeAt(4) !== 100) {
              break;
            }
          }
        // mask, m, a, s
        // clip-path, c, l, i

        case 969:
        case 942:
          {
            return webkit + out + out;
          }
        // appearance: a, p, p

        case 978:
          {
            return webkit + out + moz + out + out;
          }
        // hyphens: h, y, p
        // user-select: u, s, e

        case 1019:
        case 983:
          {
            return webkit + out + moz + out + ms + out + out;
          }
        // background/backface-visibility, b, a, c

        case 883:
          {
            // backface-visibility, -
            if (out.charCodeAt(8) === DASH) {
              return webkit + out + out;
            } // image-set(...)


            if (out.indexOf('image-set(', 11) > 0) {
              return out.replace(imgsrcptn, '$1' + webkit + '$2') + out;
            }

            return out;
          }
        // flex: f, l, e

        case 932:
          {
            if (out.charCodeAt(4) === DASH) {
              switch (out.charCodeAt(5)) {
                // flex-grow, g
                case 103:
                  {
                    return webkit + 'box-' + out.replace('-grow', '') + webkit + out + ms + out.replace('grow', 'positive') + out;
                  }
                // flex-shrink, s

                case 115:
                  {
                    return webkit + out + ms + out.replace('shrink', 'negative') + out;
                  }
                // flex-basis, b

                case 98:
                  {
                    return webkit + out + ms + out.replace('basis', 'preferred-size') + out;
                  }
              }
            }

            return webkit + out + ms + out + out;
          }
        // order: o, r, d

        case 964:
          {
            return webkit + out + ms + 'flex' + '-' + out + out;
          }
        // justify-items/justify-content, j, u, s

        case 1023:
          {
            // justify-content, c
            if (out.charCodeAt(8) !== 99) {
              break;
            }

            cache = out.substring(out.indexOf(':', 15)).replace('flex-', '').replace('space-between', 'justify');
            return webkit + 'box-pack' + cache + webkit + out + ms + 'flex-pack' + cache + out;
          }
        // cursor, c, u, r

        case 1005:
          {
            return cursorptn.test(out) ? out.replace(colonptn, ':' + webkit) + out.replace(colonptn, ':' + moz) + out : out;
          }
        // writing-mode, w, r, i

        case 1000:
          {
            cache = out.substring(13).trim();
            index = cache.indexOf('-') + 1;

            switch (cache.charCodeAt(0) + cache.charCodeAt(index)) {
              // vertical-lr
              case 226:
                {
                  cache = out.replace(writingptn, 'tb');
                  break;
                }
              // vertical-rl

              case 232:
                {
                  cache = out.replace(writingptn, 'tb-rl');
                  break;
                }
              // horizontal-tb

              case 220:
                {
                  cache = out.replace(writingptn, 'lr');
                  break;
                }

              default:
                {
                  return out;
                }
            }

            return webkit + out + ms + cache + out;
          }
        // position: sticky

        case 1017:
          {
            if (out.indexOf('sticky', 9) === -1) {
              return out;
            }
          }
        // display(flex/inline-flex/inline-box): d, i, s

        case 975:
          {
            index = (out = input).length - 10;
            cache = (out.charCodeAt(index) === 33 ? out.substring(0, index) : out).substring(input.indexOf(':', 7) + 1).trim();

            switch (hash = cache.charCodeAt(0) + (cache.charCodeAt(7) | 0)) {
              // inline-
              case 203:
                {
                  // inline-box
                  if (cache.charCodeAt(8) < 111) {
                    break;
                  }
                }
              // inline-box/sticky

              case 115:
                {
                  out = out.replace(cache, webkit + cache) + ';' + out;
                  break;
                }
              // inline-flex
              // flex

              case 207:
              case 102:
                {
                  out = out.replace(cache, webkit + (hash > 102 ? 'inline-' : '') + 'box') + ';' + out.replace(cache, webkit + cache) + ';' + out.replace(cache, ms + cache + 'box') + ';' + out;
                }
            }

            return out + ';';
          }
        // align-items, align-center, align-self: a, l, i, -

        case 938:
          {
            if (out.charCodeAt(5) === DASH) {
              switch (out.charCodeAt(6)) {
                // align-items, i
                case 105:
                  {
                    cache = out.replace('-items', '');
                    return webkit + out + webkit + 'box-' + cache + ms + 'flex-' + cache + out;
                  }
                // align-self, s

                case 115:
                  {
                    return webkit + out + ms + 'flex-item-' + out.replace(selfptn, '') + out;
                  }
                // align-content

                default:
                  {
                    return webkit + out + ms + 'flex-line-pack' + out.replace('align-content', '').replace(selfptn, '') + out;
                  }
              }
            }

            break;
          }
        // min/max

        case 973:
        case 989:
          {
            // min-/max- height/width/block-size/inline-size
            if (out.charCodeAt(3) !== DASH || out.charCodeAt(4) === 122) {
              break;
            }
          }
        // height/width: min-content / width: max-content

        case 931:
        case 953:
          {
            if (dimensionptn.test(input) === true) {
              // stretch
              if ((cache = input.substring(input.indexOf(':') + 1)).charCodeAt(0) === 115) return property(input.replace('stretch', 'fill-available'), first, second, third).replace(':fill-available', ':stretch');else return out.replace(cache, webkit + cache) + out.replace(cache, moz + cache.replace('fill-', '')) + out;
            }

            break;
          }
        // transform, transition: t, r, a

        case 962:
          {
            out = webkit + out + (out.charCodeAt(5) === 102 ? ms + out : '') + out; // transitions

            if (second + third === 211 && out.charCodeAt(13) === 105 && out.indexOf('transform', 10) > 0) {
              return out.substring(0, out.indexOf(';', 27) + 1).replace(transformptn, '$1' + webkit + '$2') + out;
            }

            break;
          }
      }

      return out;
    }
    /**
     * Vendor
     *
     * @param {string} content
     * @param {number} context
     * @return {boolean}
     */


    function vendor(content, context) {
      var index = content.indexOf(context === 1 ? ':' : '{');
      var key = content.substring(0, context !== 3 ? index : 10);
      var value = content.substring(index + 1, content.length - 1);
      return should(context !== 2 ? key : key.replace(pseudofmt, '$1'), value, context);
    }
    /**
     * Supports
     *
     * @param {string} match
     * @param {string} group
     * @return {string}
     */


    function supports(match, group) {
      var out = property(group, group.charCodeAt(0), group.charCodeAt(1), group.charCodeAt(2));
      return out !== group + ';' ? out.replace(propertyptn, ' or ($1)').substring(4) : '(' + group + ')';
    }
    /**
     * Animation
     *
     * @param {string} input
     * @return {string}
     */


    function animation(input) {
      var length = input.length;
      var index = input.indexOf(':', 9) + 1;
      var declare = input.substring(0, index).trim();
      var out = input.substring(index, length - 1).trim();

      switch (input.charCodeAt(9) * keyed) {
        case 0:
          {
            break;
          }
        // animation-*, -

        case DASH:
          {
            // animation-name, n
            if (input.charCodeAt(10) !== 110) {
              break;
            }
          }
        // animation/animation-name

        default:
          {
            // split in case of multiple animations
            var list = out.split((out = '', animationptn));

            for (var i = 0, index = 0, length = list.length; i < length; index = 0, ++i) {
              var value = list[i];
              var items = value.split(propertiesptn);

              while (value = items[index]) {
                var peak = value.charCodeAt(0);

                if (keyed === 1 && ( // letters
                peak > AT && peak < 90 || peak > 96 && peak < 123 || peak === UNDERSCORE || // dash but not in sequence i.e --
                peak === DASH && value.charCodeAt(1) !== DASH)) {
                  // not a number/function
                  switch (isNaN(parseFloat(value)) + (value.indexOf('(') !== -1)) {
                    case 1:
                      {
                        switch (value) {
                          // not a valid reserved keyword
                          case 'infinite':
                          case 'alternate':
                          case 'backwards':
                          case 'running':
                          case 'normal':
                          case 'forwards':
                          case 'both':
                          case 'none':
                          case 'linear':
                          case 'ease':
                          case 'ease-in':
                          case 'ease-out':
                          case 'ease-in-out':
                          case 'paused':
                          case 'reverse':
                          case 'alternate-reverse':
                          case 'inherit':
                          case 'initial':
                          case 'unset':
                          case 'step-start':
                          case 'step-end':
                            {
                              break;
                            }

                          default:
                            {
                              value += key;
                            }
                        }
                      }
                  }
                }

                items[index++] = value;
              }

              out += (i === 0 ? '' : ',') + items.join(' ');
            }
          }
      }

      out = declare + out + ';';
      if (prefix === 1 || prefix === 2 && vendor(out, 1)) return webkit + out + out;
      return out;
    }
    /**
     * Isolate
     *
     * @param {Array<string>} current
     */


    function isolate(current) {
      for (var i = 0, length = current.length, selector = Array(length), padding, element; i < length; ++i) {
        // split individual elements in a selector i.e h1 h2 === [h1, h2]
        var elements = current[i].split(elementptn);
        var out = '';

        for (var j = 0, size = 0, tail = 0, code = 0, l = elements.length; j < l; ++j) {
          // empty element
          if ((size = (element = elements[j]).length) === 0 && l > 1) {
            continue;
          }

          tail = out.charCodeAt(out.length - 1);
          code = element.charCodeAt(0);
          padding = '';

          if (j !== 0) {
            // determine if we need padding
            switch (tail) {
              case STAR:
              case TILDE:
              case GREATERTHAN:
              case PLUS:
              case SPACE:
              case OPENPARENTHESES:
                {
                  break;
                }

              default:
                {
                  padding = ' ';
                }
            }
          }

          switch (code) {
            case AND:
              {
                element = padding + nscopealt;
              }

            case TILDE:
            case GREATERTHAN:
            case PLUS:
            case SPACE:
            case CLOSEPARENTHESES:
            case OPENPARENTHESES:
              {
                break;
              }

            case OPENBRACKET:
              {
                element = padding + element + nscopealt;
                break;
              }

            case COLON:
              {
                switch (element.charCodeAt(1) * 2 + element.charCodeAt(2) * 3) {
                  // :global
                  case 530:
                    {
                      if (escape > 0) {
                        element = padding + element.substring(8, size - 1);
                        break;
                      }
                    }
                  // :hover, :nth-child(), ...

                  default:
                    {
                      if (j < 1 || elements[j - 1].length < 1) {
                        element = padding + nscopealt + element;
                      }
                    }
                }

                break;
              }

            case COMMA:
              {
                padding = '';
              }

            default:
              {
                if (size > 1 && element.indexOf(':') > 0) {
                  element = padding + element.replace(pseudoptn, '$1' + nscopealt + '$2');
                } else {
                  element = padding + element + nscopealt;
                }
              }
          }

          out += element;
        }

        selector[i] = out.replace(formatptn, '').trim();
      }

      return selector;
    }
    /**
     * Proxy
     *
     * @param {number} context
     * @param {string} content
     * @param {Array<string>} selectors
     * @param {Array<string>} parents
     * @param {number} line
     * @param {number} column
     * @param {number} length
     * @param {number} id
     * @param {number} depth
     * @param {number} at
     * @return {(string|void|*)}
     */


    function proxy(context, content, selectors, parents, line, column, length, id, depth, at) {
      for (var i = 0, out = content, next; i < plugged; ++i) {
        switch (next = plugins[i].call(stylis, context, out, selectors, parents, line, column, length, id, depth, at)) {
          case void 0:
          case false:
          case true:
          case null:
            {
              break;
            }

          default:
            {
              out = next;
            }
        }
      }

      if (out !== content) {
        return out;
      }
    }
    /**
     * @param {number} code
     * @param {number} index
     * @param {number} length
     * @param {string} body
     * @return {number}
     */


    function delimited(code, index, length, body) {
      for (var i = index + 1; i < length; ++i) {
        switch (body.charCodeAt(i)) {
          // /*
          case FOWARDSLASH:
            {
              if (code === STAR) {
                if (body.charCodeAt(i - 1) === STAR && index + 2 !== i) {
                  return i + 1;
                }
              }

              break;
            }
          // //

          case NEWLINE:
            {
              if (code === FOWARDSLASH) {
                return i + 1;
              }
            }
        }
      }

      return i;
    }
    /**
     * @param {number} type
     * @param {number} index
     * @param {number} length
     * @param {number} find
     * @param {string} body
     * @return {number}
     */


    function match(type, index, length, body) {
      for (var i = index + 1; i < length; ++i) {
        switch (body.charCodeAt(i)) {
          case type:
            {
              return i;
            }
        }
      }

      return i;
    }
    /**
     * Minify
     *
     * @param {(string|*)} output
     * @return {string}
     */


    function minify(output) {
      return output.replace(formatptn, '').replace(beforeptn, '').replace(afterptn, '$1').replace(tailptn, '$1').replace(whiteptn, ' ');
    }
    /**
     * Use
     *
     * @param {(Array<function(...?)>|function(...?)|number|void)?} plugin
     */


    function use(plugin) {
      switch (plugin) {
        case void 0:
        case null:
          {
            plugged = plugins.length = 0;
            break;
          }

        default:
          {
            if (typeof plugin === 'function') {
              plugins[plugged++] = plugin;
            } else if (_typeof2(plugin) === 'object') {
              for (var i = 0, length = plugin.length; i < length; ++i) {
                use(plugin[i]);
              }
            } else {
              unkwn = !!plugin | 0;
            }
          }
      }

      return use;
    }
    /**
     * Set
     *
     * @param {*} options
     */


    function set(options) {
      for (var name in options) {
        var value = options[name];

        switch (name) {
          case 'keyframe':
            keyed = value | 0;
            break;

          case 'global':
            escape = value | 0;
            break;

          case 'cascade':
            cascade = value | 0;
            break;

          case 'compress':
            compress = value | 0;
            break;

          case 'semicolon':
            semicolon = value | 0;
            break;

          case 'preserve':
            preserve = value | 0;
            break;

          case 'prefix':
            should = null;

            if (!value) {
              prefix = 0;
            } else if (typeof value !== 'function') {
              prefix = 1;
            } else {
              prefix = 2;
              should = value;
            }

        }
      }

      return set;
    }
    /**
     * Stylis
     *
     * @param {string} selector
     * @param {string} input
     * @return {*}
     */


    function stylis(selector, input) {
      if (this !== void 0 && this.constructor === stylis) {
        return factory(selector);
      } // setup


      var ns = selector;
      var code = ns.charCodeAt(0); // trim leading whitespace

      if (code < 33) {
        code = (ns = ns.trim()).charCodeAt(0);
      } // keyframe/animation namespace


      if (keyed > 0) {
        key = ns.replace(invalidptn, code === OPENBRACKET ? '' : '-');
      } // reset, used to assert if a plugin is moneky-patching the return value


      code = 1; // cascade/isolate

      if (cascade === 1) {
        nscope = ns;
      } else {
        nscopealt = ns;
      }

      var selectors = [nscope];
      var result; // execute plugins, pre-process context

      if (plugged > 0) {
        result = proxy(PREPS, input, selectors, selectors, line, column, 0, 0, 0, 0);

        if (result !== void 0 && typeof result === 'string') {
          input = result;
        }
      } // build


      var output = compile(array, selectors, input, 0, 0); // execute plugins, post-process context

      if (plugged > 0) {
        result = proxy(POSTS, output, selectors, selectors, line, column, output.length, 0, 0, 0); // bypass minification

        if (result !== void 0 && typeof (output = result) !== 'string') {
          code = 0;
        }
      } // reset


      key = '';
      nscope = '';
      nscopealt = '';
      pattern = 0;
      line = 1;
      column = 1;
      return compress * code === 0 ? output : minify(output);
    }

    stylis['use'] = use;
    stylis['set'] = set;

    if (options !== void 0) {
      set(options);
    }

    return stylis;
  });
  /***/

},
/* 43 */

/***/
function (module, __webpack_exports__, __webpack_require__) {
  ;

  __webpack_require__.r(__webpack_exports__);
  /* harmony export (binding) */


  __webpack_require__.d(__webpack_exports__, "CSS", function () {
    return CSS;
  });
  /* harmony import */


  var _Utilities_helpers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(4);
  /* harmony import */


  var _Utilities_Is__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(6);
  /* harmony import */


  var _Keyframes__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(44);
  /* harmony import */


  var _Form_Node__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(35);
  /* harmony import */


  var _Utilities_interpolationStation__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(45);
  /* harmony import */


  var _Utilities_alphaStringFromHash__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(46);
  /* harmony import */


  var _Utilities_murmurHash__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(47);
  /* harmony import */


  var stylis__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(42);
  /* harmony import */


  var stylis__WEBPACK_IMPORTED_MODULE_7___default =
  /*#__PURE__*/
  __webpack_require__.n(stylis__WEBPACK_IMPORTED_MODULE_7__);
  /* harmony import */


  var _Utilities_stylisDirectChild__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(48);
  /* harmony import */


  var css_tree__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(49);
  /* harmony import */


  var css_tree__WEBPACK_IMPORTED_MODULE_9___default =
  /*#__PURE__*/
  __webpack_require__.n(css_tree__WEBPACK_IMPORTED_MODULE_9__);

  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  function _defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    return Constructor;
  }

  function _defineProperty(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }

    return obj;
  }
  /*
  ** CSS.js
  **
  ** CSS.js performs CSS functionality within the flare library..
  **
  ** Eric James Foster, Fostware LLC, MIT License.
  ***/
  //OPTIMIZE: Rework process function so that there aren't so many checks for Is.interpolated()...
  // Get helper funcs...
  // Get type validation lib...
  // Get Keyframes class....
  // Get Node class...
  // Grab tagged template literal interpolation code...
  // Grab hash to string converter...
  // Get murmurhash...
  // Get stylis...
  // Get direct child...
  // Get CSS parser...


  window.log = _Utilities_helpers__WEBPACK_IMPORTED_MODULE_0__["log"];
  window.dir = console.dir; // Stylis configuration options...

  stylis__WEBPACK_IMPORTED_MODULE_7___default.a.set({
    global: false,
    cascade: true,
    keyframe: false,
    prefix: true,
    compress: false,
    semicolon: false
  });

  var CSS =
  /*#__PURE__*/
  function () {
    function CSS() {
      _classCallCheck(this, CSS);
    }

    _createClass(CSS, null, [{
      key: "assume",
      // A set of configuration options or assumptions. This object will be combined with the
      // assumptions of other classes when options are set...
      value: function assume(userAssumptions) {
        this._assumptions = _Form_Node__WEBPACK_IMPORTED_MODULE_3__["Node"].assume(_Utilities_helpers__WEBPACK_IMPORTED_MODULE_0__["combineObjects"](this._assumptions, userAssumptions));
        return this._assumptions;
      } // A static class property for holding an extended element's parent props....

    }, {
      key: "_createNewStyleSheet",
      // Class method for creating, appending and returning a new style sheet...
      value: function _createNewStyleSheet() {
        // Create style tag..
        var style = document.createElement('style'); // Append a textNode to it. Apparently, this is a webkit hack? More research needed...

        style.appendChild(document.createTextNode("")); // Append style tag to the head of the current doc's dom...

        document.head.appendChild(style); //

        return style.sheet;
      } //DEPRECATED: Not needed for now....
      // Internal Class method for dynamically inserting css rules into a given sheet

    }, {
      key: "_insertCSS",
      value: function _insertCSS(sheet, selector, rules) {
        var index = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;

        if ('insertRule' in sheet) {
          if (index) {
            // Use the sheet object method insertRule if available, otherwise, use addRule....
            sheet.insertRule("".concat(selector, " { ").concat(rules, " }"), index);
          } else {
            sheet.insertRule("".concat(selector, " { ").concat(rules, " }"));
          }
        } else if ('addRule' in sheet) {
          sheet.addRule(selector, rules, 1);
        }
      }
      /* A public static method for parsing a css literal, and splitting it into an
      array of separate rules, for inserting using the sheet.inserRule() method. Using
      the `css-tree` css parser/generator here....*/

    }, {
      key: "separateStyleRules",
      value: function separateStyleRules(cssLiteral) {
        /* Declare an array for our separated rules, an @rule flag, and also,
        generate our ast css tree...*/
        var rules = [],
            atRule = false,
            // AST tree...
        ast = css_tree__WEBPACK_IMPORTED_MODULE_9___default.a.parse(cssLiteral, {
          // Log parsing errors...
          onParseError: function onParseError(e) {
            log(e.formattedMessage, ['white', 'red']);
          }
        }); // Walk the css ast tree, stopping at rule nodes to regenerate and add to an array...

        css_tree__WEBPACK_IMPORTED_MODULE_9___default.a.walk(ast, {
          enter: function enter(node) {
            // log('#####################################-CSS AST NODE-########################################', ['yellow', 'red']);// log(node.type, 'orange')
            // If the node type is of Rule or @rule, meaning @media etc., ......
            if (node.type === 'Rule' || node.type === 'Atrule') {
              // Regenerate valid css from the rule...
              var rule = css_tree__WEBPACK_IMPORTED_MODULE_9___default.a.generate(node);
              /* If the atRule flag is still false and if the regen'd rule doesn't equal a
              possibly set atRule css string, ......*/

              if (!!!atRule && rule !== atRule) {
                // And if the node type is `Atrule`....
                if (node.type === 'Atrule') {
                  // Set the `atRule` flag to the regen'd @Rule block, including selectors....
                  atRule = css_tree__WEBPACK_IMPORTED_MODULE_9___default.a.generate(node.block.children.head.data); // log(cssTree.generate(node.block.children.head.data))
                } // Push the regen'd rule to the rules array....


                rules.push(rule);
              }
            }
          }
        }); // Return the array of rules...

        return rules;
      } // An internal static class method for creating usable css from a tagged template literal....

    }, {
      key: "_createCSS",
      value: function _createCSS(ttlObj, selector) {
        var props = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
        var css;
        /* If we are working on an extended component, execute interpolation functions,
        bring in the parent's styles, and finally, process the resulting css with 'stylis'...
        */
        // Is this an extended component? ....

        css = ttlObj.extended ?
        /* If so, go ahead and execute the interpolation functions with superProps, ...
        Also check if we have interpolations in the child component, and if so, execute them and
        combine the resulting css blocks, and process with Stylis.
         */
        stylis__WEBPACK_IMPORTED_MODULE_7___default()(selector, "".concat(Object(_Utilities_interpolationStation__WEBPACK_IMPORTED_MODULE_4__["default"])(ttlObj["super"], CSS._superProps[ttlObj.superId][1]), "\n         ").concat(Object(_Utilities_interpolationStation__WEBPACK_IMPORTED_MODULE_4__["default"])(ttlObj.array, props)))
        /* If not.......*/
        :
        /* If not, combine the resulting
        parent code block and with the untouched child block, and process with Stylis...
        */
        stylis__WEBPACK_IMPORTED_MODULE_7___default()(selector, // Execute interpolations, with props, process with Stylis ....*/
        Object(_Utilities_interpolationStation__WEBPACK_IMPORTED_MODULE_4__["default"])(ttlObj.array, props)); // if (ttlObj.extended) {
        //   log('X Styles', 'tomato')
        //   log(css, 'tomato')
        // }
        // Return css....

        return css;
      } // A static method for processing css with stylis...

    }, {
      key: "processStyles",
      value: function processStyles(tempLit, selector) {
        // Weave in interpolations, process with stylis....
        return stylis__WEBPACK_IMPORTED_MODULE_7___default()(selector, Object(_Utilities_interpolationStation__WEBPACK_IMPORTED_MODULE_4__["default"])(tempLit));
      }
      /* A private method for appending a CSS rule or an array of CSS rules to the default stylesheet,
      one by one.*/

    }, {
      key: "_insertRules",
      value: function _insertRules(rules) {
        var _this = this;

        var css; //

        if (_Utilities_Is__WEBPACK_IMPORTED_MODULE_1__["Is"].array(rules)) {
          rules.forEach(function (rule) {
            if (_this._assumptions.directChildNesting) {
              css = Object(_Utilities_stylisDirectChild__WEBPACK_IMPORTED_MODULE_8__["default"])(rule);
            } else {
              css = rule;
            }
            /* Adding a right arrow ">", between parent and child selectors so that styles
            may be overridden down the DOM tree... */


            CSS._styleSheet = css;
            /* The _styleSheet setter will create a new sheet and append to a new style tag
            if necessary, then insert the given css..*/
          });
        } else {
          if (this._assumptions.directChildNesting) {
            css = Object(_Utilities_stylisDirectChild__WEBPACK_IMPORTED_MODULE_8__["default"])(rules);
          } else {
            css = rules;
          } // Insert rule..


          CSS._styleSheet = css;
        }
      } // A Public method for inserting global styles into the stylesheet...

    }, {
      key: "insertGlobal",
      value: function insertGlobal(obj) {
        var css = CSS._createCSS(obj, ' '); // Separate and insert rules...


        CSS._insertRules(this.separateStyleRules(css));
      } // An internal static method for first, creating a 10 digit hash from a string of
      // css, then a 7 digit alphabetical string from the hash....

    }, {
      key: "_createKeyframesName",
      value: function _createKeyframesName(array) {
        // Create string from template array...
        var string = array[0].join('').replace(/\s|\n/g, ''); // Create and return unique id...

        return Object(_Utilities_alphaStringFromHash__WEBPACK_IMPORTED_MODULE_5__["default"])(Object(_Utilities_murmurHash__WEBPACK_IMPORTED_MODULE_6__["default"])(string));
      }
      /* an instance constructor for the keyframes class.... Returns the instance and
      inserts the rules into the stylesheet...*/

    }, {
      key: "keyframes",
      value: function keyframes(obj) {
        // Create a css string from the objects array... and remove whitespace...
        var css,
            // Create hash from string, and then a name from the hash....
        name = CSS._createKeyframesName(obj.array),
            // Create some usable css ...
        object = {};

        object.selector = "@keyframes ".concat(name);
        object.code = obj.array.join(''); // Use the computed keyframes property to generate our animation code...

        CSS._keyframesCSS = object; // Insert the rules...

        css = CSS._keyframesCSS;

        CSS._insertRules(css); // Return a keframes instance....


        return new _Keyframes__WEBPACK_IMPORTED_MODULE_2__["Keyframes"](name, css);
      }
      /* Class method dealing with adding styles to the component. If a tag
       is present in the arguments, the style is appended to the head of the doc,
      otherwise, it is appended to the shadow root...down the line....*/

    }, {
      key: "addStyles",
      value: function addStyles(appendStyle, cTag, eTag, props, tagTempLit) {
        // Declare vars...
        var sheet,
            selector = "[flareid=".concat(props.flareId, "]"),
            styleTag = eTag === 'div' ? selector : "".concat(selector, " ").concat(eTag),
            css; // If we are not appending style to a shadow root...

        if (appendStyle) {
          // Process the css...
          css = CSS._createCSS(tagTempLit, styleTag, props); // Split rules into an array. Insert into style sheet...

          CSS._insertRules(this.separateStyleRules(css));
        } else {
          css = eTag === 'div' ? CSS._createCSS(tagTempLit, ':host', props) : CSS._createCSS(tagTempLit, ":host > ".concat(eTag), props); // Return function that returns style related html...

          return function () {
            return x("style", null, css);
          };
        }
      }
    }, {
      key: "_keyframesCSS",
      // A getter for the keyframes template...
      get: function get() {
        return CSS._template;
      } // A setter for the keyframes template...
      ,
      set: function set(obj) {
        CSS._template = "".concat(obj.selector, " {\n      ").concat(obj.code, "\n    }");
      } // A property to hold the default stylesheet of the app...

    }, {
      key: "_styleSheet",
      // A getter for _sheet...
      get: function get() {
        // return the sheet!
        return CSS._sheet;
      } // A setter for _sheet... Setting sheet appends a CSS rule to it....
      ,
      set: function set(rule) {
        // If there is no sheet, create one...
        if (!CSS._sheet) {
          CSS._sheet = CSS._createNewStyleSheet();
        } // Insert given rule into stylesheet...


        CSS._sheet.insertRule(rule);
      }
    }]);

    return CSS;
  }();

  _defineProperty(CSS, "_assumptions", {
    directChildNesting: false // A public helper method for setting Flare assumptions, config options...

  });

  _defineProperty(CSS, "_superProps", {});

  _defineProperty(CSS, "_template", "");

  _defineProperty(CSS, "_sheet", null);
  /***/

},
/* 44 */

/***/
function (module, __webpack_exports__, __webpack_require__) {
  ;

  __webpack_require__.r(__webpack_exports__);
  /* harmony export (binding) */


  __webpack_require__.d(__webpack_exports__, "Keyframes", function () {
    return Keyframes;
  });

  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  function _defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    return Constructor;
  }

  function _defineProperty(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }

    return obj;
  }
  /*
  ** Keyframes.js
  **
  ** Keyframes.js holds the Keyframes class, and implements @keyframe functionality
  ** in the component styling branch of Valence, Flare...
  **
  ** Eric James Foster, Fostware LLC, MIT License.
  ***/


  var Keyframes =
  /*#__PURE__*/
  function () {
    // The name of the animation...
    // CSS Rules...
    // Instance id...
    // Instance constructor...
    function Keyframes(name, css) {
      _classCallCheck(this, Keyframes);

      _defineProperty(this, "animationName", '');

      _defineProperty(this, "rules", '');

      _defineProperty(this, "id", '');

      this.rules = css;
      this.animationName = name;
      this.id = "flare-keyframes-".concat(name);
    } // Getter for 'name'..


    _createClass(Keyframes, [{
      key: "name",
      get: function get() {
        return this.animationName;
      }
    }]);

    return Keyframes;
  }();
  /***/

},
/* 45 */

/***/
function (module, __webpack_exports__, __webpack_require__) {
  ;

  __webpack_require__.r(__webpack_exports__);
  /* harmony import */


  var _Utilities_helpers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(4);
  /* harmony import */


  var _Utilities_Is__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(6);
  /* harmony import */


  var _Keyframes__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(44);

  function _typeof(obj) {
    if (typeof Symbol === "function" && _typeof2(Symbol.iterator) === "symbol") {
      _typeof = function _typeof(obj) {
        return _typeof2(obj);
      };
    } else {
      _typeof = function _typeof(obj) {
        return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : _typeof2(obj);
      };
    }

    return _typeof(obj);
  }
  /*
  ** interpolationStation.js
  **
  ** interpolationStation.js takes in an array with css rules and also an undefined
  ** number of interpolations...
  **
  ** Eric James Foster, Fostware LLC, MIT License.
  ***/
  // Get splitFilter from helpers...
  // Get verification library...
  // Get Keyframes class for validation....
  // Pre-declaring all functions here, mainly a style thing...


  var stringWeaver, interpolationFilter;
  /* A helper function for processing tagged template literal interpolation functions,
  and inserting their values back into the template.... The function takes an array
  of strings and an array of interpolation, and props as arguments, and returns the completed
  css string....*/

  stringWeaver = function stringWeaver(strings, interpolations) {
    var props = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    return (// We need to execute them with the props object, and add the value into the template...
      strings.map(function (string, i) {
        var val;
        /*
        Since the interpolation functions (refs) array will always be 1 shorter in length than
        the strings array, The last index will be undefined if we are iterating based on 'string's'
        indeces. So, we make sure that  we don't try to execute an undefined function by skipping
        the last index.....
        */

        if (i < strings.length - 1) {
          // Utilizing a switch for the different types of interpolations we may encounter...
          switch (true) {
            // If we find a function, execute it with props passed in...
            case typeof interpolations[i] === 'function':
              val = interpolations[i](props);
              break;
            // If we have a string, It is the return value of a variable, just take it as it is...

            case typeof interpolations[i] === 'string':
              val = interpolations[i];
              break;
            // If we find a keyframes instance, we need it's name....

            case interpolations[i] instanceof _Keyframes__WEBPACK_IMPORTED_MODULE_2__["Keyframes"]:
              val = interpolations[i].name;
              break;

            case typeof interpolations[i] === 'number':
              val = interpolations[i];
              break;

            /* Otherwise, I don't know what the hell we're dealing with..... Better off
            throwing an error!*/

            default:
              throw TypeError("Expecting a 'Keyframe', 'string', 'number' or 'function' here. A value of type: ".concat(_typeof(interpolations[i]), ", was given."));
          }
          /* The last index will end up here. Since there will never be an interpolation here,
          we'll just give the value an empty string....*/

        } else {
          val = '';
        } // Add interpolation values to array strings, join them...


        return string.concat('', val);
      }).join('')
    );
  };
  /*
  This function serves to activate prop function interpolations in css styling...
  The function simply takes a tagged template literal as an argument, and spits out
  completed styles, ready for appending to a style tag...   */

  /* harmony default export */


  __webpack_exports__["default"] = interpolationFilter = function interpolationFilter(ttlArray) {
    var props = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {}; // First let's check if we have interpolations to deal with...

    if (_Utilities_Is__WEBPACK_IMPORTED_MODULE_1__["Is"].interpolated(ttlArray)) {
      // Declare var for splitting strings and functions into respective arrays...
      var arrays = Object(_Utilities_helpers__WEBPACK_IMPORTED_MODULE_0__["splitFilter"])(ttlArray, function (index) {
        return _Utilities_Is__WEBPACK_IMPORTED_MODULE_1__["Is"].array(index);
      }); // Reassemble the css literals...

      var s = stringWeaver(arrays["true"][0], arrays["false"], props);
      return s; // Otherwise, rejoin the css fragments and return...
    } else {
      return ttlArray.join('');
    }
  };
  /***/

},
/* 46 */

/***/
function (module, __webpack_exports__, __webpack_require__) {
  ;

  __webpack_require__.r(__webpack_exports__);
  /* harmony export (binding) */


  __webpack_require__.d(__webpack_exports__, "default", function () {
    return alphaStringFromHash;
  });
  /*
  ** alphaStringFromHash.js
  **
  ** alphaStringFromHash.js is a very particular algorithm for converting a numeric hash
  ** into a string of alphabetical characters. Very nearly a copy/paste of the styled-
  ** components algorithm to do the very same thing. https://github.com/styled-components/
  ** styled-components/blob/master/packages/styled-components/src/utils/generateAlphabeticName.js
  ** It is used in conjuction with the murmurhash algorithm to convert a string first
  ** into a 10 digit hash, then into a unique string of alphabetical characters to be used
  ** as a name for a css keyframes instance...
  **
  ** Eric James Foster, Fostware LLC, MIT License.
  ***/
  // The number of letters (cap and lower case) in the alphabet..


  var alphaRange = 52;
  /* Once the modulo function gets x within a 2 digit range, we can get into ascii
  alphabet range by adding either 39 or 97, depending on whether or not the value
  is > than 25.*/

  var getACharacter = function getACharacter(code) {
    return String.fromCharCode(code + (code > 25 ? 39 : 97));
  };

  function alphaStringFromHash(hash) {
    var chars = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 7;
    var name = '',
        x = hash,
        // This number determines the length of the returned string. '52' = 6, '26' = 7 chars...
    divisor = chars = 6 ? 52 : undefined;

    do {
      // Diminish the hash by dividing by 26...
      x = Math.floor(x / divisor); //  Add a character to 'name'...

      name = "".concat(getACharacter(x % alphaRange)).concat(name); // Continue looping until x is dwindled to below 52...
    } while (x > alphaRange); // The remainder should be a number in the 0 - 52 range, so we can grab one last char...


    return "".concat(getACharacter(x % alphaRange)).concat(name);
  }
  /**********************************************************
  ***********************************************************
  ***********************************************************
  ***********************************************************
  ***********************************************************
  ***********************************************************
  **********************************************************/
  // Minimal es6 version, for executing in Mancy REPL ...
  // var alphaRange = 52
  // var divisor = 26
  //
  // var getACharacter =(code)=>
  //   String.fromCharCode(code + (code > 25 ? 39 : 97))
  //
  // function alphaStringFromHash(code) {
  //   var name = '',
  //   x = code
  //
  //   do {
  // // Diminish the has by dividing by 52...
  //     x = Math.floor(x / divisor)
  // //  Add a character to 'name'...
  //     name = `${getACharacter(x % alphaRange)}${name}`
  // // Continue looping until x is dwindled to below 52...
  //   } while (x > alphaRange)
  //
  // // The remainder should be a number in the 0 - 52 range, so we can grab one last char...
  //   return `${getACharacter(x % alphaRange)}${name}`
  // }

  /***/

},
/* 47 */

/***/
function (module, __webpack_exports__, __webpack_require__) {
  ;

  __webpack_require__.r(__webpack_exports__);
  /* harmony export (binding) */


  __webpack_require__.d(__webpack_exports__, "default", function () {
    return murmurHash;
  });
  /*
  ** murmurHash.js
  **
  ** murmurHash.js is a copy/pasting of garycourt's JavaScript implementation of
  ** the murmurhash algorithm. https://github.com/garycourt/murmurhash-js/blob/master/murmurhash2_gc.js
  ** It is claimed to be sub-millisecond fast... Using this upon seeing how styled-components
  ** name's their keyframe animations... I am implementing a very similar system in flare.
  **
  ** Eric James Foster, Fostware LLC, MIT License.
  ***/


  function murmurHash(str, seed) {
    var l = str.length,
        h = seed ^ l,
        i = 0,
        k;

    while (l >= 4) {
      k = str.charCodeAt(i) & 0xff | (str.charCodeAt(++i) & 0xff) << 8 | (str.charCodeAt(++i) & 0xff) << 16 | (str.charCodeAt(++i) & 0xff) << 24;
      k = (k & 0xffff) * 0x5bd1e995 + (((k >>> 16) * 0x5bd1e995 & 0xffff) << 16);
      k ^= k >>> 24;
      k = (k & 0xffff) * 0x5bd1e995 + (((k >>> 16) * 0x5bd1e995 & 0xffff) << 16);
      h = (h & 0xffff) * 0x5bd1e995 + (((h >>> 16) * 0x5bd1e995 & 0xffff) << 16) ^ k;
      l -= 4;
      ++i;
    }

    switch (l) {
      case 3:
        h ^= (str.charCodeAt(i + 2) & 0xff) << 16;

      case 2:
        h ^= (str.charCodeAt(i + 1) & 0xff) << 8;

      case 1:
        h ^= str.charCodeAt(i) & 0xff;
        h = (h & 0xffff) * 0x5bd1e995 + (((h >>> 16) * 0x5bd1e995 & 0xffff) << 16);
    }

    h ^= h >>> 13;
    h = (h & 0xffff) * 0x5bd1e995 + (((h >>> 16) * 0x5bd1e995 & 0xffff) << 16);
    h ^= h >>> 15;
    return h >>> 0;
  }
  /***/

},
/* 48 */

/***/
function (module, __webpack_exports__, __webpack_require__) {
  ;

  __webpack_require__.r(__webpack_exports__);
  /* harmony export (binding) */


  __webpack_require__.d(__webpack_exports__, "default", function () {
    return addRightArrowToSelector;
  });
  /*
  ** _stylisDirectChild.js
  **
  ** _stylisDirectChild.js is essentially a stylis plugin that alters the selectors of the
  ** css rules that stylis creates. A ">" is added between parent and child to establish
  ** a direct relationship so that styles may be overridden down the DOM tree.
  **
  ** Eric James Foster, Fostware LLC, MIT License.
  ***/
  // Regular Expressions...


  var fullSelectorRE = /\[flareid\=\"?[\w\.]+\"?\]\s?\w+\s?\{/g;
  var fullSelectorSplitRE = /\[flareid\=\"?[\w\.]+\"?\]|[a-z0-9\-]+\s?\{/g;

  function addRightArrowToSelector(rule) {
    var selectorArr; // 

    if (fullSelectorSplitRE.test(rule)) {
      selectorArr = rule.match(fullSelectorSplitRE);

      if (selectorArr.length > 1 && rule.indexOf('@keyframes') === -1) {
        return rule.replace(fullSelectorRE, selectorArr.join(' > '));
      } else {
        return rule;
      }
    } else {
      return rule;
    }
  }
  /***/

},
/* 49 */

/***/
function (module, exports, __webpack_require__) {
  ;

  module.exports = __webpack_require__(50);
  /***/
},
/* 50 */

/***/
function (module, exports, __webpack_require__) {
  function merge() {
    var dest = {};

    for (var i = 0; i < arguments.length; i++) {
      var src = arguments[i];

      for (var key in src) {
        dest[key] = src[key];
      }
    }

    return dest;
  }

  module.exports = __webpack_require__(51).create(merge(__webpack_require__(94), __webpack_require__(137), __webpack_require__(166)));
  /***/
},
/* 51 */

/***/
function (module, exports, __webpack_require__) {
  var List = __webpack_require__(52);

  var Tokenizer = __webpack_require__(53);

  var Lexer = __webpack_require__(59);

  var grammar = __webpack_require__(74);

  var createParser = __webpack_require__(75);

  var createGenerator = __webpack_require__(77);

  var createConvertor = __webpack_require__(90);

  var createWalker = __webpack_require__(91);

  var clone = __webpack_require__(92);

  var names = __webpack_require__(62);

  var mix = __webpack_require__(93);

  function assign(dest, src) {
    for (var key in src) {
      dest[key] = src[key];
    }

    return dest;
  }

  function _createSyntax(config) {
    var parse = createParser(config);
    var walk = createWalker(config);
    var generate = createGenerator(config);
    var convert = createConvertor(walk);
    var syntax = {
      List: List,
      Tokenizer: Tokenizer,
      Lexer: Lexer,
      vendorPrefix: names.vendorPrefix,
      keyword: names.keyword,
      property: names.property,
      isCustomProperty: names.isCustomProperty,
      grammar: grammar,
      lexer: null,
      createLexer: function createLexer(config) {
        return new Lexer(config, syntax, syntax.lexer.structure);
      },
      parse: parse,
      walk: walk,
      generate: generate,
      clone: clone,
      fromPlainObject: convert.fromPlainObject,
      toPlainObject: convert.toPlainObject,
      createSyntax: function createSyntax(config) {
        return _createSyntax(mix({}, config));
      },
      fork: function fork(extension) {
        var base = mix({}, config); // copy of config

        return _createSyntax(typeof extension === 'function' ? extension(base, assign) : mix(base, extension));
      }
    };
    syntax.lexer = new Lexer({
      generic: true,
      types: config.types,
      properties: config.properties,
      node: config.node
    }, syntax);
    return syntax;
  }

  ;

  exports.create = function (config) {
    return _createSyntax(mix({}, config));
  };
  /***/

},
/* 52 */

/***/
function (module, exports, __webpack_require__) {
  ; //
  //            item        item        item        item
  //          /------\    /------\    /------\    /------\
  //          | data |    | data |    | data |    | data |
  //  null <--+-prev |<---+-prev |<---+-prev |<---+-prev |
  //          | next-+--->| next-+--->| next-+--->| next-+--> null
  //          \------/    \------/    \------/    \------/
  //             ^                                    ^
  //             |                list                |
  //             |              /------\              |
  //             \--------------+-head |              |
  //                            | tail-+--------------/
  //                            \------/
  //

  function createItem(data) {
    return {
      prev: null,
      next: null,
      data: data
    };
  }

  function allocateCursor(node, prev, next) {
    var cursor;

    if (cursors !== null) {
      cursor = cursors;
      cursors = cursors.cursor;
      cursor.prev = prev;
      cursor.next = next;
      cursor.cursor = node.cursor;
    } else {
      cursor = {
        prev: prev,
        next: next,
        cursor: node.cursor
      };
    }

    node.cursor = cursor;
    return cursor;
  }

  function releaseCursor(node) {
    var cursor = node.cursor;
    node.cursor = cursor.cursor;
    cursor.prev = null;
    cursor.next = null;
    cursor.cursor = cursors;
    cursors = cursor;
  }

  var cursors = null;

  var List = function List() {
    this.cursor = null;
    this.head = null;
    this.tail = null;
  };

  List.createItem = createItem;
  List.prototype.createItem = createItem;

  List.prototype.updateCursors = function (prevOld, prevNew, nextOld, nextNew) {
    var cursor = this.cursor;

    while (cursor !== null) {
      if (cursor.prev === prevOld) {
        cursor.prev = prevNew;
      }

      if (cursor.next === nextOld) {
        cursor.next = nextNew;
      }

      cursor = cursor.cursor;
    }
  };

  List.prototype.getSize = function () {
    var size = 0;
    var cursor = this.head;

    while (cursor) {
      size++;
      cursor = cursor.next;
    }

    return size;
  };

  List.prototype.fromArray = function (array) {
    var cursor = null;
    this.head = null;

    for (var i = 0; i < array.length; i++) {
      var item = createItem(array[i]);

      if (cursor !== null) {
        cursor.next = item;
      } else {
        this.head = item;
      }

      item.prev = cursor;
      cursor = item;
    }

    this.tail = cursor;
    return this;
  };

  List.prototype.toArray = function () {
    var cursor = this.head;
    var result = [];

    while (cursor) {
      result.push(cursor.data);
      cursor = cursor.next;
    }

    return result;
  };

  List.prototype.toJSON = List.prototype.toArray;

  List.prototype.isEmpty = function () {
    return this.head === null;
  };

  List.prototype.first = function () {
    return this.head && this.head.data;
  };

  List.prototype.last = function () {
    return this.tail && this.tail.data;
  };

  List.prototype.each = function (fn, context) {
    var item;

    if (context === undefined) {
      context = this;
    } // push cursor


    var cursor = allocateCursor(this, null, this.head);

    while (cursor.next !== null) {
      item = cursor.next;
      cursor.next = item.next;
      fn.call(context, item.data, item, this);
    } // pop cursor


    releaseCursor(this);
  };

  List.prototype.forEach = List.prototype.each;

  List.prototype.eachRight = function (fn, context) {
    var item;

    if (context === undefined) {
      context = this;
    } // push cursor


    var cursor = allocateCursor(this, this.tail, null);

    while (cursor.prev !== null) {
      item = cursor.prev;
      cursor.prev = item.prev;
      fn.call(context, item.data, item, this);
    } // pop cursor


    releaseCursor(this);
  };

  List.prototype.forEachRight = List.prototype.eachRight;

  List.prototype.nextUntil = function (start, fn, context) {
    if (start === null) {
      return;
    }

    var item;

    if (context === undefined) {
      context = this;
    } // push cursor


    var cursor = allocateCursor(this, null, start);

    while (cursor.next !== null) {
      item = cursor.next;
      cursor.next = item.next;

      if (fn.call(context, item.data, item, this)) {
        break;
      }
    } // pop cursor


    releaseCursor(this);
  };

  List.prototype.prevUntil = function (start, fn, context) {
    if (start === null) {
      return;
    }

    var item;

    if (context === undefined) {
      context = this;
    } // push cursor


    var cursor = allocateCursor(this, start, null);

    while (cursor.prev !== null) {
      item = cursor.prev;
      cursor.prev = item.prev;

      if (fn.call(context, item.data, item, this)) {
        break;
      }
    } // pop cursor


    releaseCursor(this);
  };

  List.prototype.some = function (fn, context) {
    var cursor = this.head;

    if (context === undefined) {
      context = this;
    }

    while (cursor !== null) {
      if (fn.call(context, cursor.data, cursor, this)) {
        return true;
      }

      cursor = cursor.next;
    }

    return false;
  };

  List.prototype.map = function (fn, context) {
    var result = new List();
    var cursor = this.head;

    if (context === undefined) {
      context = this;
    }

    while (cursor !== null) {
      result.appendData(fn.call(context, cursor.data, cursor, this));
      cursor = cursor.next;
    }

    return result;
  };

  List.prototype.filter = function (fn, context) {
    var result = new List();
    var cursor = this.head;

    if (context === undefined) {
      context = this;
    }

    while (cursor !== null) {
      if (fn.call(context, cursor.data, cursor, this)) {
        result.appendData(cursor.data);
      }

      cursor = cursor.next;
    }

    return result;
  };

  List.prototype.clear = function () {
    this.head = null;
    this.tail = null;
  };

  List.prototype.copy = function () {
    var result = new List();
    var cursor = this.head;

    while (cursor !== null) {
      result.insert(createItem(cursor.data));
      cursor = cursor.next;
    }

    return result;
  };

  List.prototype.prepend = function (item) {
    //      head
    //    ^
    // item
    this.updateCursors(null, item, this.head, item); // insert to the beginning of the list

    if (this.head !== null) {
      // new item <- first item
      this.head.prev = item; // new item -> first item

      item.next = this.head;
    } else {
      // if list has no head, then it also has no tail
      // in this case tail points to the new item
      this.tail = item;
    } // head always points to new item


    this.head = item;
    return this;
  };

  List.prototype.prependData = function (data) {
    return this.prepend(createItem(data));
  };

  List.prototype.append = function (item) {
    return this.insert(item);
  };

  List.prototype.appendData = function (data) {
    return this.insert(createItem(data));
  };

  List.prototype.insert = function (item, before) {
    if (before !== undefined && before !== null) {
      // prev   before
      //      ^
      //     item
      this.updateCursors(before.prev, item, before, item);

      if (before.prev === null) {
        // insert to the beginning of list
        if (this.head !== before) {
          throw new Error('before doesn\'t belong to list');
        } // since head points to before therefore list doesn't empty
        // no need to check tail


        this.head = item;
        before.prev = item;
        item.next = before;
        this.updateCursors(null, item);
      } else {
        // insert between two items
        before.prev.next = item;
        item.prev = before.prev;
        before.prev = item;
        item.next = before;
      }
    } else {
      // tail
      //      ^
      //      item
      this.updateCursors(this.tail, item, null, item); // insert to the ending of the list

      if (this.tail !== null) {
        // last item -> new item
        this.tail.next = item; // last item <- new item

        item.prev = this.tail;
      } else {
        // if list has no tail, then it also has no head
        // in this case head points to new item
        this.head = item;
      } // tail always points to new item


      this.tail = item;
    }

    return this;
  };

  List.prototype.insertData = function (data, before) {
    return this.insert(createItem(data), before);
  };

  List.prototype.remove = function (item) {
    //      item
    //       ^
    // prev     next
    this.updateCursors(item, item.prev, item, item.next);

    if (item.prev !== null) {
      item.prev.next = item.next;
    } else {
      if (this.head !== item) {
        throw new Error('item doesn\'t belong to list');
      }

      this.head = item.next;
    }

    if (item.next !== null) {
      item.next.prev = item.prev;
    } else {
      if (this.tail !== item) {
        throw new Error('item doesn\'t belong to list');
      }

      this.tail = item.prev;
    }

    item.prev = null;
    item.next = null;
    return item;
  };

  List.prototype.push = function (data) {
    this.insert(createItem(data));
  };

  List.prototype.pop = function () {
    if (this.tail !== null) {
      return this.remove(this.tail);
    }
  };

  List.prototype.unshift = function (data) {
    this.prepend(createItem(data));
  };

  List.prototype.shift = function () {
    if (this.head !== null) {
      return this.remove(this.head);
    }
  };

  List.prototype.prependList = function (list) {
    return this.insertList(list, this.head);
  };

  List.prototype.appendList = function (list) {
    return this.insertList(list);
  };

  List.prototype.insertList = function (list, before) {
    // ignore empty lists
    if (list.head === null) {
      return this;
    }

    if (before !== undefined && before !== null) {
      this.updateCursors(before.prev, list.tail, before, list.head); // insert in the middle of dist list

      if (before.prev !== null) {
        // before.prev <-> list.head
        before.prev.next = list.head;
        list.head.prev = before.prev;
      } else {
        this.head = list.head;
      }

      before.prev = list.tail;
      list.tail.next = before;
    } else {
      this.updateCursors(this.tail, list.tail, null, list.head); // insert to end of the list

      if (this.tail !== null) {
        // if destination list has a tail, then it also has a head,
        // but head doesn't change
        // dest tail -> source head
        this.tail.next = list.head; // dest tail <- source head

        list.head.prev = this.tail;
      } else {
        // if list has no a tail, then it also has no a head
        // in this case points head to new item
        this.head = list.head;
      } // tail always start point to new item


      this.tail = list.tail;
    }

    list.head = null;
    list.tail = null;
    return this;
  };

  List.prototype.replace = function (oldItem, newItemOrList) {
    if ('head' in newItemOrList) {
      this.insertList(newItemOrList, oldItem);
    } else {
      this.insert(newItemOrList, oldItem);
    }

    this.remove(oldItem);
  };

  module.exports = List;
  /***/
},
/* 53 */

/***/
function (module, exports, __webpack_require__) {
  module.exports = __webpack_require__(54);
  /***/
},
/* 54 */

/***/
function (module, exports, __webpack_require__) {
  ;

  var CssSyntaxError = __webpack_require__(55);

  var constants = __webpack_require__(57);

  var TYPE = constants.TYPE;
  var NAME = constants.NAME;
  var SYMBOL_TYPE = constants.SYMBOL_TYPE;

  var utils = __webpack_require__(58);

  var firstCharOffset = utils.firstCharOffset;
  var cmpStr = utils.cmpStr;
  var isNumber = utils.isNumber;
  var findWhiteSpaceStart = utils.findWhiteSpaceStart;
  var findWhiteSpaceEnd = utils.findWhiteSpaceEnd;
  var findCommentEnd = utils.findCommentEnd;
  var findStringEnd = utils.findStringEnd;
  var findNumberEnd = utils.findNumberEnd;
  var findIdentifierEnd = utils.findIdentifierEnd;
  var findUrlRawEnd = utils.findUrlRawEnd;
  var NULL = 0;
  var WHITESPACE = TYPE.WhiteSpace;
  var IDENTIFIER = TYPE.Identifier;
  var NUMBER = TYPE.Number;
  var STRING = TYPE.String;
  var COMMENT = TYPE.Comment;
  var PUNCTUATOR = TYPE.Punctuator;
  var CDO = TYPE.CDO;
  var CDC = TYPE.CDC;
  var ATKEYWORD = TYPE.AtKeyword;
  var FUNCTION = TYPE.Function;
  var URL = TYPE.Url;
  var RAW = TYPE.Raw;
  var N = 10;
  var F = 12;
  var R = 13;
  var STAR = TYPE.Asterisk;
  var SLASH = TYPE.Solidus;
  var FULLSTOP = TYPE.FullStop;
  var PLUSSIGN = TYPE.PlusSign;
  var HYPHENMINUS = TYPE.HyphenMinus;
  var GREATERTHANSIGN = TYPE.GreaterThanSign;
  var LESSTHANSIGN = TYPE.LessThanSign;
  var EXCLAMATIONMARK = TYPE.ExclamationMark;
  var COMMERCIALAT = TYPE.CommercialAt;
  var QUOTATIONMARK = TYPE.QuotationMark;
  var APOSTROPHE = TYPE.Apostrophe;
  var LEFTPARENTHESIS = TYPE.LeftParenthesis;
  var RIGHTPARENTHESIS = TYPE.RightParenthesis;
  var LEFTCURLYBRACKET = TYPE.LeftCurlyBracket;
  var RIGHTCURLYBRACKET = TYPE.RightCurlyBracket;
  var LEFTSQUAREBRACKET = TYPE.LeftSquareBracket;
  var RIGHTSQUAREBRACKET = TYPE.RightSquareBracket;
  var MIN_BUFFER_SIZE = 16 * 1024;
  var OFFSET_MASK = 0x00FFFFFF;
  var TYPE_SHIFT = 24;
  var SafeUint32Array = typeof Uint32Array !== 'undefined' ? Uint32Array : Array; // fallback on Array when TypedArray is not supported

  function computeLinesAndColumns(tokenizer, source) {
    var sourceLength = source.length;
    var start = firstCharOffset(source);
    var lines = tokenizer.lines;
    var line = tokenizer.startLine;
    var columns = tokenizer.columns;
    var column = tokenizer.startColumn;

    if (lines === null || lines.length < sourceLength + 1) {
      lines = new SafeUint32Array(Math.max(sourceLength + 1024, MIN_BUFFER_SIZE));
      columns = new SafeUint32Array(lines.length);
    }

    for (var i = start; i < sourceLength; i++) {
      var code = source.charCodeAt(i);
      lines[i] = line;
      columns[i] = column++;

      if (code === N || code === R || code === F) {
        if (code === R && i + 1 < sourceLength && source.charCodeAt(i + 1) === N) {
          i++;
          lines[i] = line;
          columns[i] = column;
        }

        line++;
        column = 1;
      }
    }

    lines[i] = line;
    columns[i] = column;
    tokenizer.linesAnsColumnsComputed = true;
    tokenizer.lines = lines;
    tokenizer.columns = columns;
  }

  function tokenLayout(tokenizer, source, startPos) {
    var sourceLength = source.length;
    var offsetAndType = tokenizer.offsetAndType;
    var balance = tokenizer.balance;
    var tokenCount = 0;
    var prevType = 0;
    var offset = startPos;
    var anchor = 0;
    var balanceCloseCode = 0;
    var balanceStart = 0;
    var balancePrev = 0;

    if (offsetAndType === null || offsetAndType.length < sourceLength + 1) {
      offsetAndType = new SafeUint32Array(sourceLength + 1024);
      balance = new SafeUint32Array(sourceLength + 1024);
    }

    while (offset < sourceLength) {
      var code = source.charCodeAt(offset);
      var type = code < 0x80 ? SYMBOL_TYPE[code] : IDENTIFIER;
      balance[tokenCount] = sourceLength;

      switch (type) {
        case WHITESPACE:
          offset = findWhiteSpaceEnd(source, offset + 1);
          break;

        case PUNCTUATOR:
          switch (code) {
            case balanceCloseCode:
              balancePrev = balanceStart & OFFSET_MASK;
              balanceStart = balance[balancePrev];
              balanceCloseCode = balanceStart >> TYPE_SHIFT;
              balance[tokenCount] = balancePrev;
              balance[balancePrev++] = tokenCount;

              for (; balancePrev < tokenCount; balancePrev++) {
                if (balance[balancePrev] === sourceLength) {
                  balance[balancePrev] = tokenCount;
                }
              }

              break;

            case LEFTSQUAREBRACKET:
              balance[tokenCount] = balanceStart;
              balanceCloseCode = RIGHTSQUAREBRACKET;
              balanceStart = balanceCloseCode << TYPE_SHIFT | tokenCount;
              break;

            case LEFTCURLYBRACKET:
              balance[tokenCount] = balanceStart;
              balanceCloseCode = RIGHTCURLYBRACKET;
              balanceStart = balanceCloseCode << TYPE_SHIFT | tokenCount;
              break;

            case LEFTPARENTHESIS:
              balance[tokenCount] = balanceStart;
              balanceCloseCode = RIGHTPARENTHESIS;
              balanceStart = balanceCloseCode << TYPE_SHIFT | tokenCount;
              break;
          } // /*


          if (code === STAR && prevType === SLASH) {
            type = COMMENT;
            offset = findCommentEnd(source, offset + 1);
            tokenCount--; // rewrite prev token

            break;
          } // edge case for -.123 and +.123


          if (code === FULLSTOP && (prevType === PLUSSIGN || prevType === HYPHENMINUS)) {
            if (offset + 1 < sourceLength && isNumber(source.charCodeAt(offset + 1))) {
              type = NUMBER;
              offset = findNumberEnd(source, offset + 2, false);
              tokenCount--; // rewrite prev token

              break;
            }
          } // <!--


          if (code === EXCLAMATIONMARK && prevType === LESSTHANSIGN) {
            if (offset + 2 < sourceLength && source.charCodeAt(offset + 1) === HYPHENMINUS && source.charCodeAt(offset + 2) === HYPHENMINUS) {
              type = CDO;
              offset = offset + 3;
              tokenCount--; // rewrite prev token

              break;
            }
          } // -->


          if (code === HYPHENMINUS && prevType === HYPHENMINUS) {
            if (offset + 1 < sourceLength && source.charCodeAt(offset + 1) === GREATERTHANSIGN) {
              type = CDC;
              offset = offset + 2;
              tokenCount--; // rewrite prev token

              break;
            }
          } // ident(


          if (code === LEFTPARENTHESIS && prevType === IDENTIFIER) {
            offset = offset + 1;
            tokenCount--; // rewrite prev token

            balance[tokenCount] = balance[tokenCount + 1];
            balanceStart--; // 4 char length identifier and equal to `url(` (case insensitive)

            if (offset - anchor === 4 && cmpStr(source, anchor, offset, 'url(')) {
              // special case for url() because it can contain any symbols sequence with few exceptions
              anchor = findWhiteSpaceEnd(source, offset);
              code = source.charCodeAt(anchor);

              if (code !== LEFTPARENTHESIS && code !== RIGHTPARENTHESIS && code !== QUOTATIONMARK && code !== APOSTROPHE) {
                // url(
                offsetAndType[tokenCount++] = URL << TYPE_SHIFT | offset;
                balance[tokenCount] = sourceLength; // ws*

                if (anchor !== offset) {
                  offsetAndType[tokenCount++] = WHITESPACE << TYPE_SHIFT | anchor;
                  balance[tokenCount] = sourceLength;
                } // raw


                type = RAW;
                offset = findUrlRawEnd(source, anchor);
              } else {
                type = URL;
              }
            } else {
              type = FUNCTION;
            }

            break;
          }

          type = code;
          offset = offset + 1;
          break;

        case NUMBER:
          offset = findNumberEnd(source, offset + 1, prevType !== FULLSTOP); // merge number with a preceding dot, dash or plus

          if (prevType === FULLSTOP || prevType === HYPHENMINUS || prevType === PLUSSIGN) {
            tokenCount--; // rewrite prev token
          }

          break;

        case STRING:
          offset = findStringEnd(source, offset + 1, code);
          break;

        default:
          anchor = offset;
          offset = findIdentifierEnd(source, offset); // merge identifier with a preceding dash

          if (prevType === HYPHENMINUS) {
            // rewrite prev token
            tokenCount--; // restore prev prev token type
            // for case @-prefix-ident

            prevType = tokenCount === 0 ? 0 : offsetAndType[tokenCount - 1] >> TYPE_SHIFT;
          }

          if (prevType === COMMERCIALAT) {
            // rewrite prev token and change type to <at-keyword-token>
            tokenCount--;
            type = ATKEYWORD;
          }

      }

      offsetAndType[tokenCount++] = type << TYPE_SHIFT | offset;
      prevType = type;
    } // finalize arrays


    offsetAndType[tokenCount] = offset;
    balance[tokenCount] = sourceLength;
    balance[sourceLength] = sourceLength; // prevents false positive balance match with any token

    while (balanceStart !== 0) {
      balancePrev = balanceStart & OFFSET_MASK;
      balanceStart = balance[balancePrev];
      balance[balancePrev] = sourceLength;
    }

    tokenizer.offsetAndType = offsetAndType;
    tokenizer.tokenCount = tokenCount;
    tokenizer.balance = balance;
  } //
  // tokenizer
  //


  var Tokenizer = function Tokenizer(source, startOffset, startLine, startColumn) {
    this.offsetAndType = null;
    this.balance = null;
    this.lines = null;
    this.columns = null;
    this.setSource(source, startOffset, startLine, startColumn);
  };

  Tokenizer.prototype = {
    setSource: function setSource(source, startOffset, startLine, startColumn) {
      var safeSource = String(source || '');
      var start = firstCharOffset(safeSource);
      this.source = safeSource;
      this.firstCharOffset = start;
      this.startOffset = typeof startOffset === 'undefined' ? 0 : startOffset;
      this.startLine = typeof startLine === 'undefined' ? 1 : startLine;
      this.startColumn = typeof startColumn === 'undefined' ? 1 : startColumn;
      this.linesAnsColumnsComputed = false;
      this.eof = false;
      this.currentToken = -1;
      this.tokenType = 0;
      this.tokenStart = start;
      this.tokenEnd = start;
      tokenLayout(this, safeSource, start);
      this.next();
    },
    lookupType: function lookupType(offset) {
      offset += this.currentToken;

      if (offset < this.tokenCount) {
        return this.offsetAndType[offset] >> TYPE_SHIFT;
      }

      return NULL;
    },
    lookupNonWSType: function lookupNonWSType(offset) {
      offset += this.currentToken;

      for (var type; offset < this.tokenCount; offset++) {
        type = this.offsetAndType[offset] >> TYPE_SHIFT;

        if (type !== WHITESPACE) {
          return type;
        }
      }

      return NULL;
    },
    lookupValue: function lookupValue(offset, referenceStr) {
      offset += this.currentToken;

      if (offset < this.tokenCount) {
        return cmpStr(this.source, this.offsetAndType[offset - 1] & OFFSET_MASK, this.offsetAndType[offset] & OFFSET_MASK, referenceStr);
      }

      return false;
    },
    getTokenStart: function getTokenStart(tokenNum) {
      if (tokenNum === this.currentToken) {
        return this.tokenStart;
      }

      if (tokenNum > 0) {
        return tokenNum < this.tokenCount ? this.offsetAndType[tokenNum - 1] & OFFSET_MASK : this.offsetAndType[this.tokenCount] & OFFSET_MASK;
      }

      return this.firstCharOffset;
    },
    getOffsetExcludeWS: function getOffsetExcludeWS() {
      if (this.currentToken > 0) {
        if (this.offsetAndType[this.currentToken - 1] >> TYPE_SHIFT === WHITESPACE) {
          return this.currentToken > 1 ? this.offsetAndType[this.currentToken - 2] & OFFSET_MASK : this.firstCharOffset;
        }
      }

      return this.tokenStart;
    },
    getRawLength: function getRawLength(startToken, endTokenType1, endTokenType2, includeTokenType2) {
      var cursor = startToken;
      var balanceEnd;

      loop: for (; cursor < this.tokenCount; cursor++) {
        balanceEnd = this.balance[cursor]; // belance end points to offset before start

        if (balanceEnd < startToken) {
          break loop;
        } // check token is stop type


        switch (this.offsetAndType[cursor] >> TYPE_SHIFT) {
          case endTokenType1:
            break loop;

          case endTokenType2:
            if (includeTokenType2) {
              cursor++;
            }

            break loop;

          default:
            // fast forward to the end of balanced block
            if (this.balance[balanceEnd] === cursor) {
              cursor = balanceEnd;
            }

        }
      }

      return cursor - this.currentToken;
    },
    isBalanceEdge: function isBalanceEdge(pos) {
      var balanceStart = this.balance[this.currentToken];
      return balanceStart < pos;
    },
    getTokenValue: function getTokenValue() {
      return this.source.substring(this.tokenStart, this.tokenEnd);
    },
    substrToCursor: function substrToCursor(start) {
      return this.source.substring(start, this.tokenStart);
    },
    skipWS: function skipWS() {
      for (var i = this.currentToken, skipTokenCount = 0; i < this.tokenCount; i++, skipTokenCount++) {
        if (this.offsetAndType[i] >> TYPE_SHIFT !== WHITESPACE) {
          break;
        }
      }

      if (skipTokenCount > 0) {
        this.skip(skipTokenCount);
      }
    },
    skipSC: function skipSC() {
      while (this.tokenType === WHITESPACE || this.tokenType === COMMENT) {
        this.next();
      }
    },
    skip: function skip(tokenCount) {
      var next = this.currentToken + tokenCount;

      if (next < this.tokenCount) {
        this.currentToken = next;
        this.tokenStart = this.offsetAndType[next - 1] & OFFSET_MASK;
        next = this.offsetAndType[next];
        this.tokenType = next >> TYPE_SHIFT;
        this.tokenEnd = next & OFFSET_MASK;
      } else {
        this.currentToken = this.tokenCount;
        this.next();
      }
    },
    next: function next() {
      var next = this.currentToken + 1;

      if (next < this.tokenCount) {
        this.currentToken = next;
        this.tokenStart = this.tokenEnd;
        next = this.offsetAndType[next];
        this.tokenType = next >> TYPE_SHIFT;
        this.tokenEnd = next & OFFSET_MASK;
      } else {
        this.currentToken = this.tokenCount;
        this.eof = true;
        this.tokenType = NULL;
        this.tokenStart = this.tokenEnd = this.source.length;
      }
    },
    eat: function eat(tokenType) {
      if (this.tokenType !== tokenType) {
        var offset = this.tokenStart;
        var message = NAME[tokenType] + ' is expected'; // tweak message and offset

        if (tokenType === IDENTIFIER) {
          // when identifier is expected but there is a function or url
          if (this.tokenType === FUNCTION || this.tokenType === URL) {
            offset = this.tokenEnd - 1;
            message += ' but function found';
          }
        } else {
          // when test type is part of another token show error for current position + 1
          // e.g. eat(HYPHENMINUS) will fail on "-foo", but pointing on "-" is odd
          if (this.source.charCodeAt(this.tokenStart) === tokenType) {
            offset = offset + 1;
          }
        }

        this.error(message, offset);
      }

      this.next();
    },
    eatNonWS: function eatNonWS(tokenType) {
      this.skipWS();
      this.eat(tokenType);
    },
    consume: function consume(tokenType) {
      var value = this.getTokenValue();
      this.eat(tokenType);
      return value;
    },
    consumeFunctionName: function consumeFunctionName() {
      var name = this.source.substring(this.tokenStart, this.tokenEnd - 1);
      this.eat(FUNCTION);
      return name;
    },
    consumeNonWS: function consumeNonWS(tokenType) {
      this.skipWS();
      return this.consume(tokenType);
    },
    expectIdentifier: function expectIdentifier(name) {
      if (this.tokenType !== IDENTIFIER || cmpStr(this.source, this.tokenStart, this.tokenEnd, name) === false) {
        this.error('Identifier `' + name + '` is expected');
      }

      this.next();
    },
    getLocation: function getLocation(offset, filename) {
      if (!this.linesAnsColumnsComputed) {
        computeLinesAndColumns(this, this.source);
      }

      return {
        source: filename,
        offset: this.startOffset + offset,
        line: this.lines[offset],
        column: this.columns[offset]
      };
    },
    getLocationRange: function getLocationRange(start, end, filename) {
      if (!this.linesAnsColumnsComputed) {
        computeLinesAndColumns(this, this.source);
      }

      return {
        source: filename,
        start: {
          offset: this.startOffset + start,
          line: this.lines[start],
          column: this.columns[start]
        },
        end: {
          offset: this.startOffset + end,
          line: this.lines[end],
          column: this.columns[end]
        }
      };
    },
    error: function error(message, offset) {
      var location = typeof offset !== 'undefined' && offset < this.source.length ? this.getLocation(offset) : this.eof ? this.getLocation(findWhiteSpaceStart(this.source, this.source.length - 1)) : this.getLocation(this.tokenStart);
      throw new CssSyntaxError(message || 'Unexpected input', this.source, location.offset, location.line, location.column);
    },
    dump: function dump() {
      var offset = 0;
      return Array.prototype.slice.call(this.offsetAndType, 0, this.tokenCount).map(function (item, idx) {
        var start = offset;
        var end = item & OFFSET_MASK;
        offset = end;
        return {
          idx: idx,
          type: NAME[item >> TYPE_SHIFT],
          chunk: this.source.substring(start, end),
          balance: this.balance[idx]
        };
      }, this);
    }
  }; // extend with error class

  Tokenizer.CssSyntaxError = CssSyntaxError; // extend tokenizer with constants

  Object.keys(constants).forEach(function (key) {
    Tokenizer[key] = constants[key];
  }); // extend tokenizer with static methods from utils

  Object.keys(utils).forEach(function (key) {
    Tokenizer[key] = utils[key];
  }); // warm up tokenizer to elimitate code branches that never execute
  // fix soft deoptimizations (insufficient type feedback)

  new Tokenizer('\n\r\r\n\f<!---->//""\'\'/*\r\n\f*/1a;.\\31\t\+2{url(a);func();+1.2e3 -.4e-5 .6e+7}').getLocation();
  module.exports = Tokenizer;
  /***/
},
/* 55 */

/***/
function (module, exports, __webpack_require__) {
  ;

  var createCustomError = __webpack_require__(56);

  var MAX_LINE_LENGTH = 100;
  var OFFSET_CORRECTION = 60;
  var TAB_REPLACEMENT = '    ';

  function sourceFragment(error, extraLines) {
    function processLines(start, end) {
      return lines.slice(start, end).map(function (line, idx) {
        var num = String(start + idx + 1);

        while (num.length < maxNumLength) {
          num = ' ' + num;
        }

        return num + ' |' + line;
      }).join('\n');
    }

    var lines = error.source.split(/\r\n?|\n|\f/);
    var line = error.line;
    var column = error.column;
    var startLine = Math.max(1, line - extraLines) - 1;
    var endLine = Math.min(line + extraLines, lines.length + 1);
    var maxNumLength = Math.max(4, String(endLine).length) + 1;
    var cutLeft = 0; // column correction according to replaced tab before column

    column += (TAB_REPLACEMENT.length - 1) * (lines[line - 1].substr(0, column - 1).match(/\t/g) || []).length;

    if (column > MAX_LINE_LENGTH) {
      cutLeft = column - OFFSET_CORRECTION + 3;
      column = OFFSET_CORRECTION - 2;
    }

    for (var i = startLine; i <= endLine; i++) {
      if (i >= 0 && i < lines.length) {
        lines[i] = lines[i].replace(/\t/g, TAB_REPLACEMENT);
        lines[i] = (cutLeft > 0 && lines[i].length > cutLeft ? "\u2026" : '') + lines[i].substr(cutLeft, MAX_LINE_LENGTH - 2) + (lines[i].length > cutLeft + MAX_LINE_LENGTH - 1 ? "\u2026" : '');
      }
    }

    return [processLines(startLine, line), new Array(column + maxNumLength + 2).join('-') + '^', processLines(line, endLine)].filter(Boolean).join('\n');
  }

  var CssSyntaxError = function CssSyntaxError(message, source, offset, line, column) {
    var error = createCustomError('CssSyntaxError', message);
    error.source = source;
    error.offset = offset;
    error.line = line;
    error.column = column;

    error.sourceFragment = function (extraLines) {
      return sourceFragment(error, isNaN(extraLines) ? 0 : extraLines);
    };

    Object.defineProperty(error, 'formattedMessage', {
      get: function get() {
        return 'Parse error: ' + error.message + '\n' + sourceFragment(error, 2);
      }
    }); // for backward capability

    error.parseError = {
      offset: offset,
      line: line,
      column: column
    };
    return error;
  };

  module.exports = CssSyntaxError;
  /***/
},
/* 56 */

/***/
function (module, exports) {
  module.exports = function createCustomError(name, message) {
    // use Object.create(), because some VMs prevent setting line/column otherwise
    // (iOS Safari 10 even throws an exception)
    var error = Object.create(SyntaxError.prototype);
    var errorStack = new Error();
    error.name = name;
    error.message = message;
    Object.defineProperty(error, 'stack', {
      get: function get() {
        return (errorStack.stack || '').replace(/^(.+\n){1,3}/, name + ': ' + message + '\n');
      }
    });
    return error;
  };
  /***/

},
/* 57 */

/***/
function (module, exports, __webpack_require__) {
  ; // token types (note: value shouldn't intersect with used char codes)

  var WHITESPACE = 1;
  var IDENTIFIER = 2;
  var NUMBER = 3;
  var STRING = 4;
  var COMMENT = 5;
  var PUNCTUATOR = 6;
  var CDO = 7;
  var CDC = 8;
  var ATKEYWORD = 14;
  var FUNCTION = 15;
  var URL = 16;
  var RAW = 17;
  var TAB = 9;
  var N = 10;
  var F = 12;
  var R = 13;
  var SPACE = 32;
  var TYPE = {
    WhiteSpace: WHITESPACE,
    Identifier: IDENTIFIER,
    Number: NUMBER,
    String: STRING,
    Comment: COMMENT,
    Punctuator: PUNCTUATOR,
    CDO: CDO,
    CDC: CDC,
    AtKeyword: ATKEYWORD,
    Function: FUNCTION,
    Url: URL,
    Raw: RAW,
    ExclamationMark: 33,
    // !
    QuotationMark: 34,
    // "
    NumberSign: 35,
    // #
    DollarSign: 36,
    // $
    PercentSign: 37,
    // %
    Ampersand: 38,
    // &
    Apostrophe: 39,
    // '
    LeftParenthesis: 40,
    // (
    RightParenthesis: 41,
    // )
    Asterisk: 42,
    // *
    PlusSign: 43,
    // +
    Comma: 44,
    // ,
    HyphenMinus: 45,
    // -
    FullStop: 46,
    // .
    Solidus: 47,
    // /
    Colon: 58,
    // :
    Semicolon: 59,
    // ;
    LessThanSign: 60,
    // <
    EqualsSign: 61,
    // =
    GreaterThanSign: 62,
    // >
    QuestionMark: 63,
    // ?
    CommercialAt: 64,
    // @
    LeftSquareBracket: 91,
    // [
    Backslash: 92,
    // \
    RightSquareBracket: 93,
    // ]
    CircumflexAccent: 94,
    // ^
    LowLine: 95,
    // _
    GraveAccent: 96,
    // `
    LeftCurlyBracket: 123,
    // {
    VerticalLine: 124,
    // |
    RightCurlyBracket: 125,
    // }
    Tilde: 126 // ~

  };
  var NAME = Object.keys(TYPE).reduce(function (result, key) {
    result[TYPE[key]] = key;
    return result;
  }, {}); // https://drafts.csswg.org/css-syntax/#tokenizer-definitions
  // > non-ASCII code point
  // >   A code point with a value equal to or greater than U+0080 <control>
  // > name-start code point
  // >   A letter, a non-ASCII code point, or U+005F LOW LINE (_).
  // > name code point
  // >   A name-start code point, a digit, or U+002D HYPHEN-MINUS (-)
  // That means only ASCII code points has a special meaning and we a maps for 0..127 codes only

  var SafeUint32Array = typeof Uint32Array !== 'undefined' ? Uint32Array : Array; // fallback on Array when TypedArray is not supported

  var SYMBOL_TYPE = new SafeUint32Array(0x80);
  var PUNCTUATION = new SafeUint32Array(0x80);
  var STOP_URL_RAW = new SafeUint32Array(0x80);

  for (var i = 0; i < SYMBOL_TYPE.length; i++) {
    SYMBOL_TYPE[i] = IDENTIFIER;
  } // fill categories


  [TYPE.ExclamationMark, // !
  TYPE.QuotationMark, // "
  TYPE.NumberSign, // #
  TYPE.DollarSign, // $
  TYPE.PercentSign, // %
  TYPE.Ampersand, // &
  TYPE.Apostrophe, // '
  TYPE.LeftParenthesis, // (
  TYPE.RightParenthesis, // )
  TYPE.Asterisk, // *
  TYPE.PlusSign, // +
  TYPE.Comma, // ,
  TYPE.HyphenMinus, // -
  TYPE.FullStop, // .
  TYPE.Solidus, // /
  TYPE.Colon, // :
  TYPE.Semicolon, // ;
  TYPE.LessThanSign, // <
  TYPE.EqualsSign, // =
  TYPE.GreaterThanSign, // >
  TYPE.QuestionMark, // ?
  TYPE.CommercialAt, // @
  TYPE.LeftSquareBracket, // [
  // TYPE.Backslash,          // \
  TYPE.RightSquareBracket, // ]
  TYPE.CircumflexAccent, // ^
  // TYPE.LowLine,            // _
  TYPE.GraveAccent, // `
  TYPE.LeftCurlyBracket, // {
  TYPE.VerticalLine, // |
  TYPE.RightCurlyBracket, // }
  TYPE.Tilde // ~
  ].forEach(function (key) {
    SYMBOL_TYPE[Number(key)] = PUNCTUATOR;
    PUNCTUATION[Number(key)] = PUNCTUATOR;
  });

  for (var i = 48; i <= 57; i++) {
    SYMBOL_TYPE[i] = NUMBER;
  }

  SYMBOL_TYPE[SPACE] = WHITESPACE;
  SYMBOL_TYPE[TAB] = WHITESPACE;
  SYMBOL_TYPE[N] = WHITESPACE;
  SYMBOL_TYPE[R] = WHITESPACE;
  SYMBOL_TYPE[F] = WHITESPACE;
  SYMBOL_TYPE[TYPE.Apostrophe] = STRING;
  SYMBOL_TYPE[TYPE.QuotationMark] = STRING;
  STOP_URL_RAW[SPACE] = 1;
  STOP_URL_RAW[TAB] = 1;
  STOP_URL_RAW[N] = 1;
  STOP_URL_RAW[R] = 1;
  STOP_URL_RAW[F] = 1;
  STOP_URL_RAW[TYPE.Apostrophe] = 1;
  STOP_URL_RAW[TYPE.QuotationMark] = 1;
  STOP_URL_RAW[TYPE.LeftParenthesis] = 1;
  STOP_URL_RAW[TYPE.RightParenthesis] = 1; // whitespace is punctuation ...

  PUNCTUATION[SPACE] = PUNCTUATOR;
  PUNCTUATION[TAB] = PUNCTUATOR;
  PUNCTUATION[N] = PUNCTUATOR;
  PUNCTUATION[R] = PUNCTUATOR;
  PUNCTUATION[F] = PUNCTUATOR; // ... hyper minus is not

  PUNCTUATION[TYPE.HyphenMinus] = 0;
  module.exports = {
    TYPE: TYPE,
    NAME: NAME,
    SYMBOL_TYPE: SYMBOL_TYPE,
    PUNCTUATION: PUNCTUATION,
    STOP_URL_RAW: STOP_URL_RAW
  };
  /***/
},
/* 58 */

/***/
function (module, exports, __webpack_require__) {
  ;

  var constants = __webpack_require__(57);

  var PUNCTUATION = constants.PUNCTUATION;
  var STOP_URL_RAW = constants.STOP_URL_RAW;
  var TYPE = constants.TYPE;
  var FULLSTOP = TYPE.FullStop;
  var PLUSSIGN = TYPE.PlusSign;
  var HYPHENMINUS = TYPE.HyphenMinus;
  var PUNCTUATOR = TYPE.Punctuator;
  var TAB = 9;
  var N = 10;
  var F = 12;
  var R = 13;
  var SPACE = 32;
  var BACK_SLASH = 92;
  var E = 101; // 'e'.charCodeAt(0)

  function firstCharOffset(source) {
    // detect BOM (https://en.wikipedia.org/wiki/Byte_order_mark)
    if (source.charCodeAt(0) === 0xFEFF || // UTF-16BE
    source.charCodeAt(0) === 0xFFFE) {
      // UTF-16LE
      return 1;
    }

    return 0;
  }

  function isHex(code) {
    return code >= 48 && code <= 57 || // 0 .. 9
    code >= 65 && code <= 70 || // A .. F
    code >= 97 && code <= 102; // a .. f
  }

  function isNumber(code) {
    return code >= 48 && code <= 57;
  }

  function isWhiteSpace(code) {
    return code === SPACE || code === TAB || isNewline(code);
  }

  function isNewline(code) {
    return code === R || code === N || code === F;
  }

  function getNewlineLength(source, offset, code) {
    if (isNewline(code)) {
      if (code === R && offset + 1 < source.length && source.charCodeAt(offset + 1) === N) {
        return 2;
      }

      return 1;
    }

    return 0;
  }

  function cmpChar(testStr, offset, referenceCode) {
    var code = testStr.charCodeAt(offset); // code.toLowerCase() for A..Z

    if (code >= 65 && code <= 90) {
      code = code | 32;
    }

    return code === referenceCode;
  }

  function cmpStr(testStr, start, end, referenceStr) {
    if (end - start !== referenceStr.length) {
      return false;
    }

    if (start < 0 || end > testStr.length) {
      return false;
    }

    for (var i = start; i < end; i++) {
      var testCode = testStr.charCodeAt(i);
      var refCode = referenceStr.charCodeAt(i - start); // testCode.toLowerCase() for A..Z

      if (testCode >= 65 && testCode <= 90) {
        testCode = testCode | 32;
      }

      if (testCode !== refCode) {
        return false;
      }
    }

    return true;
  }

  function findWhiteSpaceStart(source, offset) {
    while (offset >= 0 && isWhiteSpace(source.charCodeAt(offset))) {
      offset--;
    }

    return offset + 1;
  }

  function findWhiteSpaceEnd(source, offset) {
    while (offset < source.length && isWhiteSpace(source.charCodeAt(offset))) {
      offset++;
    }

    return offset;
  }

  function findCommentEnd(source, offset) {
    var commentEnd = source.indexOf('*/', offset);

    if (commentEnd === -1) {
      return source.length;
    }

    return commentEnd + 2;
  }

  function findStringEnd(source, offset, quote) {
    for (; offset < source.length; offset++) {
      var code = source.charCodeAt(offset); // TODO: bad string

      if (code === BACK_SLASH) {
        offset++;
      } else if (code === quote) {
        offset++;
        break;
      }
    }

    return offset;
  }

  function findDecimalNumberEnd(source, offset) {
    while (offset < source.length && isNumber(source.charCodeAt(offset))) {
      offset++;
    }

    return offset;
  }

  function findNumberEnd(source, offset, allowFraction) {
    var code;
    offset = findDecimalNumberEnd(source, offset); // fraction: .\d+

    if (allowFraction && offset + 1 < source.length && source.charCodeAt(offset) === FULLSTOP) {
      code = source.charCodeAt(offset + 1);

      if (isNumber(code)) {
        offset = findDecimalNumberEnd(source, offset + 1);
      }
    } // exponent: e[+-]\d+


    if (offset + 1 < source.length) {
      if ((source.charCodeAt(offset) | 32) === E) {
        // case insensitive check for `e`
        code = source.charCodeAt(offset + 1);

        if (code === PLUSSIGN || code === HYPHENMINUS) {
          if (offset + 2 < source.length) {
            code = source.charCodeAt(offset + 2);
          }
        }

        if (isNumber(code)) {
          offset = findDecimalNumberEnd(source, offset + 2);
        }
      }
    }

    return offset;
  } // skip escaped unicode sequence that can ends with space
  // [0-9a-f]{1,6}(\r\n|[ \n\r\t\f])?


  function findEscapeEnd(source, offset) {
    for (var i = 0; i < 7 && offset + i < source.length; i++) {
      var code = source.charCodeAt(offset + i);

      if (i !== 6 && isHex(code)) {
        continue;
      }

      if (i > 0) {
        offset += i - 1 + getNewlineLength(source, offset + i, code);

        if (code === SPACE || code === TAB) {
          offset++;
        }
      }

      break;
    }

    return offset;
  }

  function findIdentifierEnd(source, offset) {
    for (; offset < source.length; offset++) {
      var code = source.charCodeAt(offset);

      if (code === BACK_SLASH) {
        offset = findEscapeEnd(source, offset + 1);
      } else if (code < 0x80 && PUNCTUATION[code] === PUNCTUATOR) {
        break;
      }
    }

    return offset;
  }

  function findUrlRawEnd(source, offset) {
    for (; offset < source.length; offset++) {
      var code = source.charCodeAt(offset);

      if (code === BACK_SLASH) {
        offset = findEscapeEnd(source, offset + 1);
      } else if (code < 0x80 && STOP_URL_RAW[code] === 1) {
        break;
      }
    }

    return offset;
  }

  module.exports = {
    firstCharOffset: firstCharOffset,
    isHex: isHex,
    isNumber: isNumber,
    isWhiteSpace: isWhiteSpace,
    isNewline: isNewline,
    getNewlineLength: getNewlineLength,
    cmpChar: cmpChar,
    cmpStr: cmpStr,
    findWhiteSpaceStart: findWhiteSpaceStart,
    findWhiteSpaceEnd: findWhiteSpaceEnd,
    findCommentEnd: findCommentEnd,
    findStringEnd: findStringEnd,
    findDecimalNumberEnd: findDecimalNumberEnd,
    findNumberEnd: findNumberEnd,
    findEscapeEnd: findEscapeEnd,
    findIdentifierEnd: findIdentifierEnd,
    findUrlRawEnd: findUrlRawEnd
  };
  /***/
},
/* 59 */

/***/
function (module, exports, __webpack_require__) {
  ;

  var SyntaxReferenceError = __webpack_require__(60).SyntaxReferenceError;

  var MatchError = __webpack_require__(60).MatchError;

  var names = __webpack_require__(62);

  var generic = __webpack_require__(63);

  var parse = __webpack_require__(64);

  var generate = __webpack_require__(61);

  var walk = __webpack_require__(67);

  var astToTokens = __webpack_require__(68);

  var buildMatchGraph = __webpack_require__(69).buildMatchGraph;

  var matchAsTree = __webpack_require__(70).matchAsTree;

  var trace = __webpack_require__(71);

  var search = __webpack_require__(72);

  var getStructureFromConfig = __webpack_require__(73).getStructureFromConfig;

  var cssWideKeywords = buildMatchGraph(parse('inherit | initial | unset'));
  var cssWideKeywordsWithExpression = buildMatchGraph(parse('inherit | initial | unset | <expression>'));

  function dumpMapSyntax(map, syntaxAsAst) {
    var result = {};

    for (var name in map) {
      if (map[name].syntax) {
        result[name] = syntaxAsAst ? map[name].syntax : generate(map[name].syntax);
      }
    }

    return result;
  }

  function valueHasVar(value) {
    var hasVar = false;
    this.syntax.walk(value, function (node) {
      if (node.type === 'Function' && node.name.toLowerCase() === 'var') {
        hasVar = true;
      }
    });
    return hasVar;
  }

  function buildMatchResult(match, error, iterations) {
    return {
      matched: match,
      iterations: iterations,
      error: error,
      getTrace: trace.getTrace,
      isType: trace.isType,
      isProperty: trace.isProperty,
      isKeyword: trace.isKeyword
    };
  }

  function matchSyntax(lexer, syntax, node, useCommon) {
    if (!node) {
      return buildMatchResult(null, new Error('Node is undefined'));
    }

    if (valueHasVar.call(lexer, node)) {
      return buildMatchResult(null, new Error('Matching for a tree with var() is not supported'));
    }

    var tokens = lexer.syntax.generate(node, astToTokens);
    var result;

    if (useCommon) {
      result = matchAsTree(tokens, lexer.valueCommonSyntax, lexer);
    }

    if (!useCommon || !result.match) {
      result = matchAsTree(tokens, syntax.match, lexer);

      if (!result.match) {
        return buildMatchResult(null, new MatchError(result.reason, lexer, syntax.syntax, node, result), result.iterations);
      }
    }

    return buildMatchResult(result.match, null, result.iterations);
  }

  var Lexer = function Lexer(config, syntax, structure) {
    this.valueCommonSyntax = cssWideKeywords;
    this.syntax = syntax;
    this.generic = false;
    this.properties = {};
    this.types = {};
    this.structure = structure || getStructureFromConfig(config);

    if (config) {
      if (config.generic) {
        this.generic = true;

        for (var name in generic) {
          this.addType_(name, generic[name]);
        }
      }

      if (config.types) {
        for (var name in config.types) {
          this.addType_(name, config.types[name]);
        }
      }

      if (config.properties) {
        for (var name in config.properties) {
          this.addProperty_(name, config.properties[name]);
        }
      }
    }
  };

  Lexer.prototype = {
    structure: {},
    checkStructure: function checkStructure(ast) {
      function collectWarning(node, message) {
        warns.push({
          node: node,
          message: message
        });
      }

      var structure = this.structure;
      var warns = [];
      this.syntax.walk(ast, function (node) {
        if (structure.hasOwnProperty(node.type)) {
          structure[node.type].check(node, collectWarning);
        } else {
          collectWarning(node, 'Unknown node type `' + node.type + '`');
        }
      });
      return warns.length ? warns : false;
    },
    createDescriptor: function createDescriptor(syntax, type, name) {
      var ref = {
        type: type,
        name: name
      };
      var descriptor = {
        type: type,
        name: name,
        syntax: null,
        match: null
      };

      if (typeof syntax === 'function') {
        descriptor.match = buildMatchGraph(syntax, ref);
      } else {
        if (typeof syntax === 'string') {
          // lazy parsing on first access
          Object.defineProperty(descriptor, 'syntax', {
            get: function get() {
              Object.defineProperty(descriptor, 'syntax', {
                value: parse(syntax)
              });
              return descriptor.syntax;
            }
          });
        } else {
          descriptor.syntax = syntax;
        }

        Object.defineProperty(descriptor, 'match', {
          get: function get() {
            Object.defineProperty(descriptor, 'match', {
              value: buildMatchGraph(descriptor.syntax, ref)
            });
            return descriptor.match;
          }
        });
      }

      return descriptor;
    },
    addProperty_: function addProperty_(name, syntax) {
      this.properties[name] = this.createDescriptor(syntax, 'Property', name);
    },
    addType_: function addType_(name, syntax) {
      this.types[name] = this.createDescriptor(syntax, 'Type', name);

      if (syntax === generic.expression) {
        this.valueCommonSyntax = cssWideKeywordsWithExpression;
      }
    },
    matchDeclaration: function matchDeclaration(node) {
      if (node.type !== 'Declaration') {
        return buildMatchResult(null, new Error('Not a Declaration node'));
      }

      return this.matchProperty(node.property, node.value);
    },
    matchProperty: function matchProperty(propertyName, value) {
      var property = names.property(propertyName); // don't match syntax for a custom property

      if (property.custom) {
        return buildMatchResult(null, new Error('Lexer matching doesn\'t applicable for custom properties'));
      }

      var propertySyntax = property.vendor ? this.getProperty(property.name) || this.getProperty(property.basename) : this.getProperty(property.name);

      if (!propertySyntax) {
        return buildMatchResult(null, new SyntaxReferenceError('Unknown property', propertyName));
      }

      return matchSyntax(this, propertySyntax, value, true);
    },
    matchType: function matchType(typeName, value) {
      var typeSyntax = this.getType(typeName);

      if (!typeSyntax) {
        return buildMatchResult(null, new SyntaxReferenceError('Unknown type', typeName));
      }

      return matchSyntax(this, typeSyntax, value, false);
    },
    match: function match(syntax, value) {
      if (!syntax || !syntax.type) {
        return buildMatchResult(null, new SyntaxReferenceError('Bad syntax'));
      }

      if (!syntax.match) {
        syntax = this.createDescriptor(syntax);
      }

      return matchSyntax(this, syntax, value, false);
    },
    findValueFragments: function findValueFragments(propertyName, value, type, name) {
      return search.matchFragments(this, value, this.matchProperty(propertyName, value), type, name);
    },
    findDeclarationValueFragments: function findDeclarationValueFragments(declaration, type, name) {
      return search.matchFragments(this, declaration.value, this.matchDeclaration(declaration), type, name);
    },
    findAllFragments: function findAllFragments(ast, type, name) {
      var result = [];
      this.syntax.walk(ast, {
        visit: 'Declaration',
        enter: function (declaration) {
          result.push.apply(result, this.findDeclarationValueFragments(declaration, type, name));
        }.bind(this)
      });
      return result;
    },
    getProperty: function getProperty(name) {
      return this.properties.hasOwnProperty(name) ? this.properties[name] : null;
    },
    getType: function getType(name) {
      return this.types.hasOwnProperty(name) ? this.types[name] : null;
    },
    validate: function validate() {
      function validate(syntax, name, broken, descriptor) {
        if (broken.hasOwnProperty(name)) {
          return broken[name];
        }

        broken[name] = false;

        if (descriptor.syntax !== null) {
          walk(descriptor.syntax, function (node) {
            if (node.type !== 'Type' && node.type !== 'Property') {
              return;
            }

            var map = node.type === 'Type' ? syntax.types : syntax.properties;
            var brokenMap = node.type === 'Type' ? brokenTypes : brokenProperties;

            if (!map.hasOwnProperty(node.name) || validate(syntax, node.name, brokenMap, map[node.name])) {
              broken[name] = true;
            }
          }, this);
        }
      }

      var brokenTypes = {};
      var brokenProperties = {};

      for (var key in this.types) {
        validate(this, key, brokenTypes, this.types[key]);
      }

      for (var key in this.properties) {
        validate(this, key, brokenProperties, this.properties[key]);
      }

      brokenTypes = Object.keys(brokenTypes).filter(function (name) {
        return brokenTypes[name];
      });
      brokenProperties = Object.keys(brokenProperties).filter(function (name) {
        return brokenProperties[name];
      });

      if (brokenTypes.length || brokenProperties.length) {
        return {
          types: brokenTypes,
          properties: brokenProperties
        };
      }

      return null;
    },
    dump: function dump(syntaxAsAst) {
      return {
        generic: this.generic,
        types: dumpMapSyntax(this.types, syntaxAsAst),
        properties: dumpMapSyntax(this.properties, syntaxAsAst)
      };
    },
    toString: function toString() {
      return JSON.stringify(this.dump());
    }
  };
  module.exports = Lexer;
  /***/
},
/* 60 */

/***/
function (module, exports, __webpack_require__) {
  ;

  var createCustomError = __webpack_require__(56);

  var generateGrammar = __webpack_require__(61);

  function fromMatchResult(matchResult) {
    var tokens = matchResult.tokens;
    var longestMatch = matchResult.longestMatch;
    var node = longestMatch < tokens.length ? tokens[longestMatch].node : null;
    var mismatchOffset = 0;
    var entries = 0;
    var css = '';

    for (var i = 0; i < tokens.length; i++) {
      if (i === longestMatch) {
        mismatchOffset = css.length;
      }

      if (node !== null && tokens[i].node === node) {
        if (i <= longestMatch) {
          entries++;
        } else {
          entries = 0;
        }
      }

      css += tokens[i].value;
    }

    if (node === null) {
      mismatchOffset = css.length;
    }

    return {
      node: node,
      css: css,
      mismatchOffset: mismatchOffset,
      last: node === null || entries > 1
    };
  }

  function getLocation(node, point) {
    var loc = node && node.loc && node.loc[point];

    if (loc) {
      return {
        offset: loc.offset,
        line: loc.line,
        column: loc.column
      };
    }

    return null;
  }

  var SyntaxReferenceError = function SyntaxReferenceError(type, referenceName) {
    var error = createCustomError('SyntaxReferenceError', type + (referenceName ? ' `' + referenceName + '`' : ''));
    error.reference = referenceName;
    return error;
  };

  var MatchError = function MatchError(message, lexer, syntax, node, matchResult) {
    var error = createCustomError('SyntaxMatchError', message);
    var details = fromMatchResult(matchResult);
    var mismatchOffset = details.mismatchOffset || 0;
    var badNode = details.node || node;
    var end = getLocation(badNode, 'end');
    var start = details.last ? end : getLocation(badNode, 'start');
    var css = details.css;
    error.rawMessage = message;
    error.syntax = syntax ? generateGrammar(syntax) : '<generic>';
    error.css = css;
    error.mismatchOffset = mismatchOffset;
    error.loc = {
      source: badNode && badNode.loc && badNode.loc.source || '<unknown>',
      start: start,
      end: end
    };
    error.line = start ? start.line : undefined;
    error.column = start ? start.column : undefined;
    error.offset = start ? start.offset : undefined;
    error.message = message + '\n' + '  syntax: ' + error.syntax + '\n' + '   value: ' + (error.css || '<empty string>') + '\n' + '  --------' + new Array(error.mismatchOffset + 1).join('-') + '^';
    return error;
  };

  module.exports = {
    SyntaxReferenceError: SyntaxReferenceError,
    MatchError: MatchError
  };
  /***/
},
/* 61 */

/***/
function (module, exports) {
  function noop(value) {
    return value;
  }

  function generateMultiplier(multiplier) {
    if (multiplier.min === 0 && multiplier.max === 0) {
      return '*';
    }

    if (multiplier.min === 0 && multiplier.max === 1) {
      return '?';
    }

    if (multiplier.min === 1 && multiplier.max === 0) {
      return multiplier.comma ? '#' : '+';
    }

    if (multiplier.min === 1 && multiplier.max === 1) {
      return '';
    }

    return (multiplier.comma ? '#' : '') + (multiplier.min === multiplier.max ? '{' + multiplier.min + '}' : '{' + multiplier.min + ',' + (multiplier.max !== 0 ? multiplier.max : '') + '}');
  }

  function generateSequence(node, forceBraces, decorate) {
    var result = node.terms.map(function (term) {
      return generate(term, forceBraces, decorate);
    }).join(node.combinator === ' ' ? ' ' : ' ' + node.combinator + ' ');

    if (node.explicit || forceBraces) {
      result = (result[0] !== ',' ? '[ ' : '[') + result + ' ]';
    }

    return result;
  }

  function generate(node, forceBraces, decorate) {
    var result;

    switch (node.type) {
      case 'Group':
        result = generateSequence(node, forceBraces, decorate) + (node.disallowEmpty ? '!' : '');
        break;

      case 'Multiplier':
        // return since node is a composition
        return generate(node.term, forceBraces, decorate) + decorate(generateMultiplier(node), node);

      case 'Type':
        result = '<' + node.name + '>';
        break;

      case 'Property':
        result = '<\'' + node.name + '\'>';
        break;

      case 'Keyword':
        result = node.name;
        break;

      case 'AtKeyword':
        result = '@' + node.name;
        break;

      case 'Function':
        result = node.name + '(';
        break;

      case 'String':
      case 'Token':
        result = node.value;
        break;

      case 'Comma':
        result = ',';
        break;

      default:
        throw new Error('Unknown node type `' + node.type + '`');
    }

    return decorate(result, node);
  }

  module.exports = function (node, options) {
    var decorate = noop;
    var forceBraces = false;

    if (typeof options === 'function') {
      decorate = options;
    } else if (options) {
      forceBraces = Boolean(options.forceBraces);

      if (typeof options.decorate === 'function') {
        decorate = options.decorate;
      }
    }

    return generate(node, forceBraces, decorate);
  };
  /***/

},
/* 62 */

/***/
function (module, exports, __webpack_require__) {
  ;

  var hasOwnProperty = Object.prototype.hasOwnProperty;
  var keywords = Object.create(null);
  var properties = Object.create(null);
  var HYPHENMINUS = 45; // '-'.charCodeAt()

  function isCustomProperty(str, offset) {
    offset = offset || 0;
    return str.length - offset >= 2 && str.charCodeAt(offset) === HYPHENMINUS && str.charCodeAt(offset + 1) === HYPHENMINUS;
  }

  function getVendorPrefix(str, offset) {
    offset = offset || 0; // verdor prefix should be at least 3 chars length

    if (str.length - offset >= 3) {
      // vendor prefix starts with hyper minus following non-hyper minus
      if (str.charCodeAt(offset) === HYPHENMINUS && str.charCodeAt(offset + 1) !== HYPHENMINUS) {
        // vendor prefix should contain a hyper minus at the ending
        var secondDashIndex = str.indexOf('-', offset + 2);

        if (secondDashIndex !== -1) {
          return str.substring(offset, secondDashIndex + 1);
        }
      }
    }

    return '';
  }

  function getKeywordDescriptor(keyword) {
    if (hasOwnProperty.call(keywords, keyword)) {
      return keywords[keyword];
    }

    var name = keyword.toLowerCase();

    if (hasOwnProperty.call(keywords, name)) {
      return keywords[keyword] = keywords[name];
    }

    var custom = isCustomProperty(name, 0);
    var vendor = !custom ? getVendorPrefix(name, 0) : '';
    return keywords[keyword] = Object.freeze({
      basename: name.substr(vendor.length),
      name: name,
      vendor: vendor,
      prefix: vendor,
      custom: custom
    });
  }

  function getPropertyDescriptor(property) {
    if (hasOwnProperty.call(properties, property)) {
      return properties[property];
    }

    var name = property;
    var hack = property[0];

    if (hack === '/') {
      hack = property[1] === '/' ? '//' : '/';
    } else if (hack !== '_' && hack !== '*' && hack !== '$' && hack !== '#' && hack !== '+') {
      hack = '';
    }

    var custom = isCustomProperty(name, hack.length); // re-use result when possible (the same as for lower case)

    if (!custom) {
      name = name.toLowerCase();

      if (hasOwnProperty.call(properties, name)) {
        return properties[property] = properties[name];
      }
    }

    var vendor = !custom ? getVendorPrefix(name, hack.length) : '';
    var prefix = name.substr(0, hack.length + vendor.length);
    return properties[property] = Object.freeze({
      basename: name.substr(prefix.length),
      name: name.substr(hack.length),
      hack: hack,
      vendor: vendor,
      prefix: prefix,
      custom: custom
    });
  }

  module.exports = {
    keyword: getKeywordDescriptor,
    property: getPropertyDescriptor,
    isCustomProperty: isCustomProperty,
    vendorPrefix: getVendorPrefix
  };
  /***/
},
/* 63 */

/***/
function (module, exports, __webpack_require__) {
  var tokenizerUtils = __webpack_require__(58);

  var findIdentifierEnd = tokenizerUtils.findIdentifierEnd;
  var findNumberEnd = tokenizerUtils.findNumberEnd;
  var findDecimalNumberEnd = tokenizerUtils.findDecimalNumberEnd;
  var isHex = tokenizerUtils.isHex;

  var tokenizerConst = __webpack_require__(57);

  var SYMBOL_TYPE = tokenizerConst.SYMBOL_TYPE;
  var IDENTIFIER = tokenizerConst.TYPE.Identifier;
  var PLUSSIGN = tokenizerConst.TYPE.PlusSign;
  var HYPHENMINUS = tokenizerConst.TYPE.HyphenMinus;
  var NUMBERSIGN = tokenizerConst.TYPE.NumberSign;
  var PERCENTAGE = {
    '%': true
  }; // https://www.w3.org/TR/css-values-3/#lengths

  var LENGTH = {
    // absolute length units
    'px': true,
    'mm': true,
    'cm': true,
    'in': true,
    'pt': true,
    'pc': true,
    'q': true,
    // relative length units
    'em': true,
    'ex': true,
    'ch': true,
    'rem': true,
    // viewport-percentage lengths
    'vh': true,
    'vw': true,
    'vmin': true,
    'vmax': true,
    'vm': true
  };
  var ANGLE = {
    'deg': true,
    'grad': true,
    'rad': true,
    'turn': true
  };
  var TIME = {
    's': true,
    'ms': true
  };
  var FREQUENCY = {
    'hz': true,
    'khz': true
  }; // https://www.w3.org/TR/css-values-3/#resolution (https://drafts.csswg.org/css-values/#resolution)

  var RESOLUTION = {
    'dpi': true,
    'dpcm': true,
    'dppx': true,
    'x': true // https://github.com/w3c/csswg-drafts/issues/461

  }; // https://drafts.csswg.org/css-grid/#fr-unit

  var FLEX = {
    'fr': true
  }; // https://www.w3.org/TR/css3-speech/#mixing-props-voice-volume

  var DECIBEL = {
    'db': true
  }; // https://www.w3.org/TR/css3-speech/#voice-props-voice-pitch

  var SEMITONES = {
    'st': true
  };

  function consumeFunction(token, addTokenToMatch, getNextToken) {
    var length = 1;
    var cursor;

    do {
      cursor = getNextToken(length++);
    } while (cursor !== null && cursor.node !== token.node);

    if (cursor === null) {
      return false;
    }

    while (true) {
      // consume tokens until cursor
      if (addTokenToMatch() === cursor) {
        break;
      }
    }

    return true;
  } // TODO: implement
  // can be used wherever <length>, <frequency>, <angle>, <time>, <percentage>, <number>, or <integer> values are allowed
  // https://drafts.csswg.org/css-values/#calc-notation


  function calc(token, addTokenToMatch, getNextToken) {
    if (token === null) {
      return false;
    }

    var name = token.value.toLowerCase();

    if (name !== 'calc(' && name !== '-moz-calc(' && name !== '-webkit-calc(') {
      return false;
    }

    return consumeFunction(token, addTokenToMatch, getNextToken);
  }

  function attr(token, addTokenToMatch, getNextToken) {
    if (token === null || token.value.toLowerCase() !== 'attr(') {
      return false;
    }

    return consumeFunction(token, addTokenToMatch, getNextToken);
  }

  function expression(token, addTokenToMatch, getNextToken) {
    if (token === null || token.value.toLowerCase() !== 'expression(') {
      return false;
    }

    return consumeFunction(token, addTokenToMatch, getNextToken);
  }

  function url(token, addTokenToMatch, getNextToken) {
    if (token === null || token.value.toLowerCase() !== 'url(') {
      return false;
    }

    return consumeFunction(token, addTokenToMatch, getNextToken);
  }

  function idSelector(token, addTokenToMatch) {
    if (token === null) {
      return false;
    }

    if (token.value.charCodeAt(0) !== NUMBERSIGN) {
      return false;
    }

    if (consumeIdentifier(token.value, 1) !== token.value.length) {
      return false;
    }

    addTokenToMatch();
    return true;
  }

  function isNumber(str) {
    return /^[-+]?(\d+|\d*\.\d+)([eE][-+]?\d+)?$/.test(str);
  }

  function consumeNumber(str, allowFraction) {
    var code = str.charCodeAt(0);
    return findNumberEnd(str, code === PLUSSIGN || code === HYPHENMINUS ? 1 : 0, allowFraction);
  }

  function consumeIdentifier(str, offset) {
    var code = str.charCodeAt(offset);

    if (code < 0x80 && SYMBOL_TYPE[code] !== IDENTIFIER && code !== HYPHENMINUS) {
      return offset;
    }

    return findIdentifierEnd(str, offset + 1);
  }

  function astNode(type) {
    return function (token, addTokenToMatch) {
      if (token === null || token.node.type !== type) {
        return false;
      }

      addTokenToMatch();
      return true;
    };
  }

  function dimension(type) {
    return function (token, addTokenToMatch, getNextToken) {
      if (calc(token, addTokenToMatch, getNextToken)) {
        return true;
      }

      if (token === null) {
        return false;
      }

      var numberEnd = consumeNumber(token.value, true);

      if (numberEnd === 0) {
        return false;
      }

      if (type) {
        if (!type.hasOwnProperty(token.value.substr(numberEnd).toLowerCase())) {
          return false;
        }
      } else {
        var unitEnd = consumeIdentifier(token.value, numberEnd);

        if (unitEnd === numberEnd || unitEnd !== token.value.length) {
          return false;
        }
      }

      addTokenToMatch();
      return true;
    };
  }

  function zeroUnitlessDimension(type) {
    var isDimension = dimension(type);
    return function (token, addTokenToMatch, getNextToken) {
      if (isDimension(token, addTokenToMatch, getNextToken)) {
        return true;
      }

      if (token === null || Number(token.value) !== 0) {
        return false;
      }

      addTokenToMatch();
      return true;
    };
  }

  function number(token, addTokenToMatch, getNextToken) {
    if (calc(token, addTokenToMatch, getNextToken)) {
      return true;
    }

    if (token === null) {
      return false;
    }

    var numberEnd = consumeNumber(token.value, true);

    if (numberEnd !== token.value.length) {
      return false;
    }

    addTokenToMatch();
    return true;
  }

  function numberZeroOne(token, addTokenToMatch, getNextToken) {
    if (calc(token, addTokenToMatch, getNextToken)) {
      return true;
    }

    if (token === null || !isNumber(token.value)) {
      return false;
    }

    var value = Number(token.value);

    if (value < 0 || value > 1) {
      return false;
    }

    addTokenToMatch();
    return true;
  }

  function numberOneOrGreater(token, addTokenToMatch, getNextToken) {
    if (calc(token, addTokenToMatch, getNextToken)) {
      return true;
    }

    if (token === null || !isNumber(token.value)) {
      return false;
    }

    var value = Number(token.value);

    if (value < 1) {
      return false;
    }

    addTokenToMatch();
    return true;
  } // TODO: fail on 10e-2


  function integer(token, addTokenToMatch, getNextToken) {
    if (calc(token, addTokenToMatch, getNextToken)) {
      return true;
    }

    if (token === null) {
      return false;
    }

    var numberEnd = consumeNumber(token.value, false);

    if (numberEnd !== token.value.length) {
      return false;
    }

    addTokenToMatch();
    return true;
  } // TODO: fail on 10e-2


  function positiveInteger(token, addTokenToMatch, getNextToken) {
    if (calc(token, addTokenToMatch, getNextToken)) {
      return true;
    }

    if (token === null) {
      return false;
    }

    var numberEnd = findDecimalNumberEnd(token.value, 0);

    if (numberEnd !== token.value.length || token.value.charCodeAt(0) === HYPHENMINUS) {
      return false;
    }

    addTokenToMatch();
    return true;
  }

  function hexColor(token, addTokenToMatch) {
    if (token === null || token.value.charCodeAt(0) !== NUMBERSIGN) {
      return false;
    }

    var length = token.value.length - 1; // valid length is 3, 4, 6 and 8 (+1 for #)

    if (length !== 3 && length !== 4 && length !== 6 && length !== 8) {
      return false;
    }

    for (var i = 1; i < length; i++) {
      if (!isHex(token.value.charCodeAt(i))) {
        return false;
      }
    }

    addTokenToMatch();
    return true;
  } // https://developer.mozilla.org/en-US/docs/Web/CSS/custom-ident
  // https://drafts.csswg.org/css-values-4/#identifier-value


  function customIdent(token, addTokenToMatch) {
    if (token === null) {
      return false;
    }

    var identEnd = consumeIdentifier(token.value, 0);

    if (identEnd !== token.value.length) {
      return false;
    }

    var name = token.value.toLowerCase(); // § 3.2. Author-defined Identifiers: the <custom-ident> type
    // The CSS-wide keywords are not valid <custom-ident>s

    if (name === 'unset' || name === 'initial' || name === 'inherit') {
      return false;
    } // The default keyword is reserved and is also not a valid <custom-ident>


    if (name === 'default') {
      return false;
    } // TODO: ignore property specific keywords (as described https://developer.mozilla.org/en-US/docs/Web/CSS/custom-ident)


    addTokenToMatch();
    return true;
  }

  module.exports = {
    'angle': zeroUnitlessDimension(ANGLE),
    'attr()': attr,
    'custom-ident': customIdent,
    'decibel': dimension(DECIBEL),
    'dimension': dimension(),
    'frequency': dimension(FREQUENCY),
    'flex': dimension(FLEX),
    'hex-color': hexColor,
    'id-selector': idSelector,
    // element( <id-selector> )
    'ident': astNode('Identifier'),
    'integer': integer,
    'length': zeroUnitlessDimension(LENGTH),
    'number': number,
    'number-zero-one': numberZeroOne,
    'number-one-or-greater': numberOneOrGreater,
    'percentage': dimension(PERCENTAGE),
    'positive-integer': positiveInteger,
    'resolution': dimension(RESOLUTION),
    'semitones': dimension(SEMITONES),
    'string': astNode('String'),
    'time': dimension(TIME),
    'unicode-range': astNode('UnicodeRange'),
    'url': url,
    // old IE stuff
    'progid': astNode('Raw'),
    'expression': expression
  };
  /***/
},
/* 64 */

/***/
function (module, exports, __webpack_require__) {
  var Tokenizer = __webpack_require__(65);

  var TAB = 9;
  var N = 10;
  var F = 12;
  var R = 13;
  var SPACE = 32;
  var EXCLAMATIONMARK = 33; // !

  var NUMBERSIGN = 35; // #

  var AMPERSAND = 38; // &

  var APOSTROPHE = 39; // '

  var LEFTPARENTHESIS = 40; // (

  var RIGHTPARENTHESIS = 41; // )

  var ASTERISK = 42; // *

  var PLUSSIGN = 43; // +

  var COMMA = 44; // ,

  var LESSTHANSIGN = 60; // <

  var GREATERTHANSIGN = 62; // >

  var QUESTIONMARK = 63; // ?

  var COMMERCIALAT = 64; // @

  var LEFTSQUAREBRACKET = 91; // [

  var RIGHTSQUAREBRACKET = 93; // ]

  var LEFTCURLYBRACKET = 123; // {

  var VERTICALLINE = 124; // |

  var RIGHTCURLYBRACKET = 125; // }

  var NAME_CHAR = createCharMap(function (ch) {
    return /[a-zA-Z0-9\-]/.test(ch);
  });
  var COMBINATOR_PRECEDENCE = {
    ' ': 1,
    '&&': 2,
    '||': 3,
    '|': 4
  };

  function createCharMap(fn) {
    var array = typeof Uint32Array === 'function' ? new Uint32Array(128) : new Array(128);

    for (var i = 0; i < 128; i++) {
      array[i] = fn(String.fromCharCode(i)) ? 1 : 0;
    }

    return array;
  }

  function scanSpaces(tokenizer) {
    return tokenizer.substringToPos(tokenizer.findWsEnd(tokenizer.pos + 1));
  }

  function scanWord(tokenizer) {
    var end = tokenizer.pos;

    for (; end < tokenizer.str.length; end++) {
      var code = tokenizer.str.charCodeAt(end);

      if (code >= 128 || NAME_CHAR[code] === 0) {
        break;
      }
    }

    if (tokenizer.pos === end) {
      tokenizer.error('Expect a keyword');
    }

    return tokenizer.substringToPos(end);
  }

  function scanNumber(tokenizer) {
    var end = tokenizer.pos;

    for (; end < tokenizer.str.length; end++) {
      var code = tokenizer.str.charCodeAt(end);

      if (code < 48 || code > 57) {
        break;
      }
    }

    if (tokenizer.pos === end) {
      tokenizer.error('Expect a number');
    }

    return tokenizer.substringToPos(end);
  }

  function scanString(tokenizer) {
    var end = tokenizer.str.indexOf('\'', tokenizer.pos + 1);

    if (end === -1) {
      tokenizer.pos = tokenizer.str.length;
      tokenizer.error('Expect an apostrophe');
    }

    return tokenizer.substringToPos(end + 1);
  }

  function readMultiplierRange(tokenizer) {
    var min = null;
    var max = null;
    tokenizer.eat(LEFTCURLYBRACKET);
    min = scanNumber(tokenizer);

    if (tokenizer.charCode() === COMMA) {
      tokenizer.pos++;

      if (tokenizer.charCode() !== RIGHTCURLYBRACKET) {
        max = scanNumber(tokenizer);
      }
    } else {
      max = min;
    }

    tokenizer.eat(RIGHTCURLYBRACKET);
    return {
      min: Number(min),
      max: max ? Number(max) : 0
    };
  }

  function readMultiplier(tokenizer) {
    var range = null;
    var comma = false;

    switch (tokenizer.charCode()) {
      case ASTERISK:
        tokenizer.pos++;
        range = {
          min: 0,
          max: 0
        };
        break;

      case PLUSSIGN:
        tokenizer.pos++;
        range = {
          min: 1,
          max: 0
        };
        break;

      case QUESTIONMARK:
        tokenizer.pos++;
        range = {
          min: 0,
          max: 1
        };
        break;

      case NUMBERSIGN:
        tokenizer.pos++;
        comma = true;

        if (tokenizer.charCode() === LEFTCURLYBRACKET) {
          range = readMultiplierRange(tokenizer);
        } else {
          range = {
            min: 1,
            max: 0
          };
        }

        break;

      case LEFTCURLYBRACKET:
        range = readMultiplierRange(tokenizer);
        break;

      default:
        return null;
    }

    return {
      type: 'Multiplier',
      comma: comma,
      min: range.min,
      max: range.max,
      term: null
    };
  }

  function maybeMultiplied(tokenizer, node) {
    var multiplier = readMultiplier(tokenizer);

    if (multiplier !== null) {
      multiplier.term = node;
      return multiplier;
    }

    return node;
  }

  function maybeToken(tokenizer) {
    var ch = tokenizer.peek();

    if (ch === '') {
      return null;
    }

    return {
      type: 'Token',
      value: ch
    };
  }

  function readProperty(tokenizer) {
    var name;
    tokenizer.eat(LESSTHANSIGN);
    tokenizer.eat(APOSTROPHE);
    name = scanWord(tokenizer);
    tokenizer.eat(APOSTROPHE);
    tokenizer.eat(GREATERTHANSIGN);
    return maybeMultiplied(tokenizer, {
      type: 'Property',
      name: name
    });
  }

  function readType(tokenizer) {
    var name;
    tokenizer.eat(LESSTHANSIGN);
    name = scanWord(tokenizer);

    if (tokenizer.charCode() === LEFTPARENTHESIS && tokenizer.nextCharCode() === RIGHTPARENTHESIS) {
      tokenizer.pos += 2;
      name += '()';
    }

    tokenizer.eat(GREATERTHANSIGN);
    return maybeMultiplied(tokenizer, {
      type: 'Type',
      name: name
    });
  }

  function readKeywordOrFunction(tokenizer) {
    var name;
    name = scanWord(tokenizer);

    if (tokenizer.charCode() === LEFTPARENTHESIS) {
      tokenizer.pos++;
      return {
        type: 'Function',
        name: name
      };
    }

    return maybeMultiplied(tokenizer, {
      type: 'Keyword',
      name: name
    });
  }

  function regroupTerms(terms, combinators) {
    function createGroup(terms, combinator) {
      return {
        type: 'Group',
        terms: terms,
        combinator: combinator,
        disallowEmpty: false,
        explicit: false
      };
    }

    combinators = Object.keys(combinators).sort(function (a, b) {
      return COMBINATOR_PRECEDENCE[a] - COMBINATOR_PRECEDENCE[b];
    });

    while (combinators.length > 0) {
      var combinator = combinators.shift();

      for (var i = 0, subgroupStart = 0; i < terms.length; i++) {
        var term = terms[i];

        if (term.type === 'Combinator') {
          if (term.value === combinator) {
            if (subgroupStart === -1) {
              subgroupStart = i - 1;
            }

            terms.splice(i, 1);
            i--;
          } else {
            if (subgroupStart !== -1 && i - subgroupStart > 1) {
              terms.splice(subgroupStart, i - subgroupStart, createGroup(terms.slice(subgroupStart, i), combinator));
              i = subgroupStart + 1;
            }

            subgroupStart = -1;
          }
        }
      }

      if (subgroupStart !== -1 && combinators.length) {
        terms.splice(subgroupStart, i - subgroupStart, createGroup(terms.slice(subgroupStart, i), combinator));
      }
    }

    return combinator;
  }

  function readImplicitGroup(tokenizer) {
    var terms = [];
    var combinators = {};
    var token;
    var prevToken = null;
    var prevTokenPos = tokenizer.pos;

    while (token = peek(tokenizer)) {
      if (token.type !== 'Spaces') {
        if (token.type === 'Combinator') {
          // check for combinator in group beginning and double combinator sequence
          if (prevToken === null || prevToken.type === 'Combinator') {
            tokenizer.pos = prevTokenPos;
            tokenizer.error('Unexpected combinator');
          }

          combinators[token.value] = true;
        } else if (prevToken !== null && prevToken.type !== 'Combinator') {
          combinators[' '] = true; // a b

          terms.push({
            type: 'Combinator',
            value: ' '
          });
        }

        terms.push(token);
        prevToken = token;
        prevTokenPos = tokenizer.pos;
      }
    } // check for combinator in group ending


    if (prevToken !== null && prevToken.type === 'Combinator') {
      tokenizer.pos -= prevTokenPos;
      tokenizer.error('Unexpected combinator');
    }

    return {
      type: 'Group',
      terms: terms,
      combinator: regroupTerms(terms, combinators) || ' ',
      disallowEmpty: false,
      explicit: false
    };
  }

  function readGroup(tokenizer) {
    var result;
    tokenizer.eat(LEFTSQUAREBRACKET);
    result = readImplicitGroup(tokenizer);
    tokenizer.eat(RIGHTSQUAREBRACKET);
    result.explicit = true;

    if (tokenizer.charCode() === EXCLAMATIONMARK) {
      tokenizer.pos++;
      result.disallowEmpty = true;
    }

    return result;
  }

  function peek(tokenizer) {
    var code = tokenizer.charCode();

    if (code < 128 && NAME_CHAR[code] === 1) {
      return readKeywordOrFunction(tokenizer);
    }

    switch (code) {
      case RIGHTSQUAREBRACKET:
        // don't eat, stop scan a group
        break;

      case LEFTSQUAREBRACKET:
        return maybeMultiplied(tokenizer, readGroup(tokenizer));

      case LESSTHANSIGN:
        return tokenizer.nextCharCode() === APOSTROPHE ? readProperty(tokenizer) : readType(tokenizer);

      case VERTICALLINE:
        return {
          type: 'Combinator',
          value: tokenizer.substringToPos(tokenizer.nextCharCode() === VERTICALLINE ? tokenizer.pos + 2 : tokenizer.pos + 1)
        };

      case AMPERSAND:
        tokenizer.pos++;
        tokenizer.eat(AMPERSAND);
        return {
          type: 'Combinator',
          value: '&&'
        };

      case COMMA:
        tokenizer.pos++;
        return {
          type: 'Comma'
        };

      case APOSTROPHE:
        return maybeMultiplied(tokenizer, {
          type: 'String',
          value: scanString(tokenizer)
        });

      case SPACE:
      case TAB:
      case N:
      case R:
      case F:
        return {
          type: 'Spaces',
          value: scanSpaces(tokenizer)
        };

      case COMMERCIALAT:
        code = tokenizer.nextCharCode();

        if (code < 128 && NAME_CHAR[code] === 1) {
          tokenizer.pos++;
          return {
            type: 'AtKeyword',
            name: scanWord(tokenizer)
          };
        }

        return maybeToken(tokenizer);

      case ASTERISK:
      case PLUSSIGN:
      case QUESTIONMARK:
      case NUMBERSIGN:
      case EXCLAMATIONMARK:
        // prohibited tokens (used as a multiplier start)
        break;

      case LEFTCURLYBRACKET:
        // LEFTCURLYBRACKET is allowed since mdn/data uses it w/o quoting
        // check next char isn't a number, because it's likely a disjoined multiplier
        code = tokenizer.nextCharCode();

        if (code < 48 || code > 57) {
          return maybeToken(tokenizer);
        }

        break;

      default:
        return maybeToken(tokenizer);
    }
  }

  function parse(str) {
    var tokenizer = new Tokenizer(str);
    var result = readImplicitGroup(tokenizer);

    if (tokenizer.pos !== str.length) {
      tokenizer.error('Unexpected input');
    } // reduce redundant groups with single group term


    if (result.terms.length === 1 && result.terms[0].type === 'Group') {
      result = result.terms[0];
    }

    return result;
  } // warm up parse to elimitate code branches that never execute
  // fix soft deoptimizations (insufficient type feedback)


  parse('[a&&<b>#|<\'c\'>*||e() f{2} /,(% g#{1,2} h{2,})]!');
  module.exports = parse;
  /***/
},
/* 65 */

/***/
function (module, exports, __webpack_require__) {
  var SyntaxParseError = __webpack_require__(66).SyntaxParseError;

  var TAB = 9;
  var N = 10;
  var F = 12;
  var R = 13;
  var SPACE = 32;

  var Tokenizer = function Tokenizer(str) {
    this.str = str;
    this.pos = 0;
  };

  Tokenizer.prototype = {
    charCodeAt: function charCodeAt(pos) {
      return pos < this.str.length ? this.str.charCodeAt(pos) : 0;
    },
    charCode: function charCode() {
      return this.charCodeAt(this.pos);
    },
    nextCharCode: function nextCharCode() {
      return this.charCodeAt(this.pos + 1);
    },
    nextNonWsCode: function nextNonWsCode(pos) {
      return this.charCodeAt(this.findWsEnd(pos));
    },
    findWsEnd: function findWsEnd(pos) {
      for (; pos < this.str.length; pos++) {
        var code = this.str.charCodeAt(pos);

        if (code !== R && code !== N && code !== F && code !== SPACE && code !== TAB) {
          break;
        }
      }

      return pos;
    },
    substringToPos: function substringToPos(end) {
      return this.str.substring(this.pos, this.pos = end);
    },
    eat: function eat(code) {
      if (this.charCode() !== code) {
        this.error('Expect `' + String.fromCharCode(code) + '`');
      }

      this.pos++;
    },
    peek: function peek() {
      return this.pos < this.str.length ? this.str.charAt(this.pos++) : '';
    },
    error: function error(message) {
      throw new SyntaxParseError(message, this.str, this.pos);
    }
  };
  module.exports = Tokenizer;
  /***/
},
/* 66 */

/***/
function (module, exports, __webpack_require__) {
  var createCustomError = __webpack_require__(56);

  var SyntaxParseError = function SyntaxParseError(message, input, offset) {
    var error = createCustomError('SyntaxParseError', message);
    error.input = input;
    error.offset = offset;
    error.rawMessage = message;
    error.message = error.rawMessage + '\n' + '  ' + error.input + '\n' + '--' + new Array((error.offset || error.input.length) + 1).join('-') + '^';
    return error;
  };

  module.exports = {
    SyntaxParseError: SyntaxParseError
  };
  /***/
},
/* 67 */

/***/
function (module, exports, __webpack_require__) {
  ;

  var noop = function noop() {};

  function ensureFunction(value) {
    return typeof value === 'function' ? value : noop;
  }

  module.exports = function (node, options, context) {
    function walk(node) {
      enter.call(context, node);

      switch (node.type) {
        case 'Group':
          node.terms.forEach(walk);
          break;

        case 'Multiplier':
          walk(node.term);
          break;

        case 'Type':
        case 'Property':
        case 'Keyword':
        case 'AtKeyword':
        case 'Function':
        case 'String':
        case 'Token':
        case 'Comma':
          break;

        default:
          throw new Error('Unknown type: ' + node.type);
      }

      leave.call(context, node);
    }

    var enter = noop;
    var leave = noop;

    if (typeof options === 'function') {
      enter = options;
    } else if (options) {
      enter = ensureFunction(options.enter);
      leave = ensureFunction(options.leave);
    }

    if (enter === noop && leave === noop) {
      throw new Error('Neither `enter` nor `leave` walker handler is set or both aren\'t a function');
    }

    walk(node, context);
  };
  /***/

},
/* 68 */

/***/
function (module, exports) {
  module.exports = {
    decorator: function decorator(handlers) {
      var curNode = null;
      var prev = null;
      var tokens = [];
      return {
        children: handlers.children,
        node: function node(_node) {
          var tmp = curNode;
          curNode = _node;
          handlers.node.call(this, _node);
          curNode = tmp;
        },
        chunk: function chunk(_chunk) {
          if (tokens.length > 0) {
            switch (curNode.type) {
              case 'Dimension':
              case 'HexColor':
              case 'IdSelector':
              case 'Percentage':
                if (prev.node === curNode) {
                  prev.value += _chunk;
                  return;
                }

                break;

              case 'Function':
              case 'PseudoClassSelector':
              case 'PseudoElementSelector':
              case 'Url':
                if (_chunk === '(') {
                  prev.value += _chunk;
                  return;
                }

                break;

              case 'Atrule':
                if (prev.node === curNode && prev.value === '@') {
                  prev.value += _chunk;
                  return;
                }

                break;
            }
          }

          tokens.push(prev = {
            value: _chunk,
            node: curNode
          });
        },
        result: function result() {
          return tokens;
        }
      };
    }
  };
  /***/
},
/* 69 */

/***/
function (module, exports, __webpack_require__) {
  var parse = __webpack_require__(64);

  var MATCH = {
    type: 'Match'
  };
  var MISMATCH = {
    type: 'Mismatch'
  };
  var DISALLOW_EMPTY = {
    type: 'DisallowEmpty'
  };
  var LEFTPARENTHESIS = 40; // (

  var RIGHTPARENTHESIS = 41; // )

  function createCondition(match, thenBranch, elseBranch) {
    // reduce node count
    if (thenBranch === MATCH && elseBranch === MISMATCH) {
      return match;
    }

    if (match === MATCH && thenBranch === MATCH && elseBranch === MATCH) {
      return match;
    }

    if (match.type === 'If' && match["else"] === MISMATCH && thenBranch === MATCH) {
      thenBranch = match.then;
      match = match.match;
    }

    return {
      type: 'If',
      match: match,
      then: thenBranch,
      "else": elseBranch
    };
  }

  function isFunctionType(name) {
    return name.length > 2 && name.charCodeAt(name.length - 2) === LEFTPARENTHESIS && name.charCodeAt(name.length - 1) === RIGHTPARENTHESIS;
  }

  function isEnumCapatible(term) {
    return term.type === 'Keyword' || term.type === 'AtKeyword' || term.type === 'Function' || term.type === 'Type' && isFunctionType(term.name);
  }

  function buildGroupMatchGraph(combinator, terms, atLeastOneTermMatched) {
    switch (combinator) {
      case ' ':
        // Juxtaposing components means that all of them must occur, in the given order.
        //
        // a b c
        // =
        // match a
        //   then match b
        //     then match c
        //       then MATCH
        //       else MISMATCH
        //     else MISMATCH
        //   else MISMATCH
        var result = MATCH;

        for (var i = terms.length - 1; i >= 0; i--) {
          var term = terms[i];
          result = createCondition(term, result, MISMATCH);
        }

        ;
        return result;

      case '|':
        // A bar (|) separates two or more alternatives: exactly one of them must occur.
        //
        // a | b | c
        // =
        // match a
        //   then MATCH
        //   else match b
        //     then MATCH
        //     else match c
        //       then MATCH
        //       else MISMATCH
        var result = MISMATCH;
        var map = null;

        for (var i = terms.length - 1; i >= 0; i--) {
          var term = terms[i]; // reduce sequence of keywords into a Enum

          if (isEnumCapatible(term)) {
            if (map === null && i > 0 && isEnumCapatible(terms[i - 1])) {
              map = Object.create(null);
              result = createCondition({
                type: 'Enum',
                map: map
              }, MATCH, result);
            }

            if (map !== null) {
              var key = (isFunctionType(term.name) ? term.name.slice(0, -1) : term.name).toLowerCase();

              if (key in map === false) {
                map[key] = term;
                continue;
              }
            }
          }

          map = null; // create a new conditonal node

          result = createCondition(term, MATCH, result);
        }

        ;
        return result;

      case '&&':
        // A double ampersand (&&) separates two or more components,
        // all of which must occur, in any order.
        // Use MatchOnce for groups with a large number of terms,
        // since &&-groups produces at least N!-node trees
        if (terms.length > 5) {
          return {
            type: 'MatchOnce',
            terms: terms,
            all: true
          };
        } // Use a combination tree for groups with small number of terms
        //
        // a && b && c
        // =
        // match a
        //   then [b && c]
        //   else match b
        //     then [a && c]
        //     else match c
        //       then [a && b]
        //       else MISMATCH
        //
        // a && b
        // =
        // match a
        //   then match b
        //     then MATCH
        //     else MISMATCH
        //   else match b
        //     then match a
        //       then MATCH
        //       else MISMATCH
        //     else MISMATCH


        var result = MISMATCH;

        for (var i = terms.length - 1; i >= 0; i--) {
          var term = terms[i];
          var thenClause;

          if (terms.length > 1) {
            thenClause = buildGroupMatchGraph(combinator, terms.filter(function (newGroupTerm) {
              return newGroupTerm !== term;
            }), false);
          } else {
            thenClause = MATCH;
          }

          result = createCondition(term, thenClause, result);
        }

        ;
        return result;

      case '||':
        // A double bar (||) separates two or more options:
        // one or more of them must occur, in any order.
        // Use MatchOnce for groups with a large number of terms,
        // since ||-groups produces at least N!-node trees
        if (terms.length > 5) {
          return {
            type: 'MatchOnce',
            terms: terms,
            all: false
          };
          ;
        } // Use a combination tree for groups with small number of terms
        //
        // a || b || c
        // =
        // match a
        //   then [b || c]
        //   else match b
        //     then [a || c]
        //     else match c
        //       then [a || b]
        //       else MISMATCH
        //
        // a || b
        // =
        // match a
        //   then match b
        //     then MATCH
        //     else MATCH
        //   else match b
        //     then match a
        //       then MATCH
        //       else MATCH
        //     else MISMATCH


        var result = atLeastOneTermMatched ? MATCH : MISMATCH;

        for (var i = terms.length - 1; i >= 0; i--) {
          var term = terms[i];
          var thenClause;

          if (terms.length > 1) {
            thenClause = buildGroupMatchGraph(combinator, terms.filter(function (newGroupTerm) {
              return newGroupTerm !== term;
            }), true);
          } else {
            thenClause = MATCH;
          }

          result = createCondition(term, thenClause, result);
        }

        ;
        return result;
    }
  }

  function buildMultiplierMatchGraph(node) {
    var result = MATCH;

    var matchTerm = _buildMatchGraph(node.term);

    if (node.max === 0) {
      // disable repeating of empty match to prevent infinite loop
      matchTerm = createCondition(matchTerm, DISALLOW_EMPTY, MISMATCH); // an occurrence count is not limited, make a cycle;
      // to collect more terms on each following matching mismatch

      result = createCondition(matchTerm, null, // will be a loop
      MISMATCH);
      result.then = createCondition(MATCH, MATCH, result // make a loop
      );

      if (node.comma) {
        result.then["else"] = createCondition({
          type: 'Comma',
          syntax: node
        }, result, MISMATCH);
      }
    } else {
      // create a match node chain for [min .. max] interval with optional matches
      for (var i = node.min || 1; i <= node.max; i++) {
        if (node.comma && result !== MATCH) {
          result = createCondition({
            type: 'Comma',
            syntax: node
          }, result, MISMATCH);
        }

        result = createCondition(matchTerm, createCondition(MATCH, MATCH, result), MISMATCH);
      }
    }

    if (node.min === 0) {
      // allow zero match
      result = createCondition(MATCH, MATCH, result);
    } else {
      // create a match node chain to collect [0 ... min - 1] required matches
      for (var i = 0; i < node.min - 1; i++) {
        if (node.comma && result !== MATCH) {
          result = createCondition({
            type: 'Comma',
            syntax: node
          }, result, MISMATCH);
        }

        result = createCondition(matchTerm, result, MISMATCH);
      }
    }

    return result;
  }

  function _buildMatchGraph(node) {
    if (typeof node === 'function') {
      return {
        type: 'Generic',
        fn: node
      };
    }

    switch (node.type) {
      case 'Group':
        var result = buildGroupMatchGraph(node.combinator, node.terms.map(_buildMatchGraph), false);

        if (node.disallowEmpty) {
          result = createCondition(result, DISALLOW_EMPTY, MISMATCH);
        }

        return result;

      case 'Multiplier':
        return buildMultiplierMatchGraph(node);

      case 'Type':
      case 'Property':
        return {
          type: node.type,
          name: node.name,
          syntax: node
        };

      case 'Keyword':
        return {
          type: node.type,
          name: node.name.toLowerCase(),
          syntax: node
        };

      case 'AtKeyword':
        return {
          type: node.type,
          name: '@' + node.name.toLowerCase(),
          syntax: node
        };

      case 'Function':
        return {
          type: node.type,
          name: node.name.toLowerCase() + '(',
          syntax: node
        };

      case 'String':
        // convert a one char length String to a Token
        if (node.value.length === 3) {
          return {
            type: 'Token',
            value: node.value.charAt(1),
            syntax: node
          };
        } // otherwise use it as is


        return {
          type: node.type,
          value: node.value,
          syntax: node
        };

      case 'Token':
        return {
          type: node.type,
          value: node.value,
          syntax: node
        };

      case 'Comma':
        return {
          type: node.type,
          syntax: node
        };

      default:
        throw new Error('Unknown node type:', node.type);
    }
  }

  module.exports = {
    MATCH: MATCH,
    MISMATCH: MISMATCH,
    DISALLOW_EMPTY: DISALLOW_EMPTY,
    buildMatchGraph: function buildMatchGraph(syntaxTree, ref) {
      if (typeof syntaxTree === 'string') {
        syntaxTree = parse(syntaxTree);
      }

      return {
        type: 'MatchGraph',
        match: _buildMatchGraph(syntaxTree),
        syntax: ref || null,
        source: syntaxTree
      };
    }
  };
  /***/
},
/* 70 */

/***/
function (module, exports, __webpack_require__) {
  ;

  var hasOwnProperty = Object.prototype.hasOwnProperty;

  var matchGraph = __webpack_require__(69);

  var MATCH = matchGraph.MATCH;
  var MISMATCH = matchGraph.MISMATCH;
  var DISALLOW_EMPTY = matchGraph.DISALLOW_EMPTY;
  var TOKEN = 1;
  var OPEN_SYNTAX = 2;
  var CLOSE_SYNTAX = 3;
  var EXIT_REASON_MATCH = 'Match';
  var EXIT_REASON_MISMATCH = 'Mismatch';
  var EXIT_REASON_ITERATION_LIMIT = 'Maximum iteration number exceeded (please fill an issue on https://github.com/csstree/csstree/issues)';
  var ITERATION_LIMIT = 10000;
  var totalIterationCount = 0;

  function mapList(list, fn) {
    var result = [];

    while (list) {
      result.unshift(fn(list));
      list = list.prev;
    }

    return result;
  }

  function isCommaContextStart(token) {
    if (token === null) {
      return true;
    }

    token = token.value.charAt(token.value.length - 1);
    return token === ',' || token === '(' || token === '[' || token === '/';
  }

  function isCommaContextEnd(token) {
    if (token === null) {
      return true;
    }

    token = token.value.charAt(0);
    return token === ')' || token === ']' || token === '/';
  }

  function internalMatch(tokens, syntax, syntaxes) {
    function moveToNextToken() {
      do {
        tokenCursor++;
        token = tokenCursor < tokens.length ? tokens[tokenCursor] : null;
      } while (token !== null && !/\S/.test(token.value));
    }

    function getNextToken(offset) {
      var nextIndex = tokenCursor + offset;
      return nextIndex < tokens.length ? tokens[nextIndex] : null;
    }

    function pushThenStack(nextSyntax) {
      thenStack = {
        nextSyntax: nextSyntax,
        matchStack: matchStack,
        syntaxStack: syntaxStack,
        prev: thenStack
      };
    }

    function pushElseStack(nextSyntax) {
      elseStack = {
        nextSyntax: nextSyntax,
        matchStack: matchStack,
        syntaxStack: syntaxStack,
        thenStack: thenStack,
        tokenCursor: tokenCursor,
        token: token,
        prev: elseStack
      };
    }

    function addTokenToMatch() {
      matchStack = {
        type: TOKEN,
        syntax: syntax.syntax,
        token: token,
        prev: matchStack
      };
      moveToNextToken();

      if (tokenCursor > longestMatch) {
        longestMatch = tokenCursor;
      }

      return matchStack.token;
    }

    function openSyntax() {
      syntaxStack = {
        syntax: syntax,
        prev: syntaxStack
      };
      matchStack = {
        type: OPEN_SYNTAX,
        syntax: syntax.syntax,
        token: matchStack.token,
        prev: matchStack
      };
    }

    function closeSyntax() {
      if (matchStack.type === OPEN_SYNTAX) {
        matchStack = matchStack.prev;
      } else {
        matchStack = {
          type: CLOSE_SYNTAX,
          syntax: syntaxStack.syntax,
          token: matchStack.token,
          prev: matchStack
        };
      }

      syntaxStack = syntaxStack.prev;
    }

    var syntaxStack = null;
    var thenStack = null;
    var elseStack = null;
    var iterationCount = 0;
    var exitReason = EXIT_REASON_MATCH;
    var matchStack = {
      type: 'Stub',
      syntax: null,
      token: null,
      tokenCursor: -1,
      prev: null
    };
    var longestMatch = 0;
    var tokenCursor = -1;
    var token = null;
    moveToNextToken();

    while (true) {
      // console.log('--\n',
      //     '#' + iterationCount,
      //     require('util').inspect({
      //         match: mapList(matchStack, x => x.type === TOKEN ? x.token && x.token.value : x.syntax ? x.type + '!' + x.syntax.name : null),
      //         elseStack: mapList(elseStack, x => x.id),
      //         thenStack: mapList(thenStack, x => x.id),
      //         token: token && token.value,
      //         tokenCursor,
      //         syntax
      //     }, { depth: null })
      // );
      // prevent infinite loop
      if (++iterationCount === ITERATION_LIMIT) {
        console.warn('[csstree-match] BREAK after ' + ITERATION_LIMIT + ' iterations');
        exitReason = EXIT_REASON_ITERATION_LIMIT;
        break;
      }

      if (syntax === MATCH) {
        if (thenStack === null) {
          // turn to MISMATCH when some tokens left unmatched
          if (token !== null) {
            // doesn't mismatch if just one token left and it's an IE hack
            if (tokenCursor !== tokens.length - 1 || token.value !== '\\0' && token.value !== '\\9') {
              syntax = MISMATCH;
              continue;
            }
          } // break the main loop, return a result - MATCH


          exitReason = EXIT_REASON_MATCH;
          break;
        } // go to next syntax (`then` branch)


        syntax = thenStack.nextSyntax; // check match is not empty

        if (syntax === DISALLOW_EMPTY) {
          if (thenStack.matchStack.token === matchStack.token) {
            syntax = MISMATCH;
            continue;
          } else {
            syntax = MATCH;
          }
        } // close syntax if needed


        while (syntaxStack !== null && thenStack.syntaxStack !== syntaxStack) {
          closeSyntax();
        } // pop stack


        thenStack = thenStack.prev;
        continue;
      }

      if (syntax === MISMATCH) {
        if (elseStack === null) {
          // break the main loop, return a result - MISMATCH
          exitReason = EXIT_REASON_MISMATCH;
          break;
        } // go to next syntax (`else` branch)


        syntax = elseStack.nextSyntax; // restore all the rest stack states

        thenStack = elseStack.thenStack;
        syntaxStack = elseStack.syntaxStack;
        matchStack = elseStack.matchStack;
        tokenCursor = elseStack.tokenCursor;
        token = elseStack.token; // pop stack

        elseStack = elseStack.prev;
        continue;
      }

      switch (syntax.type) {
        case 'MatchGraph':
          syntax = syntax.match;
          break;

        case 'If':
          // IMPORTANT: else stack push must go first,
          // since it stores the state of thenStack before changes
          if (syntax["else"] !== MISMATCH) {
            pushElseStack(syntax["else"]);
          }

          if (syntax.then !== MATCH) {
            pushThenStack(syntax.then);
          }

          syntax = syntax.match;
          break;

        case 'MatchOnce':
          syntax = {
            type: 'MatchOnceBuffer',
            terms: syntax.terms,
            all: syntax.all,
            matchStack: matchStack,
            index: 0,
            mask: 0
          };
          break;

        case 'MatchOnceBuffer':
          if (syntax.index === syntax.terms.length) {
            // if no matches during a cycle
            if (syntax.matchStack === matchStack) {
              // no matches at all or it's required all terms to be matched
              if (syntax.mask === 0 || syntax.all) {
                syntax = MISMATCH;
                break;
              } // a partial match is ok


              syntax = MATCH;
              break;
            } else {
              // start trying to match from the start
              syntax.index = 0;
              syntax.matchStack = matchStack;
            }
          }

          for (; syntax.index < syntax.terms.length; syntax.index++) {
            if ((syntax.mask & 1 << syntax.index) === 0) {
              // IMPORTANT: else stack push must go first,
              // since it stores the state of thenStack before changes
              pushElseStack(syntax);
              pushThenStack({
                type: 'AddMatchOnce',
                buffer: syntax
              }); // match

              syntax = syntax.terms[syntax.index++];
              break;
            }
          }

          break;

        case 'AddMatchOnce':
          syntax = syntax.buffer;
          var newMask = syntax.mask | 1 << syntax.index - 1; // all terms are matched

          if (newMask === (1 << syntax.terms.length) - 1) {
            syntax = MATCH;
            continue;
          }

          syntax = {
            type: 'MatchOnceBuffer',
            terms: syntax.terms,
            all: syntax.all,
            matchStack: syntax.matchStack,
            index: syntax.index,
            mask: newMask
          };
          break;

        case 'Enum':
          var name = token !== null ? token.value.toLowerCase() : ''; // drop \0 and \9 hack from keyword name

          if (name.indexOf('\\') !== -1) {
            name = name.replace(/\\[09].*$/, '');
          }

          if (hasOwnProperty.call(syntax.map, name)) {
            syntax = syntax.map[name];
          } else {
            syntax = MISMATCH;
          }

          break;

        case 'Generic':
          syntax = syntax.fn(token, addTokenToMatch, getNextToken) ? MATCH : MISMATCH;
          break;

        case 'Type':
        case 'Property':
          openSyntax();
          var syntaxDict = syntax.type === 'Type' ? 'types' : 'properties';

          if (hasOwnProperty.call(syntaxes, syntaxDict) && syntaxes[syntaxDict][syntax.name]) {
            syntax = syntaxes[syntaxDict][syntax.name].match;
          } else {
            syntax = undefined;
          }

          if (!syntax) {
            throw new Error('Bad syntax reference: ' + (syntaxStack.syntax.type === 'Type' ? '<' + syntaxStack.syntax.name + '>' : '<\'' + syntaxStack.syntax.name + '\'>'));
          }

          break;

        case 'Keyword':
          var name = syntax.name;

          if (token !== null) {
            var keywordName = token.value; // drop \0 and \9 hack from keyword name

            if (keywordName.indexOf('\\') !== -1) {
              keywordName = keywordName.replace(/\\[09].*$/, '');
            }

            if (keywordName.toLowerCase() === name) {
              addTokenToMatch();
              syntax = MATCH;
              break;
            }
          }

          syntax = MISMATCH;
          break;

        case 'AtKeyword':
        case 'Function':
          if (token !== null && token.value.toLowerCase() === syntax.name) {
            addTokenToMatch();
            syntax = MATCH;
            break;
          }

          syntax = MISMATCH;
          break;

        case 'Token':
          if (token !== null && token.value === syntax.value) {
            addTokenToMatch();
            syntax = MATCH;
            break;
          }

          syntax = MISMATCH;
          break;

        case 'Comma':
          if (token !== null && token.value === ',') {
            if (isCommaContextStart(matchStack.token)) {
              syntax = MISMATCH;
            } else {
              addTokenToMatch();
              syntax = isCommaContextEnd(token) ? MISMATCH : MATCH;
            }
          } else {
            syntax = isCommaContextStart(matchStack.token) || isCommaContextEnd(token) ? MATCH : MISMATCH;
          }

          break;
        // case 'String':
        // TODO: strings with length other than 1 char

        default:
          throw new Error('Unknown node type: ' + syntax.type);
      }
    }

    totalIterationCount += iterationCount;

    if (exitReason === EXIT_REASON_MATCH) {
      while (syntaxStack !== null) {
        closeSyntax();
      }
    } else {
      matchStack = null;
    }

    return {
      tokens: tokens,
      reason: exitReason,
      iterations: iterationCount,
      match: matchStack,
      longestMatch: longestMatch
    };
  }

  function matchAsList(tokens, matchGraph, syntaxes) {
    var matchResult = internalMatch(tokens, matchGraph, syntaxes || {});

    if (matchResult.match !== null) {
      matchResult.match = mapList(matchResult.match, function (item) {
        if (item.type === OPEN_SYNTAX || item.type === CLOSE_SYNTAX) {
          return {
            type: item.type,
            syntax: item.syntax
          };
        }

        return {
          syntax: item.syntax,
          token: item.token && item.token.value,
          node: item.token && item.token.node
        };
      }).slice(1);
    }

    return matchResult;
  }

  function matchAsTree(tokens, matchGraph, syntaxes) {
    var matchResult = internalMatch(tokens, matchGraph, syntaxes || {});

    if (matchResult.match === null) {
      return matchResult;
    }

    var cursor = matchResult.match;
    var host = matchResult.match = {
      syntax: matchGraph.syntax || null,
      match: []
    };
    var stack = [host]; // revert a list

    var prev = null;
    var next = null;

    while (cursor !== null) {
      next = cursor.prev;
      cursor.prev = prev;
      prev = cursor;
      cursor = next;
    } // init the cursor to start with 2nd item since 1st is a stub item


    cursor = prev.prev; // build a tree

    while (cursor !== null && cursor.syntax !== null) {
      var entry = cursor;

      switch (entry.type) {
        case OPEN_SYNTAX:
          host.match.push(host = {
            syntax: entry.syntax,
            match: []
          });
          stack.push(host);
          break;

        case CLOSE_SYNTAX:
          stack.pop();
          host = stack[stack.length - 1];
          break;

        default:
          host.match.push({
            syntax: entry.syntax || null,
            token: entry.token.value,
            node: entry.token.node
          });
      }

      cursor = cursor.prev;
    }

    return matchResult;
  }

  module.exports = {
    matchAsList: matchAsList,
    matchAsTree: matchAsTree,
    getTotalIterationCount: function getTotalIterationCount() {
      return totalIterationCount;
    }
  };
  /***/
},
/* 71 */

/***/
function (module, exports) {
  function getTrace(node) {
    function shouldPutToTrace(syntax) {
      if (syntax === null) {
        return false;
      }

      return syntax.type === 'Type' || syntax.type === 'Property' || syntax.type === 'Keyword';
    }

    function hasMatch(matchNode) {
      if (Array.isArray(matchNode.match)) {
        // use for-loop for better perfomance
        for (var i = 0; i < matchNode.match.length; i++) {
          if (hasMatch(matchNode.match[i])) {
            if (shouldPutToTrace(matchNode.syntax)) {
              result.unshift(matchNode.syntax);
            }

            return true;
          }
        }
      } else if (matchNode.node === node) {
        result = shouldPutToTrace(matchNode.syntax) ? [matchNode.syntax] : [];
        return true;
      }

      return false;
    }

    var result = null;

    if (this.matched !== null) {
      hasMatch(this.matched);
    }

    return result;
  }

  function testNode(match, node, fn) {
    var trace = getTrace.call(match, node);

    if (trace === null) {
      return false;
    }

    return trace.some(fn);
  }

  function isType(node, type) {
    return testNode(this, node, function (matchNode) {
      return matchNode.type === 'Type' && matchNode.name === type;
    });
  }

  function isProperty(node, property) {
    return testNode(this, node, function (matchNode) {
      return matchNode.type === 'Property' && matchNode.name === property;
    });
  }

  function isKeyword(node) {
    return testNode(this, node, function (matchNode) {
      return matchNode.type === 'Keyword';
    });
  }

  module.exports = {
    getTrace: getTrace,
    isType: isType,
    isProperty: isProperty,
    isKeyword: isKeyword
  };
  /***/
},
/* 72 */

/***/
function (module, exports, __webpack_require__) {
  var List = __webpack_require__(52);

  function getFirstMatchNode(matchNode) {
    if ('node' in matchNode) {
      return matchNode.node;
    }

    return getFirstMatchNode(matchNode.match[0]);
  }

  function getLastMatchNode(matchNode) {
    if ('node' in matchNode) {
      return matchNode.node;
    }

    return getLastMatchNode(matchNode.match[matchNode.match.length - 1]);
  }

  function matchFragments(lexer, ast, match, type, name) {
    function findFragments(matchNode) {
      if (matchNode.syntax !== null && matchNode.syntax.type === type && matchNode.syntax.name === name) {
        var start = getFirstMatchNode(matchNode);
        var end = getLastMatchNode(matchNode);
        lexer.syntax.walk(ast, function (node, item, list) {
          if (node === start) {
            var nodes = new List();

            do {
              nodes.appendData(item.data);

              if (item.data === end) {
                break;
              }

              item = item.next;
            } while (item !== null);

            fragments.push({
              parent: list,
              nodes: nodes
            });
          }
        });
      }

      if (Array.isArray(matchNode.match)) {
        matchNode.match.forEach(findFragments);
      }
    }

    var fragments = [];

    if (match.matched !== null) {
      findFragments(match.matched);
    }

    return fragments;
  }

  module.exports = {
    matchFragments: matchFragments
  };
  /***/
},
/* 73 */

/***/
function (module, exports, __webpack_require__) {
  var List = __webpack_require__(52);

  var hasOwnProperty = Object.prototype.hasOwnProperty;

  function isValidNumber(value) {
    // Number.isInteger(value) && value >= 0
    return typeof value === 'number' && isFinite(value) && Math.floor(value) === value && value >= 0;
  }

  function isValidLocation(loc) {
    return Boolean(loc) && isValidNumber(loc.offset) && isValidNumber(loc.line) && isValidNumber(loc.column);
  }

  function createNodeStructureChecker(type, fields) {
    return function checkNode(node, warn) {
      if (!node || node.constructor !== Object) {
        return warn(node, 'Type of node should be an Object');
      }

      for (var key in node) {
        var valid = true;

        if (hasOwnProperty.call(node, key) === false) {
          continue;
        }

        if (key === 'type') {
          if (node.type !== type) {
            warn(node, 'Wrong node type `' + node.type + '`, expected `' + type + '`');
          }
        } else if (key === 'loc') {
          if (node.loc === null) {
            continue;
          } else if (node.loc && node.loc.constructor === Object) {
            if (typeof node.loc.source !== 'string') {
              key += '.source';
            } else if (!isValidLocation(node.loc.start)) {
              key += '.start';
            } else if (!isValidLocation(node.loc.end)) {
              key += '.end';
            } else {
              continue;
            }
          }

          valid = false;
        } else if (fields.hasOwnProperty(key)) {
          for (var i = 0, valid = false; !valid && i < fields[key].length; i++) {
            var fieldType = fields[key][i];

            switch (fieldType) {
              case String:
                valid = typeof node[key] === 'string';
                break;

              case Boolean:
                valid = typeof node[key] === 'boolean';
                break;

              case null:
                valid = node[key] === null;
                break;

              default:
                if (typeof fieldType === 'string') {
                  valid = node[key] && node[key].type === fieldType;
                } else if (Array.isArray(fieldType)) {
                  valid = node[key] instanceof List;
                }

            }
          }
        } else {
          warn(node, 'Unknown field `' + key + '` for ' + type + ' node type');
        }

        if (!valid) {
          warn(node, 'Bad value for `' + type + '.' + key + '`');
        }
      }

      for (var key in fields) {
        if (hasOwnProperty.call(fields, key) && hasOwnProperty.call(node, key) === false) {
          warn(node, 'Field `' + type + '.' + key + '` is missed');
        }
      }
    };
  }

  function processStructure(name, nodeType) {
    var structure = nodeType.structure;
    var fields = {
      type: String,
      loc: true
    };
    var docs = {
      type: '"' + name + '"'
    };

    for (var key in structure) {
      if (hasOwnProperty.call(structure, key) === false) {
        continue;
      }

      var docsTypes = [];
      var fieldTypes = fields[key] = Array.isArray(structure[key]) ? structure[key].slice() : [structure[key]];

      for (var i = 0; i < fieldTypes.length; i++) {
        var fieldType = fieldTypes[i];

        if (fieldType === String || fieldType === Boolean) {
          docsTypes.push(fieldType.name);
        } else if (fieldType === null) {
          docsTypes.push('null');
        } else if (typeof fieldType === 'string') {
          docsTypes.push('<' + fieldType + '>');
        } else if (Array.isArray(fieldType)) {
          docsTypes.push('List'); // TODO: use type enum
        } else {
          throw new Error('Wrong value `' + fieldType + '` in `' + name + '.' + key + '` structure definition');
        }
      }

      docs[key] = docsTypes.join(' | ');
    }

    return {
      docs: docs,
      check: createNodeStructureChecker(name, fields)
    };
  }

  module.exports = {
    getStructureFromConfig: function getStructureFromConfig(config) {
      var structure = {};

      if (config.node) {
        for (var name in config.node) {
          if (hasOwnProperty.call(config.node, name)) {
            var nodeType = config.node[name];

            if (nodeType.structure) {
              structure[name] = processStructure(name, nodeType);
            } else {
              throw new Error('Missed `structure` field in `' + name + '` node type definition');
            }
          }
        }
      }

      return structure;
    }
  };
  /***/
},
/* 74 */

/***/
function (module, exports, __webpack_require__) {
  module.exports = {
    SyntaxParseError: __webpack_require__(66).SyntaxParseError,
    parse: __webpack_require__(64),
    generate: __webpack_require__(61),
    walk: __webpack_require__(67)
  };
  /***/
},
/* 75 */

/***/
function (module, exports, __webpack_require__) {
  ;

  var Tokenizer = __webpack_require__(53);

  var List = __webpack_require__(52);

  var sequence = __webpack_require__(76);

  var noop = function noop() {};

  function createParseContext(name) {
    return function () {
      return this[name]();
    };
  }

  function processConfig(config) {
    var parserConfig = {
      context: {},
      scope: {},
      atrule: {},
      pseudo: {}
    };

    if (config.parseContext) {
      for (var name in config.parseContext) {
        switch (_typeof2(config.parseContext[name])) {
          case 'function':
            parserConfig.context[name] = config.parseContext[name];
            break;

          case 'string':
            parserConfig.context[name] = createParseContext(config.parseContext[name]);
            break;
        }
      }
    }

    if (config.scope) {
      for (var name in config.scope) {
        parserConfig.scope[name] = config.scope[name];
      }
    }

    if (config.atrule) {
      for (var name in config.atrule) {
        var atrule = config.atrule[name];

        if (atrule.parse) {
          parserConfig.atrule[name] = atrule.parse;
        }
      }
    }

    if (config.pseudo) {
      for (var name in config.pseudo) {
        var pseudo = config.pseudo[name];

        if (pseudo.parse) {
          parserConfig.pseudo[name] = pseudo.parse;
        }
      }
    }

    if (config.node) {
      for (var name in config.node) {
        parserConfig[name] = config.node[name].parse;
      }
    }

    return parserConfig;
  }

  module.exports = function createParser(config) {
    var parser = {
      scanner: new Tokenizer(),
      filename: '<unknown>',
      needPositions: false,
      onParseError: noop,
      onParseErrorThrow: false,
      parseAtrulePrelude: true,
      parseRulePrelude: true,
      parseValue: true,
      parseCustomProperty: false,
      readSequence: sequence,
      createList: function createList() {
        return new List();
      },
      createSingleNodeList: function createSingleNodeList(node) {
        return new List().appendData(node);
      },
      getFirstListNode: function getFirstListNode(list) {
        return list && list.first();
      },
      getLastListNode: function getLastListNode(list) {
        return list.last();
      },
      parseWithFallback: function parseWithFallback(consumer, fallback) {
        var startToken = this.scanner.currentToken;

        try {
          return consumer.call(this);
        } catch (e) {
          if (this.onParseErrorThrow) {
            throw e;
          }

          var fallbackNode = fallback.call(this, startToken);
          this.onParseErrorThrow = true;
          this.onParseError(e, fallbackNode);
          this.onParseErrorThrow = false;
          return fallbackNode;
        }
      },
      getLocation: function getLocation(start, end) {
        if (this.needPositions) {
          return this.scanner.getLocationRange(start, end, this.filename);
        }

        return null;
      },
      getLocationFromList: function getLocationFromList(list) {
        if (this.needPositions) {
          var head = this.getFirstListNode(list);
          var tail = this.getLastListNode(list);
          return this.scanner.getLocationRange(head !== null ? head.loc.start.offset - this.scanner.startOffset : this.scanner.tokenStart, tail !== null ? tail.loc.end.offset - this.scanner.startOffset : this.scanner.tokenStart, this.filename);
        }

        return null;
      }
    };
    config = processConfig(config || {});

    for (var key in config) {
      parser[key] = config[key];
    }

    return function (source, options) {
      options = options || {};
      var context = options.context || 'default';
      var ast;
      parser.scanner.setSource(source, options.offset, options.line, options.column);
      parser.filename = options.filename || '<unknown>';
      parser.needPositions = Boolean(options.positions);
      parser.onParseError = typeof options.onParseError === 'function' ? options.onParseError : noop;
      parser.onParseErrorThrow = false;
      parser.parseAtrulePrelude = 'parseAtrulePrelude' in options ? Boolean(options.parseAtrulePrelude) : true;
      parser.parseRulePrelude = 'parseRulePrelude' in options ? Boolean(options.parseRulePrelude) : true;
      parser.parseValue = 'parseValue' in options ? Boolean(options.parseValue) : true;
      parser.parseCustomProperty = 'parseCustomProperty' in options ? Boolean(options.parseCustomProperty) : false;

      if (!parser.context.hasOwnProperty(context)) {
        throw new Error('Unknown context `' + context + '`');
      }

      ast = parser.context[context].call(parser, options);

      if (!parser.scanner.eof) {
        parser.scanner.error();
      }

      return ast;
    };
  };
  /***/

},
/* 76 */

/***/
function (module, exports, __webpack_require__) {
  var TYPE = __webpack_require__(53).TYPE;

  var WHITESPACE = TYPE.WhiteSpace;
  var COMMENT = TYPE.Comment;

  module.exports = function readSequence(recognizer) {
    var children = this.createList();
    var child = null;
    var context = {
      recognizer: recognizer,
      space: null,
      ignoreWS: false,
      ignoreWSAfter: false
    };
    this.scanner.skipSC();

    while (!this.scanner.eof) {
      switch (this.scanner.tokenType) {
        case COMMENT:
          this.scanner.next();
          continue;

        case WHITESPACE:
          if (context.ignoreWS) {
            this.scanner.next();
          } else {
            context.space = this.WhiteSpace();
          }

          continue;
      }

      child = recognizer.getNode.call(this, context);

      if (child === undefined) {
        break;
      }

      if (context.space !== null) {
        children.push(context.space);
        context.space = null;
      }

      children.push(child);

      if (context.ignoreWSAfter) {
        context.ignoreWSAfter = false;
        context.ignoreWS = true;
      } else {
        context.ignoreWS = false;
      }
    }

    return children;
  };
  /***/

},
/* 77 */

/***/
function (module, exports, __webpack_require__) {
  ;

  var sourceMap = __webpack_require__(78);

  var hasOwnProperty = Object.prototype.hasOwnProperty;

  function processChildren(node, delimeter) {
    var list = node.children;
    var prev = null;

    if (typeof delimeter !== 'function') {
      list.forEach(this.node, this);
    } else {
      list.forEach(function (node) {
        if (prev !== null) {
          delimeter.call(this, prev);
        }

        this.node(node);
        prev = node;
      }, this);
    }
  }

  module.exports = function createGenerator(config) {
    function processNode(node) {
      if (hasOwnProperty.call(types, node.type)) {
        types[node.type].call(this, node);
      } else {
        throw new Error('Unknown node type: ' + node.type);
      }
    }

    var types = {};

    if (config.node) {
      for (var name in config.node) {
        types[name] = config.node[name].generate;
      }
    }

    return function (node, options) {
      var buffer = '';
      var handlers = {
        children: processChildren,
        node: processNode,
        chunk: function chunk(_chunk2) {
          buffer += _chunk2;
        },
        result: function result() {
          return buffer;
        }
      };

      if (options) {
        if (typeof options.decorator === 'function') {
          handlers = options.decorator(handlers);
        }

        if (options.sourceMap) {
          handlers = sourceMap(handlers);
        }
      }

      handlers.node(node);
      return handlers.result();
    };
  };
  /***/

},
/* 78 */

/***/
function (module, exports, __webpack_require__) {
  ;

  var SourceMapGenerator = __webpack_require__(79).SourceMapGenerator;

  var trackNodes = {
    Atrule: true,
    Selector: true,
    Declaration: true
  };

  module.exports = function generateSourceMap(handlers) {
    var map = new SourceMapGenerator();
    var line = 1;
    var column = 0;
    var generated = {
      line: 1,
      column: 0
    };
    var original = {
      line: 0,
      // should be zero to add first mapping
      column: 0
    };
    var sourceMappingActive = false;
    var activatedGenerated = {
      line: 1,
      column: 0
    };
    var activatedMapping = {
      generated: activatedGenerated
    };
    var handlersNode = handlers.node;

    handlers.node = function (node) {
      if (node.loc && node.loc.start && trackNodes.hasOwnProperty(node.type)) {
        var nodeLine = node.loc.start.line;
        var nodeColumn = node.loc.start.column - 1;

        if (original.line !== nodeLine || original.column !== nodeColumn) {
          original.line = nodeLine;
          original.column = nodeColumn;
          generated.line = line;
          generated.column = column;

          if (sourceMappingActive) {
            sourceMappingActive = false;

            if (generated.line !== activatedGenerated.line || generated.column !== activatedGenerated.column) {
              map.addMapping(activatedMapping);
            }
          }

          sourceMappingActive = true;
          map.addMapping({
            source: node.loc.source,
            original: original,
            generated: generated
          });
        }
      }

      handlersNode.call(this, node);

      if (sourceMappingActive && trackNodes.hasOwnProperty(node.type)) {
        activatedGenerated.line = line;
        activatedGenerated.column = column;
      }
    };

    var handlersChunk = handlers.chunk;

    handlers.chunk = function (chunk) {
      for (var i = 0; i < chunk.length; i++) {
        if (chunk.charCodeAt(i) === 10) {
          // \n
          line++;
          column = 0;
        } else {
          column++;
        }
      }

      handlersChunk(chunk);
    };

    var handlersResult = handlers.result;

    handlers.result = function () {
      if (sourceMappingActive) {
        map.addMapping(activatedMapping);
      }

      return {
        css: handlersResult(),
        map: map
      };
    };

    return handlers;
  };
  /***/

},
/* 79 */

/***/
function (module, exports, __webpack_require__) {
  /*
   * Copyright 2009-2011 Mozilla Foundation and contributors
   * Licensed under the New BSD license. See LICENSE.txt or:
   * http://opensource.org/licenses/BSD-3-Clause
   */
  exports.SourceMapGenerator = __webpack_require__(80).SourceMapGenerator;
  exports.SourceMapConsumer = __webpack_require__(86).SourceMapConsumer;
  exports.SourceNode = __webpack_require__(89).SourceNode;
  /***/
},
/* 80 */

/***/
function (module, exports, __webpack_require__) {
  /* -*- Mode: js; js-indent-level: 2; -*- */

  /*
   * Copyright 2011 Mozilla Foundation and contributors
   * Licensed under the New BSD license. See LICENSE or:
   * http://opensource.org/licenses/BSD-3-Clause
   */
  var base64VLQ = __webpack_require__(81);

  var util = __webpack_require__(83);

  var ArraySet = __webpack_require__(84).ArraySet;

  var MappingList = __webpack_require__(85).MappingList;
  /**
   * An instance of the SourceMapGenerator represents a source map which is
   * being built incrementally. You may pass an object with the following
   * properties:
   *
   *   - file: The filename of the generated source.
   *   - sourceRoot: A root for all relative URLs in this source map.
   */


  function SourceMapGenerator(aArgs) {
    if (!aArgs) {
      aArgs = {};
    }

    this._file = util.getArg(aArgs, 'file', null);
    this._sourceRoot = util.getArg(aArgs, 'sourceRoot', null);
    this._skipValidation = util.getArg(aArgs, 'skipValidation', false);
    this._sources = new ArraySet();
    this._names = new ArraySet();
    this._mappings = new MappingList();
    this._sourcesContents = null;
  }

  SourceMapGenerator.prototype._version = 3;
  /**
   * Creates a new SourceMapGenerator based on a SourceMapConsumer
   *
   * @param aSourceMapConsumer The SourceMap.
   */

  SourceMapGenerator.fromSourceMap = function SourceMapGenerator_fromSourceMap(aSourceMapConsumer) {
    var sourceRoot = aSourceMapConsumer.sourceRoot;
    var generator = new SourceMapGenerator({
      file: aSourceMapConsumer.file,
      sourceRoot: sourceRoot
    });
    aSourceMapConsumer.eachMapping(function (mapping) {
      var newMapping = {
        generated: {
          line: mapping.generatedLine,
          column: mapping.generatedColumn
        }
      };

      if (mapping.source != null) {
        newMapping.source = mapping.source;

        if (sourceRoot != null) {
          newMapping.source = util.relative(sourceRoot, newMapping.source);
        }

        newMapping.original = {
          line: mapping.originalLine,
          column: mapping.originalColumn
        };

        if (mapping.name != null) {
          newMapping.name = mapping.name;
        }
      }

      generator.addMapping(newMapping);
    });
    aSourceMapConsumer.sources.forEach(function (sourceFile) {
      var content = aSourceMapConsumer.sourceContentFor(sourceFile);

      if (content != null) {
        generator.setSourceContent(sourceFile, content);
      }
    });
    return generator;
  };
  /**
   * Add a single mapping from original source line and column to the generated
   * source's line and column for this source map being created. The mapping
   * object should have the following properties:
   *
   *   - generated: An object with the generated line and column positions.
   *   - original: An object with the original line and column positions.
   *   - source: The original source file (relative to the sourceRoot).
   *   - name: An optional original token name for this mapping.
   */


  SourceMapGenerator.prototype.addMapping = function SourceMapGenerator_addMapping(aArgs) {
    var generated = util.getArg(aArgs, 'generated');
    var original = util.getArg(aArgs, 'original', null);
    var source = util.getArg(aArgs, 'source', null);
    var name = util.getArg(aArgs, 'name', null);

    if (!this._skipValidation) {
      this._validateMapping(generated, original, source, name);
    }

    if (source != null) {
      source = String(source);

      if (!this._sources.has(source)) {
        this._sources.add(source);
      }
    }

    if (name != null) {
      name = String(name);

      if (!this._names.has(name)) {
        this._names.add(name);
      }
    }

    this._mappings.add({
      generatedLine: generated.line,
      generatedColumn: generated.column,
      originalLine: original != null && original.line,
      originalColumn: original != null && original.column,
      source: source,
      name: name
    });
  };
  /**
   * Set the source content for a source file.
   */


  SourceMapGenerator.prototype.setSourceContent = function SourceMapGenerator_setSourceContent(aSourceFile, aSourceContent) {
    var source = aSourceFile;

    if (this._sourceRoot != null) {
      source = util.relative(this._sourceRoot, source);
    }

    if (aSourceContent != null) {
      // Add the source content to the _sourcesContents map.
      // Create a new _sourcesContents map if the property is null.
      if (!this._sourcesContents) {
        this._sourcesContents = Object.create(null);
      }

      this._sourcesContents[util.toSetString(source)] = aSourceContent;
    } else if (this._sourcesContents) {
      // Remove the source file from the _sourcesContents map.
      // If the _sourcesContents map is empty, set the property to null.
      delete this._sourcesContents[util.toSetString(source)];

      if (Object.keys(this._sourcesContents).length === 0) {
        this._sourcesContents = null;
      }
    }
  };
  /**
   * Applies the mappings of a sub-source-map for a specific source file to the
   * source map being generated. Each mapping to the supplied source file is
   * rewritten using the supplied source map. Note: The resolution for the
   * resulting mappings is the minimium of this map and the supplied map.
   *
   * @param aSourceMapConsumer The source map to be applied.
   * @param aSourceFile Optional. The filename of the source file.
   *        If omitted, SourceMapConsumer's file property will be used.
   * @param aSourceMapPath Optional. The dirname of the path to the source map
   *        to be applied. If relative, it is relative to the SourceMapConsumer.
   *        This parameter is needed when the two source maps aren't in the same
   *        directory, and the source map to be applied contains relative source
   *        paths. If so, those relative source paths need to be rewritten
   *        relative to the SourceMapGenerator.
   */


  SourceMapGenerator.prototype.applySourceMap = function SourceMapGenerator_applySourceMap(aSourceMapConsumer, aSourceFile, aSourceMapPath) {
    var sourceFile = aSourceFile; // If aSourceFile is omitted, we will use the file property of the SourceMap

    if (aSourceFile == null) {
      if (aSourceMapConsumer.file == null) {
        throw new Error('SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, ' + 'or the source map\'s "file" property. Both were omitted.');
      }

      sourceFile = aSourceMapConsumer.file;
    }

    var sourceRoot = this._sourceRoot; // Make "sourceFile" relative if an absolute Url is passed.

    if (sourceRoot != null) {
      sourceFile = util.relative(sourceRoot, sourceFile);
    } // Applying the SourceMap can add and remove items from the sources and
    // the names array.


    var newSources = new ArraySet();
    var newNames = new ArraySet(); // Find mappings for the "sourceFile"

    this._mappings.unsortedForEach(function (mapping) {
      if (mapping.source === sourceFile && mapping.originalLine != null) {
        // Check if it can be mapped by the source map, then update the mapping.
        var original = aSourceMapConsumer.originalPositionFor({
          line: mapping.originalLine,
          column: mapping.originalColumn
        });

        if (original.source != null) {
          // Copy mapping
          mapping.source = original.source;

          if (aSourceMapPath != null) {
            mapping.source = util.join(aSourceMapPath, mapping.source);
          }

          if (sourceRoot != null) {
            mapping.source = util.relative(sourceRoot, mapping.source);
          }

          mapping.originalLine = original.line;
          mapping.originalColumn = original.column;

          if (original.name != null) {
            mapping.name = original.name;
          }
        }
      }

      var source = mapping.source;

      if (source != null && !newSources.has(source)) {
        newSources.add(source);
      }

      var name = mapping.name;

      if (name != null && !newNames.has(name)) {
        newNames.add(name);
      }
    }, this);

    this._sources = newSources;
    this._names = newNames; // Copy sourcesContents of applied map.

    aSourceMapConsumer.sources.forEach(function (sourceFile) {
      var content = aSourceMapConsumer.sourceContentFor(sourceFile);

      if (content != null) {
        if (aSourceMapPath != null) {
          sourceFile = util.join(aSourceMapPath, sourceFile);
        }

        if (sourceRoot != null) {
          sourceFile = util.relative(sourceRoot, sourceFile);
        }

        this.setSourceContent(sourceFile, content);
      }
    }, this);
  };
  /**
   * A mapping can have one of the three levels of data:
   *
   *   1. Just the generated position.
   *   2. The Generated position, original position, and original source.
   *   3. Generated and original position, original source, as well as a name
   *      token.
   *
   * To maintain consistency, we validate that any new mapping being added falls
   * in to one of these categories.
   */


  SourceMapGenerator.prototype._validateMapping = function SourceMapGenerator_validateMapping(aGenerated, aOriginal, aSource, aName) {
    // When aOriginal is truthy but has empty values for .line and .column,
    // it is most likely a programmer error. In this case we throw a very
    // specific error message to try to guide them the right way.
    // For example: https://github.com/Polymer/polymer-bundler/pull/519
    if (aOriginal && typeof aOriginal.line !== 'number' && typeof aOriginal.column !== 'number') {
      throw new Error('original.line and original.column are not numbers -- you probably meant to omit ' + 'the original mapping entirely and only map the generated position. If so, pass ' + 'null for the original mapping instead of an object with empty or null values.');
    }

    if (aGenerated && 'line' in aGenerated && 'column' in aGenerated && aGenerated.line > 0 && aGenerated.column >= 0 && !aOriginal && !aSource && !aName) {
      // Case 1.
      return;
    } else if (aGenerated && 'line' in aGenerated && 'column' in aGenerated && aOriginal && 'line' in aOriginal && 'column' in aOriginal && aGenerated.line > 0 && aGenerated.column >= 0 && aOriginal.line > 0 && aOriginal.column >= 0 && aSource) {
      // Cases 2 and 3.
      return;
    } else {
      throw new Error('Invalid mapping: ' + JSON.stringify({
        generated: aGenerated,
        source: aSource,
        original: aOriginal,
        name: aName
      }));
    }
  };
  /**
   * Serialize the accumulated mappings in to the stream of base 64 VLQs
   * specified by the source map format.
   */


  SourceMapGenerator.prototype._serializeMappings = function SourceMapGenerator_serializeMappings() {
    var previousGeneratedColumn = 0;
    var previousGeneratedLine = 1;
    var previousOriginalColumn = 0;
    var previousOriginalLine = 0;
    var previousName = 0;
    var previousSource = 0;
    var result = '';
    var next;
    var mapping;
    var nameIdx;
    var sourceIdx;

    var mappings = this._mappings.toArray();

    for (var i = 0, len = mappings.length; i < len; i++) {
      mapping = mappings[i];
      next = '';

      if (mapping.generatedLine !== previousGeneratedLine) {
        previousGeneratedColumn = 0;

        while (mapping.generatedLine !== previousGeneratedLine) {
          next += ';';
          previousGeneratedLine++;
        }
      } else {
        if (i > 0) {
          if (!util.compareByGeneratedPositionsInflated(mapping, mappings[i - 1])) {
            continue;
          }

          next += ',';
        }
      }

      next += base64VLQ.encode(mapping.generatedColumn - previousGeneratedColumn);
      previousGeneratedColumn = mapping.generatedColumn;

      if (mapping.source != null) {
        sourceIdx = this._sources.indexOf(mapping.source);
        next += base64VLQ.encode(sourceIdx - previousSource);
        previousSource = sourceIdx; // lines are stored 0-based in SourceMap spec version 3

        next += base64VLQ.encode(mapping.originalLine - 1 - previousOriginalLine);
        previousOriginalLine = mapping.originalLine - 1;
        next += base64VLQ.encode(mapping.originalColumn - previousOriginalColumn);
        previousOriginalColumn = mapping.originalColumn;

        if (mapping.name != null) {
          nameIdx = this._names.indexOf(mapping.name);
          next += base64VLQ.encode(nameIdx - previousName);
          previousName = nameIdx;
        }
      }

      result += next;
    }

    return result;
  };

  SourceMapGenerator.prototype._generateSourcesContent = function SourceMapGenerator_generateSourcesContent(aSources, aSourceRoot) {
    return aSources.map(function (source) {
      if (!this._sourcesContents) {
        return null;
      }

      if (aSourceRoot != null) {
        source = util.relative(aSourceRoot, source);
      }

      var key = util.toSetString(source);
      return Object.prototype.hasOwnProperty.call(this._sourcesContents, key) ? this._sourcesContents[key] : null;
    }, this);
  };
  /**
   * Externalize the source map.
   */


  SourceMapGenerator.prototype.toJSON = function SourceMapGenerator_toJSON() {
    var map = {
      version: this._version,
      sources: this._sources.toArray(),
      names: this._names.toArray(),
      mappings: this._serializeMappings()
    };

    if (this._file != null) {
      map.file = this._file;
    }

    if (this._sourceRoot != null) {
      map.sourceRoot = this._sourceRoot;
    }

    if (this._sourcesContents) {
      map.sourcesContent = this._generateSourcesContent(map.sources, map.sourceRoot);
    }

    return map;
  };
  /**
   * Render the source map being generated to a string.
   */


  SourceMapGenerator.prototype.toString = function SourceMapGenerator_toString() {
    return JSON.stringify(this.toJSON());
  };

  exports.SourceMapGenerator = SourceMapGenerator;
  /***/
},
/* 81 */

/***/
function (module, exports, __webpack_require__) {
  /* -*- Mode: js; js-indent-level: 2; -*- */

  /*
   * Copyright 2011 Mozilla Foundation and contributors
   * Licensed under the New BSD license. See LICENSE or:
   * http://opensource.org/licenses/BSD-3-Clause
   *
   * Based on the Base 64 VLQ implementation in Closure Compiler:
   * https://code.google.com/p/closure-compiler/source/browse/trunk/src/com/google/debugging/sourcemap/Base64VLQ.java
   *
   * Copyright 2011 The Closure Compiler Authors. All rights reserved.
   * Redistribution and use in source and binary forms, with or without
   * modification, are permitted provided that the following conditions are
   * met:
   *
   *  * Redistributions of source code must retain the above copyright
   *    notice, this list of conditions and the following disclaimer.
   *  * Redistributions in binary form must reproduce the above
   *    copyright notice, this list of conditions and the following
   *    disclaimer in the documentation and/or other materials provided
   *    with the distribution.
   *  * Neither the name of Google Inc. nor the names of its
   *    contributors may be used to endorse or promote products derived
   *    from this software without specific prior written permission.
   *
   * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
   * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
   * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
   * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
   * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
   * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
   * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
   * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
   * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
   * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
   * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
   */
  var base64 = __webpack_require__(82); // A single base 64 digit can contain 6 bits of data. For the base 64 variable
  // length quantities we use in the source map spec, the first bit is the sign,
  // the next four bits are the actual value, and the 6th bit is the
  // continuation bit. The continuation bit tells us whether there are more
  // digits in this value following this digit.
  //
  //   Continuation
  //   |    Sign
  //   |    |
  //   V    V
  //   101011


  var VLQ_BASE_SHIFT = 5; // binary: 100000

  var VLQ_BASE = 1 << VLQ_BASE_SHIFT; // binary: 011111

  var VLQ_BASE_MASK = VLQ_BASE - 1; // binary: 100000

  var VLQ_CONTINUATION_BIT = VLQ_BASE;
  /**
   * Converts from a two-complement value to a value where the sign bit is
   * placed in the least significant bit.  For example, as decimals:
   *   1 becomes 2 (10 binary), -1 becomes 3 (11 binary)
   *   2 becomes 4 (100 binary), -2 becomes 5 (101 binary)
   */

  function toVLQSigned(aValue) {
    return aValue < 0 ? (-aValue << 1) + 1 : (aValue << 1) + 0;
  }
  /**
   * Converts to a two-complement value from a value where the sign bit is
   * placed in the least significant bit.  For example, as decimals:
   *   2 (10 binary) becomes 1, 3 (11 binary) becomes -1
   *   4 (100 binary) becomes 2, 5 (101 binary) becomes -2
   */


  function fromVLQSigned(aValue) {
    var isNegative = (aValue & 1) === 1;
    var shifted = aValue >> 1;
    return isNegative ? -shifted : shifted;
  }
  /**
   * Returns the base 64 VLQ encoded value.
   */


  exports.encode = function base64VLQ_encode(aValue) {
    var encoded = "";
    var digit;
    var vlq = toVLQSigned(aValue);

    do {
      digit = vlq & VLQ_BASE_MASK;
      vlq >>>= VLQ_BASE_SHIFT;

      if (vlq > 0) {
        // There are still more digits in this value, so we must make sure the
        // continuation bit is marked.
        digit |= VLQ_CONTINUATION_BIT;
      }

      encoded += base64.encode(digit);
    } while (vlq > 0);

    return encoded;
  };
  /**
   * Decodes the next base 64 VLQ value from the given string and returns the
   * value and the rest of the string via the out parameter.
   */


  exports.decode = function base64VLQ_decode(aStr, aIndex, aOutParam) {
    var strLen = aStr.length;
    var result = 0;
    var shift = 0;
    var continuation, digit;

    do {
      if (aIndex >= strLen) {
        throw new Error("Expected more digits in base 64 VLQ value.");
      }

      digit = base64.decode(aStr.charCodeAt(aIndex++));

      if (digit === -1) {
        throw new Error("Invalid base64 digit: " + aStr.charAt(aIndex - 1));
      }

      continuation = !!(digit & VLQ_CONTINUATION_BIT);
      digit &= VLQ_BASE_MASK;
      result = result + (digit << shift);
      shift += VLQ_BASE_SHIFT;
    } while (continuation);

    aOutParam.value = fromVLQSigned(result);
    aOutParam.rest = aIndex;
  };
  /***/

},
/* 82 */

/***/
function (module, exports) {
  /* -*- Mode: js; js-indent-level: 2; -*- */

  /*
   * Copyright 2011 Mozilla Foundation and contributors
   * Licensed under the New BSD license. See LICENSE or:
   * http://opensource.org/licenses/BSD-3-Clause
   */
  var intToCharMap = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'.split('');
  /**
   * Encode an integer in the range of 0 to 63 to a single base 64 digit.
   */

  exports.encode = function (number) {
    if (0 <= number && number < intToCharMap.length) {
      return intToCharMap[number];
    }

    throw new TypeError("Must be between 0 and 63: " + number);
  };
  /**
   * Decode a single base 64 character code digit to an integer. Returns -1 on
   * failure.
   */


  exports.decode = function (charCode) {
    var bigA = 65; // 'A'

    var bigZ = 90; // 'Z'

    var littleA = 97; // 'a'

    var littleZ = 122; // 'z'

    var zero = 48; // '0'

    var nine = 57; // '9'

    var plus = 43; // '+'

    var slash = 47; // '/'

    var littleOffset = 26;
    var numberOffset = 52; // 0 - 25: ABCDEFGHIJKLMNOPQRSTUVWXYZ

    if (bigA <= charCode && charCode <= bigZ) {
      return charCode - bigA;
    } // 26 - 51: abcdefghijklmnopqrstuvwxyz


    if (littleA <= charCode && charCode <= littleZ) {
      return charCode - littleA + littleOffset;
    } // 52 - 61: 0123456789


    if (zero <= charCode && charCode <= nine) {
      return charCode - zero + numberOffset;
    } // 62: +


    if (charCode == plus) {
      return 62;
    } // 63: /


    if (charCode == slash) {
      return 63;
    } // Invalid base64 digit.


    return -1;
  };
  /***/

},
/* 83 */

/***/
function (module, exports) {
  /* -*- Mode: js; js-indent-level: 2; -*- */

  /*
   * Copyright 2011 Mozilla Foundation and contributors
   * Licensed under the New BSD license. See LICENSE or:
   * http://opensource.org/licenses/BSD-3-Clause
   */

  /**
   * This is a helper function for getting values from parameter/options
   * objects.
   *
   * @param args The object we are extracting values from
   * @param name The name of the property we are getting.
   * @param defaultValue An optional value to return if the property is missing
   * from the object. If this is not specified and the property is missing, an
   * error will be thrown.
   */
  function getArg(aArgs, aName, aDefaultValue) {
    if (aName in aArgs) {
      return aArgs[aName];
    } else if (arguments.length === 3) {
      return aDefaultValue;
    } else {
      throw new Error('"' + aName + '" is a required argument.');
    }
  }

  exports.getArg = getArg;
  var urlRegexp = /^(?:([\w+\-.]+):)?\/\/(?:(\w+:\w+)@)?([\w.]*)(?::(\d+))?(\S*)$/;
  var dataUrlRegexp = /^data:.+\,.+$/;

  function urlParse(aUrl) {
    var match = aUrl.match(urlRegexp);

    if (!match) {
      return null;
    }

    return {
      scheme: match[1],
      auth: match[2],
      host: match[3],
      port: match[4],
      path: match[5]
    };
  }

  exports.urlParse = urlParse;

  function urlGenerate(aParsedUrl) {
    var url = '';

    if (aParsedUrl.scheme) {
      url += aParsedUrl.scheme + ':';
    }

    url += '//';

    if (aParsedUrl.auth) {
      url += aParsedUrl.auth + '@';
    }

    if (aParsedUrl.host) {
      url += aParsedUrl.host;
    }

    if (aParsedUrl.port) {
      url += ":" + aParsedUrl.port;
    }

    if (aParsedUrl.path) {
      url += aParsedUrl.path;
    }

    return url;
  }

  exports.urlGenerate = urlGenerate;
  /**
   * Normalizes a path, or the path portion of a URL:
   *
   * - Replaces consecutive slashes with one slash.
   * - Removes unnecessary '.' parts.
   * - Removes unnecessary '<dir>/..' parts.
   *
   * Based on code in the Node.js 'path' core module.
   *
   * @param aPath The path or url to normalize.
   */

  function normalize(aPath) {
    var path = aPath;
    var url = urlParse(aPath);

    if (url) {
      if (!url.path) {
        return aPath;
      }

      path = url.path;
    }

    var isAbsolute = exports.isAbsolute(path);
    var parts = path.split(/\/+/);

    for (var part, up = 0, i = parts.length - 1; i >= 0; i--) {
      part = parts[i];

      if (part === '.') {
        parts.splice(i, 1);
      } else if (part === '..') {
        up++;
      } else if (up > 0) {
        if (part === '') {
          // The first part is blank if the path is absolute. Trying to go
          // above the root is a no-op. Therefore we can remove all '..' parts
          // directly after the root.
          parts.splice(i + 1, up);
          up = 0;
        } else {
          parts.splice(i, 2);
          up--;
        }
      }
    }

    path = parts.join('/');

    if (path === '') {
      path = isAbsolute ? '/' : '.';
    }

    if (url) {
      url.path = path;
      return urlGenerate(url);
    }

    return path;
  }

  exports.normalize = normalize;
  /**
   * Joins two paths/URLs.
   *
   * @param aRoot The root path or URL.
   * @param aPath The path or URL to be joined with the root.
   *
   * - If aPath is a URL or a data URI, aPath is returned, unless aPath is a
   *   scheme-relative URL: Then the scheme of aRoot, if any, is prepended
   *   first.
   * - Otherwise aPath is a path. If aRoot is a URL, then its path portion
   *   is updated with the result and aRoot is returned. Otherwise the result
   *   is returned.
   *   - If aPath is absolute, the result is aPath.
   *   - Otherwise the two paths are joined with a slash.
   * - Joining for example 'http://' and 'www.example.com' is also supported.
   */

  function join(aRoot, aPath) {
    if (aRoot === "") {
      aRoot = ".";
    }

    if (aPath === "") {
      aPath = ".";
    }

    var aPathUrl = urlParse(aPath);
    var aRootUrl = urlParse(aRoot);

    if (aRootUrl) {
      aRoot = aRootUrl.path || '/';
    } // `join(foo, '//www.example.org')`


    if (aPathUrl && !aPathUrl.scheme) {
      if (aRootUrl) {
        aPathUrl.scheme = aRootUrl.scheme;
      }

      return urlGenerate(aPathUrl);
    }

    if (aPathUrl || aPath.match(dataUrlRegexp)) {
      return aPath;
    } // `join('http://', 'www.example.com')`


    if (aRootUrl && !aRootUrl.host && !aRootUrl.path) {
      aRootUrl.host = aPath;
      return urlGenerate(aRootUrl);
    }

    var joined = aPath.charAt(0) === '/' ? aPath : normalize(aRoot.replace(/\/+$/, '') + '/' + aPath);

    if (aRootUrl) {
      aRootUrl.path = joined;
      return urlGenerate(aRootUrl);
    }

    return joined;
  }

  exports.join = join;

  exports.isAbsolute = function (aPath) {
    return aPath.charAt(0) === '/' || !!aPath.match(urlRegexp);
  };
  /**
   * Make a path relative to a URL or another path.
   *
   * @param aRoot The root path or URL.
   * @param aPath The path or URL to be made relative to aRoot.
   */


  function relative(aRoot, aPath) {
    if (aRoot === "") {
      aRoot = ".";
    }

    aRoot = aRoot.replace(/\/$/, ''); // It is possible for the path to be above the root. In this case, simply
    // checking whether the root is a prefix of the path won't work. Instead, we
    // need to remove components from the root one by one, until either we find
    // a prefix that fits, or we run out of components to remove.

    var level = 0;

    while (aPath.indexOf(aRoot + '/') !== 0) {
      var index = aRoot.lastIndexOf("/");

      if (index < 0) {
        return aPath;
      } // If the only part of the root that is left is the scheme (i.e. http://,
      // file:///, etc.), one or more slashes (/), or simply nothing at all, we
      // have exhausted all components, so the path is not relative to the root.


      aRoot = aRoot.slice(0, index);

      if (aRoot.match(/^([^\/]+:\/)?\/*$/)) {
        return aPath;
      }

      ++level;
    } // Make sure we add a "../" for each component we removed from the root.


    return Array(level + 1).join("../") + aPath.substr(aRoot.length + 1);
  }

  exports.relative = relative;

  var supportsNullProto = function () {
    var obj = Object.create(null);
    return !('__proto__' in obj);
  }();

  function identity(s) {
    return s;
  }
  /**
   * Because behavior goes wacky when you set `__proto__` on objects, we
   * have to prefix all the strings in our set with an arbitrary character.
   *
   * See https://github.com/mozilla/source-map/pull/31 and
   * https://github.com/mozilla/source-map/issues/30
   *
   * @param String aStr
   */


  function toSetString(aStr) {
    if (isProtoString(aStr)) {
      return '$' + aStr;
    }

    return aStr;
  }

  exports.toSetString = supportsNullProto ? identity : toSetString;

  function fromSetString(aStr) {
    if (isProtoString(aStr)) {
      return aStr.slice(1);
    }

    return aStr;
  }

  exports.fromSetString = supportsNullProto ? identity : fromSetString;

  function isProtoString(s) {
    if (!s) {
      return false;
    }

    var length = s.length;

    if (length < 9
    /* "__proto__".length */
    ) {
        return false;
      }

    if (s.charCodeAt(length - 1) !== 95
    /* '_' */
    || s.charCodeAt(length - 2) !== 95
    /* '_' */
    || s.charCodeAt(length - 3) !== 111
    /* 'o' */
    || s.charCodeAt(length - 4) !== 116
    /* 't' */
    || s.charCodeAt(length - 5) !== 111
    /* 'o' */
    || s.charCodeAt(length - 6) !== 114
    /* 'r' */
    || s.charCodeAt(length - 7) !== 112
    /* 'p' */
    || s.charCodeAt(length - 8) !== 95
    /* '_' */
    || s.charCodeAt(length - 9) !== 95
    /* '_' */
    ) {
        return false;
      }

    for (var i = length - 10; i >= 0; i--) {
      if (s.charCodeAt(i) !== 36
      /* '$' */
      ) {
          return false;
        }
    }

    return true;
  }
  /**
   * Comparator between two mappings where the original positions are compared.
   *
   * Optionally pass in `true` as `onlyCompareGenerated` to consider two
   * mappings with the same original source/line/column, but different generated
   * line and column the same. Useful when searching for a mapping with a
   * stubbed out mapping.
   */


  function compareByOriginalPositions(mappingA, mappingB, onlyCompareOriginal) {
    var cmp = mappingA.source - mappingB.source;

    if (cmp !== 0) {
      return cmp;
    }

    cmp = mappingA.originalLine - mappingB.originalLine;

    if (cmp !== 0) {
      return cmp;
    }

    cmp = mappingA.originalColumn - mappingB.originalColumn;

    if (cmp !== 0 || onlyCompareOriginal) {
      return cmp;
    }

    cmp = mappingA.generatedColumn - mappingB.generatedColumn;

    if (cmp !== 0) {
      return cmp;
    }

    cmp = mappingA.generatedLine - mappingB.generatedLine;

    if (cmp !== 0) {
      return cmp;
    }

    return mappingA.name - mappingB.name;
  }

  exports.compareByOriginalPositions = compareByOriginalPositions;
  /**
   * Comparator between two mappings with deflated source and name indices where
   * the generated positions are compared.
   *
   * Optionally pass in `true` as `onlyCompareGenerated` to consider two
   * mappings with the same generated line and column, but different
   * source/name/original line and column the same. Useful when searching for a
   * mapping with a stubbed out mapping.
   */

  function compareByGeneratedPositionsDeflated(mappingA, mappingB, onlyCompareGenerated) {
    var cmp = mappingA.generatedLine - mappingB.generatedLine;

    if (cmp !== 0) {
      return cmp;
    }

    cmp = mappingA.generatedColumn - mappingB.generatedColumn;

    if (cmp !== 0 || onlyCompareGenerated) {
      return cmp;
    }

    cmp = mappingA.source - mappingB.source;

    if (cmp !== 0) {
      return cmp;
    }

    cmp = mappingA.originalLine - mappingB.originalLine;

    if (cmp !== 0) {
      return cmp;
    }

    cmp = mappingA.originalColumn - mappingB.originalColumn;

    if (cmp !== 0) {
      return cmp;
    }

    return mappingA.name - mappingB.name;
  }

  exports.compareByGeneratedPositionsDeflated = compareByGeneratedPositionsDeflated;

  function strcmp(aStr1, aStr2) {
    if (aStr1 === aStr2) {
      return 0;
    }

    if (aStr1 > aStr2) {
      return 1;
    }

    return -1;
  }
  /**
   * Comparator between two mappings with inflated source and name strings where
   * the generated positions are compared.
   */


  function compareByGeneratedPositionsInflated(mappingA, mappingB) {
    var cmp = mappingA.generatedLine - mappingB.generatedLine;

    if (cmp !== 0) {
      return cmp;
    }

    cmp = mappingA.generatedColumn - mappingB.generatedColumn;

    if (cmp !== 0) {
      return cmp;
    }

    cmp = strcmp(mappingA.source, mappingB.source);

    if (cmp !== 0) {
      return cmp;
    }

    cmp = mappingA.originalLine - mappingB.originalLine;

    if (cmp !== 0) {
      return cmp;
    }

    cmp = mappingA.originalColumn - mappingB.originalColumn;

    if (cmp !== 0) {
      return cmp;
    }

    return strcmp(mappingA.name, mappingB.name);
  }

  exports.compareByGeneratedPositionsInflated = compareByGeneratedPositionsInflated;
  /***/
},
/* 84 */

/***/
function (module, exports, __webpack_require__) {
  /* -*- Mode: js; js-indent-level: 2; -*- */

  /*
   * Copyright 2011 Mozilla Foundation and contributors
   * Licensed under the New BSD license. See LICENSE or:
   * http://opensource.org/licenses/BSD-3-Clause
   */
  var util = __webpack_require__(83);

  var has = Object.prototype.hasOwnProperty;
  var hasNativeMap = typeof Map !== "undefined";
  /**
   * A data structure which is a combination of an array and a set. Adding a new
   * member is O(1), testing for membership is O(1), and finding the index of an
   * element is O(1). Removing elements from the set is not supported. Only
   * strings are supported for membership.
   */

  function ArraySet() {
    this._array = [];
    this._set = hasNativeMap ? new Map() : Object.create(null);
  }
  /**
   * Static method for creating ArraySet instances from an existing array.
   */


  ArraySet.fromArray = function ArraySet_fromArray(aArray, aAllowDuplicates) {
    var set = new ArraySet();

    for (var i = 0, len = aArray.length; i < len; i++) {
      set.add(aArray[i], aAllowDuplicates);
    }

    return set;
  };
  /**
   * Return how many unique items are in this ArraySet. If duplicates have been
   * added, than those do not count towards the size.
   *
   * @returns Number
   */


  ArraySet.prototype.size = function ArraySet_size() {
    return hasNativeMap ? this._set.size : Object.getOwnPropertyNames(this._set).length;
  };
  /**
   * Add the given string to this set.
   *
   * @param String aStr
   */


  ArraySet.prototype.add = function ArraySet_add(aStr, aAllowDuplicates) {
    var sStr = hasNativeMap ? aStr : util.toSetString(aStr);
    var isDuplicate = hasNativeMap ? this.has(aStr) : has.call(this._set, sStr);
    var idx = this._array.length;

    if (!isDuplicate || aAllowDuplicates) {
      this._array.push(aStr);
    }

    if (!isDuplicate) {
      if (hasNativeMap) {
        this._set.set(aStr, idx);
      } else {
        this._set[sStr] = idx;
      }
    }
  };
  /**
   * Is the given string a member of this set?
   *
   * @param String aStr
   */


  ArraySet.prototype.has = function ArraySet_has(aStr) {
    if (hasNativeMap) {
      return this._set.has(aStr);
    } else {
      var sStr = util.toSetString(aStr);
      return has.call(this._set, sStr);
    }
  };
  /**
   * What is the index of the given string in the array?
   *
   * @param String aStr
   */


  ArraySet.prototype.indexOf = function ArraySet_indexOf(aStr) {
    if (hasNativeMap) {
      var idx = this._set.get(aStr);

      if (idx >= 0) {
        return idx;
      }
    } else {
      var sStr = util.toSetString(aStr);

      if (has.call(this._set, sStr)) {
        return this._set[sStr];
      }
    }

    throw new Error('"' + aStr + '" is not in the set.');
  };
  /**
   * What is the element at the given index?
   *
   * @param Number aIdx
   */


  ArraySet.prototype.at = function ArraySet_at(aIdx) {
    if (aIdx >= 0 && aIdx < this._array.length) {
      return this._array[aIdx];
    }

    throw new Error('No element indexed by ' + aIdx);
  };
  /**
   * Returns the array representation of this set (which has the proper indices
   * indicated by indexOf). Note that this is a copy of the internal array used
   * for storing the members so that no one can mess with internal state.
   */


  ArraySet.prototype.toArray = function ArraySet_toArray() {
    return this._array.slice();
  };

  exports.ArraySet = ArraySet;
  /***/
},
/* 85 */

/***/
function (module, exports, __webpack_require__) {
  /* -*- Mode: js; js-indent-level: 2; -*- */

  /*
   * Copyright 2014 Mozilla Foundation and contributors
   * Licensed under the New BSD license. See LICENSE or:
   * http://opensource.org/licenses/BSD-3-Clause
   */
  var util = __webpack_require__(83);
  /**
   * Determine whether mappingB is after mappingA with respect to generated
   * position.
   */


  function generatedPositionAfter(mappingA, mappingB) {
    // Optimized for most common case
    var lineA = mappingA.generatedLine;
    var lineB = mappingB.generatedLine;
    var columnA = mappingA.generatedColumn;
    var columnB = mappingB.generatedColumn;
    return lineB > lineA || lineB == lineA && columnB >= columnA || util.compareByGeneratedPositionsInflated(mappingA, mappingB) <= 0;
  }
  /**
   * A data structure to provide a sorted view of accumulated mappings in a
   * performance conscious manner. It trades a neglibable overhead in general
   * case for a large speedup in case of mappings being added in order.
   */


  function MappingList() {
    this._array = [];
    this._sorted = true; // Serves as infimum

    this._last = {
      generatedLine: -1,
      generatedColumn: 0
    };
  }
  /**
   * Iterate through internal items. This method takes the same arguments that
   * `Array.prototype.forEach` takes.
   *
   * NOTE: The order of the mappings is NOT guaranteed.
   */


  MappingList.prototype.unsortedForEach = function MappingList_forEach(aCallback, aThisArg) {
    this._array.forEach(aCallback, aThisArg);
  };
  /**
   * Add the given source mapping.
   *
   * @param Object aMapping
   */


  MappingList.prototype.add = function MappingList_add(aMapping) {
    if (generatedPositionAfter(this._last, aMapping)) {
      this._last = aMapping;

      this._array.push(aMapping);
    } else {
      this._sorted = false;

      this._array.push(aMapping);
    }
  };
  /**
   * Returns the flat, sorted array of mappings. The mappings are sorted by
   * generated position.
   *
   * WARNING: This method returns internal data without copying, for
   * performance. The return value must NOT be mutated, and should be treated as
   * an immutable borrow. If you want to take ownership, you must make your own
   * copy.
   */


  MappingList.prototype.toArray = function MappingList_toArray() {
    if (!this._sorted) {
      this._array.sort(util.compareByGeneratedPositionsInflated);

      this._sorted = true;
    }

    return this._array;
  };

  exports.MappingList = MappingList;
  /***/
},
/* 86 */

/***/
function (module, exports, __webpack_require__) {
  /* -*- Mode: js; js-indent-level: 2; -*- */

  /*
   * Copyright 2011 Mozilla Foundation and contributors
   * Licensed under the New BSD license. See LICENSE or:
   * http://opensource.org/licenses/BSD-3-Clause
   */
  var util = __webpack_require__(83);

  var binarySearch = __webpack_require__(87);

  var ArraySet = __webpack_require__(84).ArraySet;

  var base64VLQ = __webpack_require__(81);

  var quickSort = __webpack_require__(88).quickSort;

  function SourceMapConsumer(aSourceMap) {
    var sourceMap = aSourceMap;

    if (typeof aSourceMap === 'string') {
      sourceMap = JSON.parse(aSourceMap.replace(/^\)\]\}'/, ''));
    }

    return sourceMap.sections != null ? new IndexedSourceMapConsumer(sourceMap) : new BasicSourceMapConsumer(sourceMap);
  }

  SourceMapConsumer.fromSourceMap = function (aSourceMap) {
    return BasicSourceMapConsumer.fromSourceMap(aSourceMap);
  };
  /**
   * The version of the source mapping spec that we are consuming.
   */


  SourceMapConsumer.prototype._version = 3; // `__generatedMappings` and `__originalMappings` are arrays that hold the
  // parsed mapping coordinates from the source map's "mappings" attribute. They
  // are lazily instantiated, accessed via the `_generatedMappings` and
  // `_originalMappings` getters respectively, and we only parse the mappings
  // and create these arrays once queried for a source location. We jump through
  // these hoops because there can be many thousands of mappings, and parsing
  // them is expensive, so we only want to do it if we must.
  //
  // Each object in the arrays is of the form:
  //
  //     {
  //       generatedLine: The line number in the generated code,
  //       generatedColumn: The column number in the generated code,
  //       source: The path to the original source file that generated this
  //               chunk of code,
  //       originalLine: The line number in the original source that
  //                     corresponds to this chunk of generated code,
  //       originalColumn: The column number in the original source that
  //                       corresponds to this chunk of generated code,
  //       name: The name of the original symbol which generated this chunk of
  //             code.
  //     }
  //
  // All properties except for `generatedLine` and `generatedColumn` can be
  // `null`.
  //
  // `_generatedMappings` is ordered by the generated positions.
  //
  // `_originalMappings` is ordered by the original positions.

  SourceMapConsumer.prototype.__generatedMappings = null;
  Object.defineProperty(SourceMapConsumer.prototype, '_generatedMappings', {
    get: function get() {
      if (!this.__generatedMappings) {
        this._parseMappings(this._mappings, this.sourceRoot);
      }

      return this.__generatedMappings;
    }
  });
  SourceMapConsumer.prototype.__originalMappings = null;
  Object.defineProperty(SourceMapConsumer.prototype, '_originalMappings', {
    get: function get() {
      if (!this.__originalMappings) {
        this._parseMappings(this._mappings, this.sourceRoot);
      }

      return this.__originalMappings;
    }
  });

  SourceMapConsumer.prototype._charIsMappingSeparator = function SourceMapConsumer_charIsMappingSeparator(aStr, index) {
    var c = aStr.charAt(index);
    return c === ";" || c === ",";
  };
  /**
   * Parse the mappings in a string in to a data structure which we can easily
   * query (the ordered arrays in the `this.__generatedMappings` and
   * `this.__originalMappings` properties).
   */


  SourceMapConsumer.prototype._parseMappings = function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {
    throw new Error("Subclasses must implement _parseMappings");
  };

  SourceMapConsumer.GENERATED_ORDER = 1;
  SourceMapConsumer.ORIGINAL_ORDER = 2;
  SourceMapConsumer.GREATEST_LOWER_BOUND = 1;
  SourceMapConsumer.LEAST_UPPER_BOUND = 2;
  /**
   * Iterate over each mapping between an original source/line/column and a
   * generated line/column in this source map.
   *
   * @param Function aCallback
   *        The function that is called with each mapping.
   * @param Object aContext
   *        Optional. If specified, this object will be the value of `this` every
   *        time that `aCallback` is called.
   * @param aOrder
   *        Either `SourceMapConsumer.GENERATED_ORDER` or
   *        `SourceMapConsumer.ORIGINAL_ORDER`. Specifies whether you want to
   *        iterate over the mappings sorted by the generated file's line/column
   *        order or the original's source/line/column order, respectively. Defaults to
   *        `SourceMapConsumer.GENERATED_ORDER`.
   */

  SourceMapConsumer.prototype.eachMapping = function SourceMapConsumer_eachMapping(aCallback, aContext, aOrder) {
    var context = aContext || null;
    var order = aOrder || SourceMapConsumer.GENERATED_ORDER;
    var mappings;

    switch (order) {
      case SourceMapConsumer.GENERATED_ORDER:
        mappings = this._generatedMappings;
        break;

      case SourceMapConsumer.ORIGINAL_ORDER:
        mappings = this._originalMappings;
        break;

      default:
        throw new Error("Unknown order of iteration.");
    }

    var sourceRoot = this.sourceRoot;
    mappings.map(function (mapping) {
      var source = mapping.source === null ? null : this._sources.at(mapping.source);

      if (source != null && sourceRoot != null) {
        source = util.join(sourceRoot, source);
      }

      return {
        source: source,
        generatedLine: mapping.generatedLine,
        generatedColumn: mapping.generatedColumn,
        originalLine: mapping.originalLine,
        originalColumn: mapping.originalColumn,
        name: mapping.name === null ? null : this._names.at(mapping.name)
      };
    }, this).forEach(aCallback, context);
  };
  /**
   * Returns all generated line and column information for the original source,
   * line, and column provided. If no column is provided, returns all mappings
   * corresponding to a either the line we are searching for or the next
   * closest line that has any mappings. Otherwise, returns all mappings
   * corresponding to the given line and either the column we are searching for
   * or the next closest column that has any offsets.
   *
   * The only argument is an object with the following properties:
   *
   *   - source: The filename of the original source.
   *   - line: The line number in the original source.
   *   - column: Optional. the column number in the original source.
   *
   * and an array of objects is returned, each with the following properties:
   *
   *   - line: The line number in the generated source, or null.
   *   - column: The column number in the generated source, or null.
   */


  SourceMapConsumer.prototype.allGeneratedPositionsFor = function SourceMapConsumer_allGeneratedPositionsFor(aArgs) {
    var line = util.getArg(aArgs, 'line'); // When there is no exact match, BasicSourceMapConsumer.prototype._findMapping
    // returns the index of the closest mapping less than the needle. By
    // setting needle.originalColumn to 0, we thus find the last mapping for
    // the given line, provided such a mapping exists.

    var needle = {
      source: util.getArg(aArgs, 'source'),
      originalLine: line,
      originalColumn: util.getArg(aArgs, 'column', 0)
    };

    if (this.sourceRoot != null) {
      needle.source = util.relative(this.sourceRoot, needle.source);
    }

    if (!this._sources.has(needle.source)) {
      return [];
    }

    needle.source = this._sources.indexOf(needle.source);
    var mappings = [];

    var index = this._findMapping(needle, this._originalMappings, "originalLine", "originalColumn", util.compareByOriginalPositions, binarySearch.LEAST_UPPER_BOUND);

    if (index >= 0) {
      var mapping = this._originalMappings[index];

      if (aArgs.column === undefined) {
        var originalLine = mapping.originalLine; // Iterate until either we run out of mappings, or we run into
        // a mapping for a different line than the one we found. Since
        // mappings are sorted, this is guaranteed to find all mappings for
        // the line we found.

        while (mapping && mapping.originalLine === originalLine) {
          mappings.push({
            line: util.getArg(mapping, 'generatedLine', null),
            column: util.getArg(mapping, 'generatedColumn', null),
            lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)
          });
          mapping = this._originalMappings[++index];
        }
      } else {
        var originalColumn = mapping.originalColumn; // Iterate until either we run out of mappings, or we run into
        // a mapping for a different line than the one we were searching for.
        // Since mappings are sorted, this is guaranteed to find all mappings for
        // the line we are searching for.

        while (mapping && mapping.originalLine === line && mapping.originalColumn == originalColumn) {
          mappings.push({
            line: util.getArg(mapping, 'generatedLine', null),
            column: util.getArg(mapping, 'generatedColumn', null),
            lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)
          });
          mapping = this._originalMappings[++index];
        }
      }
    }

    return mappings;
  };

  exports.SourceMapConsumer = SourceMapConsumer;
  /**
   * A BasicSourceMapConsumer instance represents a parsed source map which we can
   * query for information about the original file positions by giving it a file
   * position in the generated source.
   *
   * The only parameter is the raw source map (either as a JSON string, or
   * already parsed to an object). According to the spec, source maps have the
   * following attributes:
   *
   *   - version: Which version of the source map spec this map is following.
   *   - sources: An array of URLs to the original source files.
   *   - names: An array of identifiers which can be referrenced by individual mappings.
   *   - sourceRoot: Optional. The URL root from which all sources are relative.
   *   - sourcesContent: Optional. An array of contents of the original source files.
   *   - mappings: A string of base64 VLQs which contain the actual mappings.
   *   - file: Optional. The generated file this source map is associated with.
   *
   * Here is an example source map, taken from the source map spec[0]:
   *
   *     {
   *       version : 3,
   *       file: "out.js",
   *       sourceRoot : "",
   *       sources: ["foo.js", "bar.js"],
   *       names: ["src", "maps", "are", "fun"],
   *       mappings: "AA,AB;;ABCDE;"
   *     }
   *
   * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit?pli=1#
   */

  function BasicSourceMapConsumer(aSourceMap) {
    var sourceMap = aSourceMap;

    if (typeof aSourceMap === 'string') {
      sourceMap = JSON.parse(aSourceMap.replace(/^\)\]\}'/, ''));
    }

    var version = util.getArg(sourceMap, 'version');
    var sources = util.getArg(sourceMap, 'sources'); // Sass 3.3 leaves out the 'names' array, so we deviate from the spec (which
    // requires the array) to play nice here.

    var names = util.getArg(sourceMap, 'names', []);
    var sourceRoot = util.getArg(sourceMap, 'sourceRoot', null);
    var sourcesContent = util.getArg(sourceMap, 'sourcesContent', null);
    var mappings = util.getArg(sourceMap, 'mappings');
    var file = util.getArg(sourceMap, 'file', null); // Once again, Sass deviates from the spec and supplies the version as a
    // string rather than a number, so we use loose equality checking here.

    if (version != this._version) {
      throw new Error('Unsupported version: ' + version);
    }

    sources = sources.map(String) // Some source maps produce relative source paths like "./foo.js" instead of
    // "foo.js".  Normalize these first so that future comparisons will succeed.
    // See bugzil.la/1090768.
    .map(util.normalize) // Always ensure that absolute sources are internally stored relative to
    // the source root, if the source root is absolute. Not doing this would
    // be particularly problematic when the source root is a prefix of the
    // source (valid, but why??). See github issue #199 and bugzil.la/1188982.
    .map(function (source) {
      return sourceRoot && util.isAbsolute(sourceRoot) && util.isAbsolute(source) ? util.relative(sourceRoot, source) : source;
    }); // Pass `true` below to allow duplicate names and sources. While source maps
    // are intended to be compressed and deduplicated, the TypeScript compiler
    // sometimes generates source maps with duplicates in them. See Github issue
    // #72 and bugzil.la/889492.

    this._names = ArraySet.fromArray(names.map(String), true);
    this._sources = ArraySet.fromArray(sources, true);
    this.sourceRoot = sourceRoot;
    this.sourcesContent = sourcesContent;
    this._mappings = mappings;
    this.file = file;
  }

  BasicSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);
  BasicSourceMapConsumer.prototype.consumer = SourceMapConsumer;
  /**
   * Create a BasicSourceMapConsumer from a SourceMapGenerator.
   *
   * @param SourceMapGenerator aSourceMap
   *        The source map that will be consumed.
   * @returns BasicSourceMapConsumer
   */

  BasicSourceMapConsumer.fromSourceMap = function SourceMapConsumer_fromSourceMap(aSourceMap) {
    var smc = Object.create(BasicSourceMapConsumer.prototype);
    var names = smc._names = ArraySet.fromArray(aSourceMap._names.toArray(), true);
    var sources = smc._sources = ArraySet.fromArray(aSourceMap._sources.toArray(), true);
    smc.sourceRoot = aSourceMap._sourceRoot;
    smc.sourcesContent = aSourceMap._generateSourcesContent(smc._sources.toArray(), smc.sourceRoot);
    smc.file = aSourceMap._file; // Because we are modifying the entries (by converting string sources and
    // names to indices into the sources and names ArraySets), we have to make
    // a copy of the entry or else bad things happen. Shared mutable state
    // strikes again! See github issue #191.

    var generatedMappings = aSourceMap._mappings.toArray().slice();

    var destGeneratedMappings = smc.__generatedMappings = [];
    var destOriginalMappings = smc.__originalMappings = [];

    for (var i = 0, length = generatedMappings.length; i < length; i++) {
      var srcMapping = generatedMappings[i];
      var destMapping = new Mapping();
      destMapping.generatedLine = srcMapping.generatedLine;
      destMapping.generatedColumn = srcMapping.generatedColumn;

      if (srcMapping.source) {
        destMapping.source = sources.indexOf(srcMapping.source);
        destMapping.originalLine = srcMapping.originalLine;
        destMapping.originalColumn = srcMapping.originalColumn;

        if (srcMapping.name) {
          destMapping.name = names.indexOf(srcMapping.name);
        }

        destOriginalMappings.push(destMapping);
      }

      destGeneratedMappings.push(destMapping);
    }

    quickSort(smc.__originalMappings, util.compareByOriginalPositions);
    return smc;
  };
  /**
   * The version of the source mapping spec that we are consuming.
   */


  BasicSourceMapConsumer.prototype._version = 3;
  /**
   * The list of original sources.
   */

  Object.defineProperty(BasicSourceMapConsumer.prototype, 'sources', {
    get: function get() {
      return this._sources.toArray().map(function (s) {
        return this.sourceRoot != null ? util.join(this.sourceRoot, s) : s;
      }, this);
    }
  });
  /**
   * Provide the JIT with a nice shape / hidden class.
   */

  function Mapping() {
    this.generatedLine = 0;
    this.generatedColumn = 0;
    this.source = null;
    this.originalLine = null;
    this.originalColumn = null;
    this.name = null;
  }
  /**
   * Parse the mappings in a string in to a data structure which we can easily
   * query (the ordered arrays in the `this.__generatedMappings` and
   * `this.__originalMappings` properties).
   */


  BasicSourceMapConsumer.prototype._parseMappings = function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {
    var generatedLine = 1;
    var previousGeneratedColumn = 0;
    var previousOriginalLine = 0;
    var previousOriginalColumn = 0;
    var previousSource = 0;
    var previousName = 0;
    var length = aStr.length;
    var index = 0;
    var cachedSegments = {};
    var temp = {};
    var originalMappings = [];
    var generatedMappings = [];
    var mapping, str, segment, end, value;

    while (index < length) {
      if (aStr.charAt(index) === ';') {
        generatedLine++;
        index++;
        previousGeneratedColumn = 0;
      } else if (aStr.charAt(index) === ',') {
        index++;
      } else {
        mapping = new Mapping();
        mapping.generatedLine = generatedLine; // Because each offset is encoded relative to the previous one,
        // many segments often have the same encoding. We can exploit this
        // fact by caching the parsed variable length fields of each segment,
        // allowing us to avoid a second parse if we encounter the same
        // segment again.

        for (end = index; end < length; end++) {
          if (this._charIsMappingSeparator(aStr, end)) {
            break;
          }
        }

        str = aStr.slice(index, end);
        segment = cachedSegments[str];

        if (segment) {
          index += str.length;
        } else {
          segment = [];

          while (index < end) {
            base64VLQ.decode(aStr, index, temp);
            value = temp.value;
            index = temp.rest;
            segment.push(value);
          }

          if (segment.length === 2) {
            throw new Error('Found a source, but no line and column');
          }

          if (segment.length === 3) {
            throw new Error('Found a source and line, but no column');
          }

          cachedSegments[str] = segment;
        } // Generated column.


        mapping.generatedColumn = previousGeneratedColumn + segment[0];
        previousGeneratedColumn = mapping.generatedColumn;

        if (segment.length > 1) {
          // Original source.
          mapping.source = previousSource + segment[1];
          previousSource += segment[1]; // Original line.

          mapping.originalLine = previousOriginalLine + segment[2];
          previousOriginalLine = mapping.originalLine; // Lines are stored 0-based

          mapping.originalLine += 1; // Original column.

          mapping.originalColumn = previousOriginalColumn + segment[3];
          previousOriginalColumn = mapping.originalColumn;

          if (segment.length > 4) {
            // Original name.
            mapping.name = previousName + segment[4];
            previousName += segment[4];
          }
        }

        generatedMappings.push(mapping);

        if (typeof mapping.originalLine === 'number') {
          originalMappings.push(mapping);
        }
      }
    }

    quickSort(generatedMappings, util.compareByGeneratedPositionsDeflated);
    this.__generatedMappings = generatedMappings;
    quickSort(originalMappings, util.compareByOriginalPositions);
    this.__originalMappings = originalMappings;
  };
  /**
   * Find the mapping that best matches the hypothetical "needle" mapping that
   * we are searching for in the given "haystack" of mappings.
   */


  BasicSourceMapConsumer.prototype._findMapping = function SourceMapConsumer_findMapping(aNeedle, aMappings, aLineName, aColumnName, aComparator, aBias) {
    // To return the position we are searching for, we must first find the
    // mapping for the given position and then return the opposite position it
    // points to. Because the mappings are sorted, we can use binary search to
    // find the best mapping.
    if (aNeedle[aLineName] <= 0) {
      throw new TypeError('Line must be greater than or equal to 1, got ' + aNeedle[aLineName]);
    }

    if (aNeedle[aColumnName] < 0) {
      throw new TypeError('Column must be greater than or equal to 0, got ' + aNeedle[aColumnName]);
    }

    return binarySearch.search(aNeedle, aMappings, aComparator, aBias);
  };
  /**
   * Compute the last column for each generated mapping. The last column is
   * inclusive.
   */


  BasicSourceMapConsumer.prototype.computeColumnSpans = function SourceMapConsumer_computeColumnSpans() {
    for (var index = 0; index < this._generatedMappings.length; ++index) {
      var mapping = this._generatedMappings[index]; // Mappings do not contain a field for the last generated columnt. We
      // can come up with an optimistic estimate, however, by assuming that
      // mappings are contiguous (i.e. given two consecutive mappings, the
      // first mapping ends where the second one starts).

      if (index + 1 < this._generatedMappings.length) {
        var nextMapping = this._generatedMappings[index + 1];

        if (mapping.generatedLine === nextMapping.generatedLine) {
          mapping.lastGeneratedColumn = nextMapping.generatedColumn - 1;
          continue;
        }
      } // The last mapping for each line spans the entire line.


      mapping.lastGeneratedColumn = Infinity;
    }
  };
  /**
   * Returns the original source, line, and column information for the generated
   * source's line and column positions provided. The only argument is an object
   * with the following properties:
   *
   *   - line: The line number in the generated source.
   *   - column: The column number in the generated source.
   *   - bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or
   *     'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the
   *     closest element that is smaller than or greater than the one we are
   *     searching for, respectively, if the exact element cannot be found.
   *     Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'.
   *
   * and an object is returned with the following properties:
   *
   *   - source: The original source file, or null.
   *   - line: The line number in the original source, or null.
   *   - column: The column number in the original source, or null.
   *   - name: The original identifier, or null.
   */


  BasicSourceMapConsumer.prototype.originalPositionFor = function SourceMapConsumer_originalPositionFor(aArgs) {
    var needle = {
      generatedLine: util.getArg(aArgs, 'line'),
      generatedColumn: util.getArg(aArgs, 'column')
    };

    var index = this._findMapping(needle, this._generatedMappings, "generatedLine", "generatedColumn", util.compareByGeneratedPositionsDeflated, util.getArg(aArgs, 'bias', SourceMapConsumer.GREATEST_LOWER_BOUND));

    if (index >= 0) {
      var mapping = this._generatedMappings[index];

      if (mapping.generatedLine === needle.generatedLine) {
        var source = util.getArg(mapping, 'source', null);

        if (source !== null) {
          source = this._sources.at(source);

          if (this.sourceRoot != null) {
            source = util.join(this.sourceRoot, source);
          }
        }

        var name = util.getArg(mapping, 'name', null);

        if (name !== null) {
          name = this._names.at(name);
        }

        return {
          source: source,
          line: util.getArg(mapping, 'originalLine', null),
          column: util.getArg(mapping, 'originalColumn', null),
          name: name
        };
      }
    }

    return {
      source: null,
      line: null,
      column: null,
      name: null
    };
  };
  /**
   * Return true if we have the source content for every source in the source
   * map, false otherwise.
   */


  BasicSourceMapConsumer.prototype.hasContentsOfAllSources = function BasicSourceMapConsumer_hasContentsOfAllSources() {
    if (!this.sourcesContent) {
      return false;
    }

    return this.sourcesContent.length >= this._sources.size() && !this.sourcesContent.some(function (sc) {
      return sc == null;
    });
  };
  /**
   * Returns the original source content. The only argument is the url of the
   * original source file. Returns null if no original source content is
   * available.
   */


  BasicSourceMapConsumer.prototype.sourceContentFor = function SourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {
    if (!this.sourcesContent) {
      return null;
    }

    if (this.sourceRoot != null) {
      aSource = util.relative(this.sourceRoot, aSource);
    }

    if (this._sources.has(aSource)) {
      return this.sourcesContent[this._sources.indexOf(aSource)];
    }

    var url;

    if (this.sourceRoot != null && (url = util.urlParse(this.sourceRoot))) {
      // XXX: file:// URIs and absolute paths lead to unexpected behavior for
      // many users. We can help them out when they expect file:// URIs to
      // behave like it would if they were running a local HTTP server. See
      // https://bugzilla.mozilla.org/show_bug.cgi?id=885597.
      var fileUriAbsPath = aSource.replace(/^file:\/\//, "");

      if (url.scheme == "file" && this._sources.has(fileUriAbsPath)) {
        return this.sourcesContent[this._sources.indexOf(fileUriAbsPath)];
      }

      if ((!url.path || url.path == "/") && this._sources.has("/" + aSource)) {
        return this.sourcesContent[this._sources.indexOf("/" + aSource)];
      }
    } // This function is used recursively from
    // IndexedSourceMapConsumer.prototype.sourceContentFor. In that case, we
    // don't want to throw if we can't find the source - we just want to
    // return null, so we provide a flag to exit gracefully.


    if (nullOnMissing) {
      return null;
    } else {
      throw new Error('"' + aSource + '" is not in the SourceMap.');
    }
  };
  /**
   * Returns the generated line and column information for the original source,
   * line, and column positions provided. The only argument is an object with
   * the following properties:
   *
   *   - source: The filename of the original source.
   *   - line: The line number in the original source.
   *   - column: The column number in the original source.
   *   - bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or
   *     'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the
   *     closest element that is smaller than or greater than the one we are
   *     searching for, respectively, if the exact element cannot be found.
   *     Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'.
   *
   * and an object is returned with the following properties:
   *
   *   - line: The line number in the generated source, or null.
   *   - column: The column number in the generated source, or null.
   */


  BasicSourceMapConsumer.prototype.generatedPositionFor = function SourceMapConsumer_generatedPositionFor(aArgs) {
    var source = util.getArg(aArgs, 'source');

    if (this.sourceRoot != null) {
      source = util.relative(this.sourceRoot, source);
    }

    if (!this._sources.has(source)) {
      return {
        line: null,
        column: null,
        lastColumn: null
      };
    }

    source = this._sources.indexOf(source);
    var needle = {
      source: source,
      originalLine: util.getArg(aArgs, 'line'),
      originalColumn: util.getArg(aArgs, 'column')
    };

    var index = this._findMapping(needle, this._originalMappings, "originalLine", "originalColumn", util.compareByOriginalPositions, util.getArg(aArgs, 'bias', SourceMapConsumer.GREATEST_LOWER_BOUND));

    if (index >= 0) {
      var mapping = this._originalMappings[index];

      if (mapping.source === needle.source) {
        return {
          line: util.getArg(mapping, 'generatedLine', null),
          column: util.getArg(mapping, 'generatedColumn', null),
          lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)
        };
      }
    }

    return {
      line: null,
      column: null,
      lastColumn: null
    };
  };

  exports.BasicSourceMapConsumer = BasicSourceMapConsumer;
  /**
   * An IndexedSourceMapConsumer instance represents a parsed source map which
   * we can query for information. It differs from BasicSourceMapConsumer in
   * that it takes "indexed" source maps (i.e. ones with a "sections" field) as
   * input.
   *
   * The only parameter is a raw source map (either as a JSON string, or already
   * parsed to an object). According to the spec for indexed source maps, they
   * have the following attributes:
   *
   *   - version: Which version of the source map spec this map is following.
   *   - file: Optional. The generated file this source map is associated with.
   *   - sections: A list of section definitions.
   *
   * Each value under the "sections" field has two fields:
   *   - offset: The offset into the original specified at which this section
   *       begins to apply, defined as an object with a "line" and "column"
   *       field.
   *   - map: A source map definition. This source map could also be indexed,
   *       but doesn't have to be.
   *
   * Instead of the "map" field, it's also possible to have a "url" field
   * specifying a URL to retrieve a source map from, but that's currently
   * unsupported.
   *
   * Here's an example source map, taken from the source map spec[0], but
   * modified to omit a section which uses the "url" field.
   *
   *  {
   *    version : 3,
   *    file: "app.js",
   *    sections: [{
   *      offset: {line:100, column:10},
   *      map: {
   *        version : 3,
   *        file: "section.js",
   *        sources: ["foo.js", "bar.js"],
   *        names: ["src", "maps", "are", "fun"],
   *        mappings: "AAAA,E;;ABCDE;"
   *      }
   *    }],
   *  }
   *
   * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit#heading=h.535es3xeprgt
   */

  function IndexedSourceMapConsumer(aSourceMap) {
    var sourceMap = aSourceMap;

    if (typeof aSourceMap === 'string') {
      sourceMap = JSON.parse(aSourceMap.replace(/^\)\]\}'/, ''));
    }

    var version = util.getArg(sourceMap, 'version');
    var sections = util.getArg(sourceMap, 'sections');

    if (version != this._version) {
      throw new Error('Unsupported version: ' + version);
    }

    this._sources = new ArraySet();
    this._names = new ArraySet();
    var lastOffset = {
      line: -1,
      column: 0
    };
    this._sections = sections.map(function (s) {
      if (s.url) {
        // The url field will require support for asynchronicity.
        // See https://github.com/mozilla/source-map/issues/16
        throw new Error('Support for url field in sections not implemented.');
      }

      var offset = util.getArg(s, 'offset');
      var offsetLine = util.getArg(offset, 'line');
      var offsetColumn = util.getArg(offset, 'column');

      if (offsetLine < lastOffset.line || offsetLine === lastOffset.line && offsetColumn < lastOffset.column) {
        throw new Error('Section offsets must be ordered and non-overlapping.');
      }

      lastOffset = offset;
      return {
        generatedOffset: {
          // The offset fields are 0-based, but we use 1-based indices when
          // encoding/decoding from VLQ.
          generatedLine: offsetLine + 1,
          generatedColumn: offsetColumn + 1
        },
        consumer: new SourceMapConsumer(util.getArg(s, 'map'))
      };
    });
  }

  IndexedSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);
  IndexedSourceMapConsumer.prototype.constructor = SourceMapConsumer;
  /**
   * The version of the source mapping spec that we are consuming.
   */

  IndexedSourceMapConsumer.prototype._version = 3;
  /**
   * The list of original sources.
   */

  Object.defineProperty(IndexedSourceMapConsumer.prototype, 'sources', {
    get: function get() {
      var sources = [];

      for (var i = 0; i < this._sections.length; i++) {
        for (var j = 0; j < this._sections[i].consumer.sources.length; j++) {
          sources.push(this._sections[i].consumer.sources[j]);
        }
      }

      return sources;
    }
  });
  /**
   * Returns the original source, line, and column information for the generated
   * source's line and column positions provided. The only argument is an object
   * with the following properties:
   *
   *   - line: The line number in the generated source.
   *   - column: The column number in the generated source.
   *
   * and an object is returned with the following properties:
   *
   *   - source: The original source file, or null.
   *   - line: The line number in the original source, or null.
   *   - column: The column number in the original source, or null.
   *   - name: The original identifier, or null.
   */

  IndexedSourceMapConsumer.prototype.originalPositionFor = function IndexedSourceMapConsumer_originalPositionFor(aArgs) {
    var needle = {
      generatedLine: util.getArg(aArgs, 'line'),
      generatedColumn: util.getArg(aArgs, 'column')
    }; // Find the section containing the generated position we're trying to map
    // to an original position.

    var sectionIndex = binarySearch.search(needle, this._sections, function (needle, section) {
      var cmp = needle.generatedLine - section.generatedOffset.generatedLine;

      if (cmp) {
        return cmp;
      }

      return needle.generatedColumn - section.generatedOffset.generatedColumn;
    });
    var section = this._sections[sectionIndex];

    if (!section) {
      return {
        source: null,
        line: null,
        column: null,
        name: null
      };
    }

    return section.consumer.originalPositionFor({
      line: needle.generatedLine - (section.generatedOffset.generatedLine - 1),
      column: needle.generatedColumn - (section.generatedOffset.generatedLine === needle.generatedLine ? section.generatedOffset.generatedColumn - 1 : 0),
      bias: aArgs.bias
    });
  };
  /**
   * Return true if we have the source content for every source in the source
   * map, false otherwise.
   */


  IndexedSourceMapConsumer.prototype.hasContentsOfAllSources = function IndexedSourceMapConsumer_hasContentsOfAllSources() {
    return this._sections.every(function (s) {
      return s.consumer.hasContentsOfAllSources();
    });
  };
  /**
   * Returns the original source content. The only argument is the url of the
   * original source file. Returns null if no original source content is
   * available.
   */


  IndexedSourceMapConsumer.prototype.sourceContentFor = function IndexedSourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {
    for (var i = 0; i < this._sections.length; i++) {
      var section = this._sections[i];
      var content = section.consumer.sourceContentFor(aSource, true);

      if (content) {
        return content;
      }
    }

    if (nullOnMissing) {
      return null;
    } else {
      throw new Error('"' + aSource + '" is not in the SourceMap.');
    }
  };
  /**
   * Returns the generated line and column information for the original source,
   * line, and column positions provided. The only argument is an object with
   * the following properties:
   *
   *   - source: The filename of the original source.
   *   - line: The line number in the original source.
   *   - column: The column number in the original source.
   *
   * and an object is returned with the following properties:
   *
   *   - line: The line number in the generated source, or null.
   *   - column: The column number in the generated source, or null.
   */


  IndexedSourceMapConsumer.prototype.generatedPositionFor = function IndexedSourceMapConsumer_generatedPositionFor(aArgs) {
    for (var i = 0; i < this._sections.length; i++) {
      var section = this._sections[i]; // Only consider this section if the requested source is in the list of
      // sources of the consumer.

      if (section.consumer.sources.indexOf(util.getArg(aArgs, 'source')) === -1) {
        continue;
      }

      var generatedPosition = section.consumer.generatedPositionFor(aArgs);

      if (generatedPosition) {
        var ret = {
          line: generatedPosition.line + (section.generatedOffset.generatedLine - 1),
          column: generatedPosition.column + (section.generatedOffset.generatedLine === generatedPosition.line ? section.generatedOffset.generatedColumn - 1 : 0)
        };
        return ret;
      }
    }

    return {
      line: null,
      column: null
    };
  };
  /**
   * Parse the mappings in a string in to a data structure which we can easily
   * query (the ordered arrays in the `this.__generatedMappings` and
   * `this.__originalMappings` properties).
   */


  IndexedSourceMapConsumer.prototype._parseMappings = function IndexedSourceMapConsumer_parseMappings(aStr, aSourceRoot) {
    this.__generatedMappings = [];
    this.__originalMappings = [];

    for (var i = 0; i < this._sections.length; i++) {
      var section = this._sections[i];
      var sectionMappings = section.consumer._generatedMappings;

      for (var j = 0; j < sectionMappings.length; j++) {
        var mapping = sectionMappings[j];

        var source = section.consumer._sources.at(mapping.source);

        if (section.consumer.sourceRoot !== null) {
          source = util.join(section.consumer.sourceRoot, source);
        }

        this._sources.add(source);

        source = this._sources.indexOf(source);

        var name = section.consumer._names.at(mapping.name);

        this._names.add(name);

        name = this._names.indexOf(name); // The mappings coming from the consumer for the section have
        // generated positions relative to the start of the section, so we
        // need to offset them to be relative to the start of the concatenated
        // generated file.

        var adjustedMapping = {
          source: source,
          generatedLine: mapping.generatedLine + (section.generatedOffset.generatedLine - 1),
          generatedColumn: mapping.generatedColumn + (section.generatedOffset.generatedLine === mapping.generatedLine ? section.generatedOffset.generatedColumn - 1 : 0),
          originalLine: mapping.originalLine,
          originalColumn: mapping.originalColumn,
          name: name
        };

        this.__generatedMappings.push(adjustedMapping);

        if (typeof adjustedMapping.originalLine === 'number') {
          this.__originalMappings.push(adjustedMapping);
        }
      }
    }

    quickSort(this.__generatedMappings, util.compareByGeneratedPositionsDeflated);
    quickSort(this.__originalMappings, util.compareByOriginalPositions);
  };

  exports.IndexedSourceMapConsumer = IndexedSourceMapConsumer;
  /***/
},
/* 87 */

/***/
function (module, exports) {
  /* -*- Mode: js; js-indent-level: 2; -*- */

  /*
   * Copyright 2011 Mozilla Foundation and contributors
   * Licensed under the New BSD license. See LICENSE or:
   * http://opensource.org/licenses/BSD-3-Clause
   */
  exports.GREATEST_LOWER_BOUND = 1;
  exports.LEAST_UPPER_BOUND = 2;
  /**
   * Recursive implementation of binary search.
   *
   * @param aLow Indices here and lower do not contain the needle.
   * @param aHigh Indices here and higher do not contain the needle.
   * @param aNeedle The element being searched for.
   * @param aHaystack The non-empty array being searched.
   * @param aCompare Function which takes two elements and returns -1, 0, or 1.
   * @param aBias Either 'binarySearch.GREATEST_LOWER_BOUND' or
   *     'binarySearch.LEAST_UPPER_BOUND'. Specifies whether to return the
   *     closest element that is smaller than or greater than the one we are
   *     searching for, respectively, if the exact element cannot be found.
   */

  function recursiveSearch(aLow, aHigh, aNeedle, aHaystack, aCompare, aBias) {
    // This function terminates when one of the following is true:
    //
    //   1. We find the exact element we are looking for.
    //
    //   2. We did not find the exact element, but we can return the index of
    //      the next-closest element.
    //
    //   3. We did not find the exact element, and there is no next-closest
    //      element than the one we are searching for, so we return -1.
    var mid = Math.floor((aHigh - aLow) / 2) + aLow;
    var cmp = aCompare(aNeedle, aHaystack[mid], true);

    if (cmp === 0) {
      // Found the element we are looking for.
      return mid;
    } else if (cmp > 0) {
      // Our needle is greater than aHaystack[mid].
      if (aHigh - mid > 1) {
        // The element is in the upper half.
        return recursiveSearch(mid, aHigh, aNeedle, aHaystack, aCompare, aBias);
      } // The exact needle element was not found in this haystack. Determine if
      // we are in termination case (3) or (2) and return the appropriate thing.


      if (aBias == exports.LEAST_UPPER_BOUND) {
        return aHigh < aHaystack.length ? aHigh : -1;
      } else {
        return mid;
      }
    } else {
      // Our needle is less than aHaystack[mid].
      if (mid - aLow > 1) {
        // The element is in the lower half.
        return recursiveSearch(aLow, mid, aNeedle, aHaystack, aCompare, aBias);
      } // we are in termination case (3) or (2) and return the appropriate thing.


      if (aBias == exports.LEAST_UPPER_BOUND) {
        return mid;
      } else {
        return aLow < 0 ? -1 : aLow;
      }
    }
  }
  /**
   * This is an implementation of binary search which will always try and return
   * the index of the closest element if there is no exact hit. This is because
   * mappings between original and generated line/col pairs are single points,
   * and there is an implicit region between each of them, so a miss just means
   * that you aren't on the very start of a region.
   *
   * @param aNeedle The element you are looking for.
   * @param aHaystack The array that is being searched.
   * @param aCompare A function which takes the needle and an element in the
   *     array and returns -1, 0, or 1 depending on whether the needle is less
   *     than, equal to, or greater than the element, respectively.
   * @param aBias Either 'binarySearch.GREATEST_LOWER_BOUND' or
   *     'binarySearch.LEAST_UPPER_BOUND'. Specifies whether to return the
   *     closest element that is smaller than or greater than the one we are
   *     searching for, respectively, if the exact element cannot be found.
   *     Defaults to 'binarySearch.GREATEST_LOWER_BOUND'.
   */


  exports.search = function search(aNeedle, aHaystack, aCompare, aBias) {
    if (aHaystack.length === 0) {
      return -1;
    }

    var index = recursiveSearch(-1, aHaystack.length, aNeedle, aHaystack, aCompare, aBias || exports.GREATEST_LOWER_BOUND);

    if (index < 0) {
      return -1;
    } // We have found either the exact element, or the next-closest element than
    // the one we are searching for. However, there may be more than one such
    // element. Make sure we always return the smallest of these.


    while (index - 1 >= 0) {
      if (aCompare(aHaystack[index], aHaystack[index - 1], true) !== 0) {
        break;
      }

      --index;
    }

    return index;
  };
  /***/

},
/* 88 */

/***/
function (module, exports) {
  /* -*- Mode: js; js-indent-level: 2; -*- */

  /*
   * Copyright 2011 Mozilla Foundation and contributors
   * Licensed under the New BSD license. See LICENSE or:
   * http://opensource.org/licenses/BSD-3-Clause
   */
  // It turns out that some (most?) JavaScript engines don't self-host
  // `Array.prototype.sort`. This makes sense because C++ will likely remain
  // faster than JS when doing raw CPU-intensive sorting. However, when using a
  // custom comparator function, calling back and forth between the VM's C++ and
  // JIT'd JS is rather slow *and* loses JIT type information, resulting in
  // worse generated code for the comparator function than would be optimal. In
  // fact, when sorting with a comparator, these costs outweigh the benefits of
  // sorting in C++. By using our own JS-implemented Quick Sort (below), we get
  // a ~3500ms mean speed-up in `bench/bench.html`.

  /**
   * Swap the elements indexed by `x` and `y` in the array `ary`.
   *
   * @param {Array} ary
   *        The array.
   * @param {Number} x
   *        The index of the first item.
   * @param {Number} y
   *        The index of the second item.
   */
  function swap(ary, x, y) {
    var temp = ary[x];
    ary[x] = ary[y];
    ary[y] = temp;
  }
  /**
   * Returns a random integer within the range `low .. high` inclusive.
   *
   * @param {Number} low
   *        The lower bound on the range.
   * @param {Number} high
   *        The upper bound on the range.
   */


  function randomIntInRange(low, high) {
    return Math.round(low + Math.random() * (high - low));
  }
  /**
   * The Quick Sort algorithm.
   *
   * @param {Array} ary
   *        An array to sort.
   * @param {function} comparator
   *        Function to use to compare two items.
   * @param {Number} p
   *        Start index of the array
   * @param {Number} r
   *        End index of the array
   */


  function doQuickSort(ary, comparator, p, r) {
    // If our lower bound is less than our upper bound, we (1) partition the
    // array into two pieces and (2) recurse on each half. If it is not, this is
    // the empty array and our base case.
    if (p < r) {
      // (1) Partitioning.
      //
      // The partitioning chooses a pivot between `p` and `r` and moves all
      // elements that are less than or equal to the pivot to the before it, and
      // all the elements that are greater than it after it. The effect is that
      // once partition is done, the pivot is in the exact place it will be when
      // the array is put in sorted order, and it will not need to be moved
      // again. This runs in O(n) time.
      // Always choose a random pivot so that an input array which is reverse
      // sorted does not cause O(n^2) running time.
      var pivotIndex = randomIntInRange(p, r);
      var i = p - 1;
      swap(ary, pivotIndex, r);
      var pivot = ary[r]; // Immediately after `j` is incremented in this loop, the following hold
      // true:
      //
      //   * Every element in `ary[p .. i]` is less than or equal to the pivot.
      //
      //   * Every element in `ary[i+1 .. j-1]` is greater than the pivot.

      for (var j = p; j < r; j++) {
        if (comparator(ary[j], pivot) <= 0) {
          i += 1;
          swap(ary, i, j);
        }
      }

      swap(ary, i + 1, j);
      var q = i + 1; // (2) Recurse on each half.

      doQuickSort(ary, comparator, p, q - 1);
      doQuickSort(ary, comparator, q + 1, r);
    }
  }
  /**
   * Sort the given array in-place with the given comparator function.
   *
   * @param {Array} ary
   *        An array to sort.
   * @param {function} comparator
   *        Function to use to compare two items.
   */


  exports.quickSort = function (ary, comparator) {
    doQuickSort(ary, comparator, 0, ary.length - 1);
  };
  /***/

},
/* 89 */

/***/
function (module, exports, __webpack_require__) {
  /* -*- Mode: js; js-indent-level: 2; -*- */

  /*
   * Copyright 2011 Mozilla Foundation and contributors
   * Licensed under the New BSD license. See LICENSE or:
   * http://opensource.org/licenses/BSD-3-Clause
   */
  var SourceMapGenerator = __webpack_require__(80).SourceMapGenerator;

  var util = __webpack_require__(83); // Matches a Windows-style `\r\n` newline or a `\n` newline used by all other
  // operating systems these days (capturing the result).


  var REGEX_NEWLINE = /(\r?\n)/; // Newline character code for charCodeAt() comparisons

  var NEWLINE_CODE = 10; // Private symbol for identifying `SourceNode`s when multiple versions of
  // the source-map library are loaded. This MUST NOT CHANGE across
  // versions!

  var isSourceNode = "$$$isSourceNode$$$";
  /**
   * SourceNodes provide a way to abstract over interpolating/concatenating
   * snippets of generated JavaScript source code while maintaining the line and
   * column information associated with the original source code.
   *
   * @param aLine The original line number.
   * @param aColumn The original column number.
   * @param aSource The original source's filename.
   * @param aChunks Optional. An array of strings which are snippets of
   *        generated JS, or other SourceNodes.
   * @param aName The original identifier.
   */

  function SourceNode(aLine, aColumn, aSource, aChunks, aName) {
    this.children = [];
    this.sourceContents = {};
    this.line = aLine == null ? null : aLine;
    this.column = aColumn == null ? null : aColumn;
    this.source = aSource == null ? null : aSource;
    this.name = aName == null ? null : aName;
    this[isSourceNode] = true;
    if (aChunks != null) this.add(aChunks);
  }
  /**
   * Creates a SourceNode from generated code and a SourceMapConsumer.
   *
   * @param aGeneratedCode The generated code
   * @param aSourceMapConsumer The SourceMap for the generated code
   * @param aRelativePath Optional. The path that relative sources in the
   *        SourceMapConsumer should be relative to.
   */


  SourceNode.fromStringWithSourceMap = function SourceNode_fromStringWithSourceMap(aGeneratedCode, aSourceMapConsumer, aRelativePath) {
    // The SourceNode we want to fill with the generated code
    // and the SourceMap
    var node = new SourceNode(); // All even indices of this array are one line of the generated code,
    // while all odd indices are the newlines between two adjacent lines
    // (since `REGEX_NEWLINE` captures its match).
    // Processed fragments are accessed by calling `shiftNextLine`.

    var remainingLines = aGeneratedCode.split(REGEX_NEWLINE);
    var remainingLinesIndex = 0;

    var shiftNextLine = function shiftNextLine() {
      var lineContents = getNextLine(); // The last line of a file might not have a newline.

      var newLine = getNextLine() || "";
      return lineContents + newLine;

      function getNextLine() {
        return remainingLinesIndex < remainingLines.length ? remainingLines[remainingLinesIndex++] : undefined;
      }
    }; // We need to remember the position of "remainingLines"


    var lastGeneratedLine = 1,
        lastGeneratedColumn = 0; // The generate SourceNodes we need a code range.
    // To extract it current and last mapping is used.
    // Here we store the last mapping.

    var lastMapping = null;
    aSourceMapConsumer.eachMapping(function (mapping) {
      if (lastMapping !== null) {
        // We add the code from "lastMapping" to "mapping":
        // First check if there is a new line in between.
        if (lastGeneratedLine < mapping.generatedLine) {
          // Associate first line with "lastMapping"
          addMappingWithCode(lastMapping, shiftNextLine());
          lastGeneratedLine++;
          lastGeneratedColumn = 0; // The remaining code is added without mapping
        } else {
          // There is no new line in between.
          // Associate the code between "lastGeneratedColumn" and
          // "mapping.generatedColumn" with "lastMapping"
          var nextLine = remainingLines[remainingLinesIndex];
          var code = nextLine.substr(0, mapping.generatedColumn - lastGeneratedColumn);
          remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn - lastGeneratedColumn);
          lastGeneratedColumn = mapping.generatedColumn;
          addMappingWithCode(lastMapping, code); // No more remaining code, continue

          lastMapping = mapping;
          return;
        }
      } // We add the generated code until the first mapping
      // to the SourceNode without any mapping.
      // Each line is added as separate string.


      while (lastGeneratedLine < mapping.generatedLine) {
        node.add(shiftNextLine());
        lastGeneratedLine++;
      }

      if (lastGeneratedColumn < mapping.generatedColumn) {
        var nextLine = remainingLines[remainingLinesIndex];
        node.add(nextLine.substr(0, mapping.generatedColumn));
        remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn);
        lastGeneratedColumn = mapping.generatedColumn;
      }

      lastMapping = mapping;
    }, this); // We have processed all mappings.

    if (remainingLinesIndex < remainingLines.length) {
      if (lastMapping) {
        // Associate the remaining code in the current line with "lastMapping"
        addMappingWithCode(lastMapping, shiftNextLine());
      } // and add the remaining lines without any mapping


      node.add(remainingLines.splice(remainingLinesIndex).join(""));
    } // Copy sourcesContent into SourceNode


    aSourceMapConsumer.sources.forEach(function (sourceFile) {
      var content = aSourceMapConsumer.sourceContentFor(sourceFile);

      if (content != null) {
        if (aRelativePath != null) {
          sourceFile = util.join(aRelativePath, sourceFile);
        }

        node.setSourceContent(sourceFile, content);
      }
    });
    return node;

    function addMappingWithCode(mapping, code) {
      if (mapping === null || mapping.source === undefined) {
        node.add(code);
      } else {
        var source = aRelativePath ? util.join(aRelativePath, mapping.source) : mapping.source;
        node.add(new SourceNode(mapping.originalLine, mapping.originalColumn, source, code, mapping.name));
      }
    }
  };
  /**
   * Add a chunk of generated JS to this source node.
   *
   * @param aChunk A string snippet of generated JS code, another instance of
   *        SourceNode, or an array where each member is one of those things.
   */


  SourceNode.prototype.add = function SourceNode_add(aChunk) {
    if (Array.isArray(aChunk)) {
      aChunk.forEach(function (chunk) {
        this.add(chunk);
      }, this);
    } else if (aChunk[isSourceNode] || typeof aChunk === "string") {
      if (aChunk) {
        this.children.push(aChunk);
      }
    } else {
      throw new TypeError("Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk);
    }

    return this;
  };
  /**
   * Add a chunk of generated JS to the beginning of this source node.
   *
   * @param aChunk A string snippet of generated JS code, another instance of
   *        SourceNode, or an array where each member is one of those things.
   */


  SourceNode.prototype.prepend = function SourceNode_prepend(aChunk) {
    if (Array.isArray(aChunk)) {
      for (var i = aChunk.length - 1; i >= 0; i--) {
        this.prepend(aChunk[i]);
      }
    } else if (aChunk[isSourceNode] || typeof aChunk === "string") {
      this.children.unshift(aChunk);
    } else {
      throw new TypeError("Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk);
    }

    return this;
  };
  /**
   * Walk over the tree of JS snippets in this node and its children. The
   * walking function is called once for each snippet of JS and is passed that
   * snippet and the its original associated source's line/column location.
   *
   * @param aFn The traversal function.
   */


  SourceNode.prototype.walk = function SourceNode_walk(aFn) {
    var chunk;

    for (var i = 0, len = this.children.length; i < len; i++) {
      chunk = this.children[i];

      if (chunk[isSourceNode]) {
        chunk.walk(aFn);
      } else {
        if (chunk !== '') {
          aFn(chunk, {
            source: this.source,
            line: this.line,
            column: this.column,
            name: this.name
          });
        }
      }
    }
  };
  /**
   * Like `String.prototype.join` except for SourceNodes. Inserts `aStr` between
   * each of `this.children`.
   *
   * @param aSep The separator.
   */


  SourceNode.prototype.join = function SourceNode_join(aSep) {
    var newChildren;
    var i;
    var len = this.children.length;

    if (len > 0) {
      newChildren = [];

      for (i = 0; i < len - 1; i++) {
        newChildren.push(this.children[i]);
        newChildren.push(aSep);
      }

      newChildren.push(this.children[i]);
      this.children = newChildren;
    }

    return this;
  };
  /**
   * Call String.prototype.replace on the very right-most source snippet. Useful
   * for trimming whitespace from the end of a source node, etc.
   *
   * @param aPattern The pattern to replace.
   * @param aReplacement The thing to replace the pattern with.
   */


  SourceNode.prototype.replaceRight = function SourceNode_replaceRight(aPattern, aReplacement) {
    var lastChild = this.children[this.children.length - 1];

    if (lastChild[isSourceNode]) {
      lastChild.replaceRight(aPattern, aReplacement);
    } else if (typeof lastChild === 'string') {
      this.children[this.children.length - 1] = lastChild.replace(aPattern, aReplacement);
    } else {
      this.children.push(''.replace(aPattern, aReplacement));
    }

    return this;
  };
  /**
   * Set the source content for a source file. This will be added to the SourceMapGenerator
   * in the sourcesContent field.
   *
   * @param aSourceFile The filename of the source file
   * @param aSourceContent The content of the source file
   */


  SourceNode.prototype.setSourceContent = function SourceNode_setSourceContent(aSourceFile, aSourceContent) {
    this.sourceContents[util.toSetString(aSourceFile)] = aSourceContent;
  };
  /**
   * Walk over the tree of SourceNodes. The walking function is called for each
   * source file content and is passed the filename and source content.
   *
   * @param aFn The traversal function.
   */


  SourceNode.prototype.walkSourceContents = function SourceNode_walkSourceContents(aFn) {
    for (var i = 0, len = this.children.length; i < len; i++) {
      if (this.children[i][isSourceNode]) {
        this.children[i].walkSourceContents(aFn);
      }
    }

    var sources = Object.keys(this.sourceContents);

    for (var i = 0, len = sources.length; i < len; i++) {
      aFn(util.fromSetString(sources[i]), this.sourceContents[sources[i]]);
    }
  };
  /**
   * Return the string representation of this source node. Walks over the tree
   * and concatenates all the various snippets together to one string.
   */


  SourceNode.prototype.toString = function SourceNode_toString() {
    var str = "";
    this.walk(function (chunk) {
      str += chunk;
    });
    return str;
  };
  /**
   * Returns the string representation of this source node along with a source
   * map.
   */


  SourceNode.prototype.toStringWithSourceMap = function SourceNode_toStringWithSourceMap(aArgs) {
    var generated = {
      code: "",
      line: 1,
      column: 0
    };
    var map = new SourceMapGenerator(aArgs);
    var sourceMappingActive = false;
    var lastOriginalSource = null;
    var lastOriginalLine = null;
    var lastOriginalColumn = null;
    var lastOriginalName = null;
    this.walk(function (chunk, original) {
      generated.code += chunk;

      if (original.source !== null && original.line !== null && original.column !== null) {
        if (lastOriginalSource !== original.source || lastOriginalLine !== original.line || lastOriginalColumn !== original.column || lastOriginalName !== original.name) {
          map.addMapping({
            source: original.source,
            original: {
              line: original.line,
              column: original.column
            },
            generated: {
              line: generated.line,
              column: generated.column
            },
            name: original.name
          });
        }

        lastOriginalSource = original.source;
        lastOriginalLine = original.line;
        lastOriginalColumn = original.column;
        lastOriginalName = original.name;
        sourceMappingActive = true;
      } else if (sourceMappingActive) {
        map.addMapping({
          generated: {
            line: generated.line,
            column: generated.column
          }
        });
        lastOriginalSource = null;
        sourceMappingActive = false;
      }

      for (var idx = 0, length = chunk.length; idx < length; idx++) {
        if (chunk.charCodeAt(idx) === NEWLINE_CODE) {
          generated.line++;
          generated.column = 0; // Mappings end at eol

          if (idx + 1 === length) {
            lastOriginalSource = null;
            sourceMappingActive = false;
          } else if (sourceMappingActive) {
            map.addMapping({
              source: original.source,
              original: {
                line: original.line,
                column: original.column
              },
              generated: {
                line: generated.line,
                column: generated.column
              },
              name: original.name
            });
          }
        } else {
          generated.column++;
        }
      }
    });
    this.walkSourceContents(function (sourceFile, sourceContent) {
      map.setSourceContent(sourceFile, sourceContent);
    });
    return {
      code: generated.code,
      map: map
    };
  };

  exports.SourceNode = SourceNode;
  /***/
},
/* 90 */

/***/
function (module, exports, __webpack_require__) {
  var List = __webpack_require__(52);

  module.exports = function createConvertors(walk) {
    return {
      fromPlainObject: function fromPlainObject(ast) {
        walk(ast, {
          enter: function enter(node) {
            if (node.children && node.children instanceof List === false) {
              node.children = new List().fromArray(node.children);
            }
          }
        });
        return ast;
      },
      toPlainObject: function toPlainObject(ast) {
        walk(ast, {
          leave: function leave(node) {
            if (node.children && node.children instanceof List) {
              node.children = node.children.toArray();
            }
          }
        });
        return ast;
      }
    };
  };
  /***/

},
/* 91 */

/***/
function (module, exports, __webpack_require__) {
  ;

  var hasOwnProperty = Object.prototype.hasOwnProperty;

  var noop = function noop() {};

  function ensureFunction(value) {
    return typeof value === 'function' ? value : noop;
  }

  function invokeForType(fn, type) {
    return function (node, item, list) {
      if (node.type === type) {
        fn.call(this, node, item, list);
      }
    };
  }

  function getWalkersFromStructure(name, nodeType) {
    var structure = nodeType.structure;
    var walkers = [];

    for (var key in structure) {
      if (hasOwnProperty.call(structure, key) === false) {
        continue;
      }

      var fieldTypes = structure[key];
      var walker = {
        name: key,
        type: false,
        nullable: false
      };

      if (!Array.isArray(structure[key])) {
        fieldTypes = [structure[key]];
      }

      for (var i = 0; i < fieldTypes.length; i++) {
        var fieldType = fieldTypes[i];

        if (fieldType === null) {
          walker.nullable = true;
        } else if (typeof fieldType === 'string') {
          walker.type = 'node';
        } else if (Array.isArray(fieldType)) {
          walker.type = 'list';
        }
      }

      if (walker.type) {
        walkers.push(walker);
      }
    }

    if (walkers.length) {
      return {
        context: nodeType.walkContext,
        fields: walkers
      };
    }

    return null;
  }

  function getTypesFromConfig(config) {
    var types = {};

    for (var name in config.node) {
      if (hasOwnProperty.call(config.node, name)) {
        var nodeType = config.node[name];

        if (!nodeType.structure) {
          throw new Error('Missed `structure` field in `' + name + '` node type definition');
        }

        types[name] = getWalkersFromStructure(name, nodeType);
      }
    }

    return types;
  }

  function createTypeIterator(config, reverse) {
    var fields = reverse ? config.fields.slice().reverse() : config.fields;
    var body = fields.map(function (field) {
      var ref = 'node.' + field.name;
      var line;

      if (field.type === 'list') {
        line = reverse ? ref + '.forEachRight(walk);' : ref + '.forEach(walk);';
      } else {
        line = 'walk(' + ref + ');';
      }

      if (field.nullable) {
        line = 'if (' + ref + ') {\n    ' + line + '}';
      }

      return line;
    });

    if (config.context) {
      body = [].concat('var old = context.' + config.context + ';', 'context.' + config.context + ' = node;', body, 'context.' + config.context + ' = old;');
    }

    return new Function('node', 'context', 'walk', body.join('\n'));
  }

  function createFastTraveralMap(iterators) {
    return {
      Atrule: {
        StyleSheet: iterators.StyleSheet,
        Atrule: iterators.Atrule,
        Rule: iterators.Rule,
        Block: iterators.Block
      },
      Rule: {
        StyleSheet: iterators.StyleSheet,
        Atrule: iterators.Atrule,
        Rule: iterators.Rule,
        Block: iterators.Block
      },
      Declaration: {
        StyleSheet: iterators.StyleSheet,
        Atrule: iterators.Atrule,
        Rule: iterators.Rule,
        Block: iterators.Block
      }
    };
  }

  module.exports = function createWalker(config) {
    var types = getTypesFromConfig(config);
    var iteratorsNatural = {};
    var iteratorsReverse = {};

    for (var name in types) {
      if (hasOwnProperty.call(types, name) && types[name] !== null) {
        iteratorsNatural[name] = createTypeIterator(types[name], false);
        iteratorsReverse[name] = createTypeIterator(types[name], true);
      }
    }

    var fastTraversalIteratorsNatural = createFastTraveralMap(iteratorsNatural);
    var fastTraversalIteratorsReverse = createFastTraveralMap(iteratorsReverse);
    return function walk(root, options) {
      function walkNode(node, item, list) {
        enter.call(context, node, item, list);

        if (iterators.hasOwnProperty(node.type)) {
          iterators[node.type](node, context, walkNode);
        }

        leave.call(context, node, item, list);
      }

      var enter = noop;
      var leave = noop;
      var iterators = iteratorsNatural;
      var context = {
        root: root,
        stylesheet: null,
        atrule: null,
        atrulePrelude: null,
        rule: null,
        selector: null,
        block: null,
        declaration: null,
        "function": null
      };

      if (typeof options === 'function') {
        enter = options;
      } else if (options) {
        enter = ensureFunction(options.enter);
        leave = ensureFunction(options.leave);

        if (options.reverse) {
          iterators = iteratorsReverse;
        }

        if (options.visit) {
          if (fastTraversalIteratorsNatural.hasOwnProperty(options.visit)) {
            iterators = options.reverse ? fastTraversalIteratorsReverse[options.visit] : fastTraversalIteratorsNatural[options.visit];
          } else if (!types.hasOwnProperty(options.visit)) {
            throw new Error('Bad value `' + options.visit + '` for `visit` option (should be: ' + Object.keys(types).join(', ') + ')');
          }

          enter = invokeForType(enter, options.visit);
          leave = invokeForType(leave, options.visit);
        }
      }

      if (enter === noop && leave === noop) {
        throw new Error('Neither `enter` nor `leave` walker handler is set or both aren\'t a function');
      } // swap handlers in reverse mode to invert visit order


      if (options.reverse) {
        var tmp = enter;
        enter = leave;
        leave = tmp;
      }

      walkNode(root);
    };
  };
  /***/

},
/* 92 */

/***/
function (module, exports, __webpack_require__) {
  ;

  var List = __webpack_require__(52);

  module.exports = function clone(node) {
    var result = {};

    for (var key in node) {
      var value = node[key];

      if (value) {
        if (Array.isArray(value) || value instanceof List) {
          value = value.map(clone);
        } else if (value.constructor === Object) {
          value = clone(value);
        }
      }

      result[key] = value;
    }

    return result;
  };
  /***/

},
/* 93 */

/***/
function (module, exports) {
  var hasOwnProperty = Object.prototype.hasOwnProperty;
  var shape = {
    generic: true,
    types: {},
    properties: {},
    parseContext: {},
    scope: {},
    atrule: ['parse'],
    pseudo: ['parse'],
    node: ['name', 'structure', 'parse', 'generate', 'walkContext']
  };

  function isObject(value) {
    return value && value.constructor === Object;
  }

  function copy(value) {
    if (isObject(value)) {
      var res = {};

      for (var key in value) {
        if (hasOwnProperty.call(value, key)) {
          res[key] = value[key];
        }
      }

      return res;
    } else {
      return value;
    }
  }

  function extend(dest, src) {
    for (var key in src) {
      if (hasOwnProperty.call(src, key)) {
        if (isObject(dest[key])) {
          extend(dest[key], copy(src[key]));
        } else {
          dest[key] = copy(src[key]);
        }
      }
    }
  }

  function mix(dest, src, shape) {
    for (var key in shape) {
      if (hasOwnProperty.call(shape, key) === false) {
        continue;
      }

      if (shape[key] === true) {
        if (key in src) {
          if (hasOwnProperty.call(src, key)) {
            dest[key] = copy(src[key]);
          }
        }
      } else if (shape[key]) {
        if (isObject(shape[key])) {
          var res = {};
          extend(res, dest[key]);
          extend(res, src[key]);
          dest[key] = res;
        } else if (Array.isArray(shape[key])) {
          var res = {};
          var innerShape = shape[key].reduce(function (s, k) {
            s[k] = true;
            return s;
          }, {});

          for (var name in dest[key]) {
            if (hasOwnProperty.call(dest[key], name)) {
              res[name] = {};

              if (dest[key] && dest[key][name]) {
                mix(res[name], dest[key][name], innerShape);
              }
            }
          }

          for (var name in src[key]) {
            if (hasOwnProperty.call(src[key], name)) {
              if (!res[name]) {
                res[name] = {};
              }

              if (src[key] && src[key][name]) {
                mix(res[name], src[key][name], innerShape);
              }
            }
          }

          dest[key] = res;
        }
      }
    }

    return dest;
  }

  module.exports = function (dest, src) {
    return mix(dest, src, shape);
  };
  /***/

},
/* 94 */

/***/
function (module, exports, __webpack_require__) {
  var data = __webpack_require__(95);

  module.exports = {
    generic: true,
    types: data.types,
    properties: data.properties,
    node: __webpack_require__(96)
  };
  /***/
},
/* 95 */

/***/
function (module) {
  module.exports = {
    "generic": true,
    "types": {
      "absolute-size": "xx-small | x-small | small | medium | large | x-large | xx-large",
      "alpha-value": "<number> | <percentage>",
      "angle-percentage": "<angle> | <percentage>",
      "animateable-feature": "scroll-position | contents | <custom-ident>",
      "attachment": "scroll | fixed | local",
      "auto-repeat": "repeat( [ auto-fill | auto-fit ] , [ <line-names>? <fixed-size> ]+ <line-names>? )",
      "auto-track-list": "[ <line-names>? [ <fixed-size> | <fixed-repeat> ] ]* <line-names>? <auto-repeat> [ <line-names>? [ <fixed-size> | <fixed-repeat> ] ]* <line-names>?",
      "baseline-position": "[ first | last ]? baseline",
      "basic-shape": "<inset()> | <circle()> | <ellipse()> | <polygon()>",
      "bg-image": "none | <image>",
      "bg-layer": "<bg-image> || <bg-position> [ / <bg-size> ]? || <repeat-style> || <attachment> || <box> || <box>",
      "bg-position": "[ [ left | center | right | top | bottom | <length-percentage> ] | [ left | center | right | <length-percentage> ] [ top | center | bottom | <length-percentage> ] | [ center | [ left | right ] <length-percentage>? ] && [ center | [ top | bottom ] <length-percentage>? ] ]",
      "bg-size": "[ <length-percentage> | auto ]{1,2} | cover | contain",
      "blur()": "blur( <length> )",
      "blend-mode": "normal | multiply | screen | overlay | darken | lighten | color-dodge | color-burn | hard-light | soft-light | difference | exclusion | hue | saturation | color | luminosity",
      "box": "border-box | padding-box | content-box",
      "br-style": "none | hidden | dotted | dashed | solid | double | groove | ridge | inset | outset",
      "br-width": "<length> | thin | medium | thick",
      "brightness()": "brightness( <number-percentage> )",
      "calc()": "calc( <calc-sum> )",
      "calc-sum": "<calc-product> [ [ '+' | '-' ] <calc-product> ]*",
      "calc-product": "<calc-value> [ '*' <calc-value> | '/' <number> ]*",
      "calc-value": "<number> | <dimension> | <percentage> | ( <calc-sum> )",
      "cf-final-image": "<image> | <color>",
      "cf-mixing-image": "<percentage>? && <image>",
      "circle()": "circle( [ <shape-radius> ]? [ at <position> ]? )",
      "clip-source": "<url>",
      "color": "<rgb()> | <rgba()> | <hsl()> | <hsla()> | <hex-color> | <named-color> | currentcolor | <deprecated-system-color>",
      "color-stop": "<color> <length-percentage>?",
      "color-stop-list": "<color-stop>#{2,}",
      "common-lig-values": "[ common-ligatures | no-common-ligatures ]",
      "composite-style": "clear | copy | source-over | source-in | source-out | source-atop | destination-over | destination-in | destination-out | destination-atop | xor",
      "compositing-operator": "add | subtract | intersect | exclude",
      "contextual-alt-values": "[ contextual | no-contextual ]",
      "content-distribution": "space-between | space-around | space-evenly | stretch",
      "content-list": "[ <string> | contents | <url> | <quote> | <attr()> | counter( <ident> , <'list-style-type'>? ) ]+",
      "content-position": "center | start | end | flex-start | flex-end",
      "content-replacement": "<image>",
      "contrast()": "contrast( [ <number-percentage> ] )",
      "counter-style": "<counter-style-name> | symbols( )",
      "counter-style-name": "<custom-ident>",
      "cross-fade()": "cross-fade( <cf-mixing-image> , <cf-final-image>? )",
      "cubic-bezier-timing-function": "ease | ease-in | ease-out | ease-in-out | cubic-bezier( <number> , <number> , <number> , <number> )",
      "deprecated-system-color": "ActiveBorder | ActiveCaption | AppWorkspace | Background | ButtonFace | ButtonHighlight | ButtonShadow | ButtonText | CaptionText | GrayText | Highlight | HighlightText | InactiveBorder | InactiveCaption | InactiveCaptionText | InfoBackground | InfoText | Menu | MenuText | Scrollbar | ThreeDDarkShadow | ThreeDFace | ThreeDHighlight | ThreeDLightShadow | ThreeDShadow | Window | WindowFrame | WindowText",
      "discretionary-lig-values": "[ discretionary-ligatures | no-discretionary-ligatures ]",
      "display-box": "contents | none",
      "display-inside": "flow | flow-root | table | flex | grid | subgrid | ruby",
      "display-internal": "table-row-group | table-header-group | table-footer-group | table-row | table-cell | table-column-group | table-column | table-caption | ruby-base | ruby-text | ruby-base-container | ruby-text-container",
      "display-legacy": "inline-block | inline-list-item | inline-table | inline-flex | inline-grid",
      "display-listitem": "<display-outside>? && [ flow | flow-root ]? && list-item",
      "display-outside": "block | inline | run-in",
      "drop-shadow()": "drop-shadow( <length>{2,3} <color>? )",
      "east-asian-variant-values": "[ jis78 | jis83 | jis90 | jis04 | simplified | traditional ]",
      "east-asian-width-values": "[ full-width | proportional-width ]",
      "element()": "element( <id-selector> )",
      "ellipse()": "ellipse( [ <shape-radius>{2} ]? [ at <position> ]? )",
      "ending-shape": "circle | ellipse",
      "explicit-track-list": "[ <line-names>? <track-size> ]+ <line-names>?",
      "family-name": "<string> | <custom-ident>+",
      "feature-tag-value": "<string> [ <integer> | on | off ]?",
      "feature-value-name": "<custom-ident>",
      "fill-rule": "nonzero | evenodd",
      "filter-function": "<blur()> | <brightness()> | <contrast()> | <drop-shadow()> | <grayscale()> | <hue-rotate()> | <invert()> | <opacity()> | <saturate()> | <sepia()>",
      "filter-function-list": "[ <filter-function> | <url> ]+",
      "final-bg-layer": "<'background-color'> || <bg-image> || <bg-position> [ / <bg-size> ]? || <repeat-style> || <attachment> || <box> || <box>",
      "fit-content()": "fit-content( [ <length> | <percentage> ] )",
      "fixed-breadth": "<length-percentage>",
      "fixed-repeat": "repeat( [ <positive-integer> ] , [ <line-names>? <fixed-size> ]+ <line-names>? )",
      "fixed-size": "<fixed-breadth> | minmax( <fixed-breadth> , <track-breadth> ) | minmax( <inflexible-breadth> , <fixed-breadth> )",
      "font-variant-css21": "[ normal | small-caps ]",
      "frames-timing-function": "frames( <integer> )",
      "frequency-percentage": "<frequency> | <percentage>",
      "generic-family": "serif | sans-serif | cursive | fantasy | monospace | -apple-system",
      "generic-name": "serif | sans-serif | cursive | fantasy | monospace",
      "geometry-box": "<shape-box> | fill-box | stroke-box | view-box",
      "gradient": "<-legacy-gradient> | <linear-gradient()> | <repeating-linear-gradient()> | <radial-gradient()> | <repeating-radial-gradient()>",
      "grayscale()": "grayscale( <number-percentage> )",
      "grid-line": "auto | <custom-ident> | [ <integer> && <custom-ident>? ] | [ span && [ <integer> || <custom-ident> ] ]",
      "historical-lig-values": "[ historical-ligatures | no-historical-ligatures ]",
      "hsl()": "hsl( <hue> <percentage> <percentage> [ / <alpha-value> ]? ) | hsl( <hue> , <percentage> , <percentage> , <alpha-value>? )",
      "hsla()": "hsla( <hue> <percentage> <percentage> [ / <alpha-value> ]? ) | hsla( <hue> , <percentage> , <percentage> , <alpha-value>? )",
      "hue": "<number> | <angle>",
      "hue-rotate()": "hue-rotate( <angle> )",
      "image": "<url> | <image()> | <image-set()> | <element()> | <cross-fade()> | <gradient>",
      "image()": "image( [ [ <image> | <string> ]? , <color>? ]! )",
      "image-set()": "image-set( <image-set-option># )",
      "image-set-option": "[ <image> | <string> ] <resolution>",
      "inflexible-breadth": "<length> | <percentage> | min-content | max-content | auto",
      "inset()": "inset( <length-percentage>{1,4} [ round <'border-radius'> ]? )",
      "invert()": "invert( <number-percentage> )",
      "keyframes-name": "<custom-ident> | <string>",
      "keyframe-selector": "from | to | <percentage>",
      "leader()": "leader( <leader-type> )",
      "leader-type": "dotted | solid | space | <string>",
      "length-percentage": "<length> | <percentage>",
      "line-names": "'[' <custom-ident>* ']'",
      "line-name-list": "[ <line-names> | <name-repeat> ]+",
      "linear-gradient()": "linear-gradient( [ <angle> | to <side-or-corner> ]? , <color-stop-list> )",
      "mask-layer": "<mask-reference> || <position> [ / <bg-size> ]? || <repeat-style> || <geometry-box> || [ <geometry-box> | no-clip ] || <compositing-operator> || <masking-mode>",
      "mask-position": "[ <length-percentage> | left | center | right ] [ <length-percentage> | top | center | bottom ]?",
      "mask-reference": "none | <image> | <mask-source>",
      "mask-source": "<url>",
      "masking-mode": "alpha | luminance | match-source",
      "matrix()": "matrix( <number> [, <number> ]{5} )",
      "matrix3d()": "matrix3d( <number> [, <number> ]{15} )",
      "media-type": "<ident>",
      "mf-boolean": "<mf-name>",
      "mf-name": "<ident>",
      "minmax()": "minmax( [ <length> | <percentage> | <flex> | min-content | max-content | auto ] , [ <length> | <percentage> | <flex> | min-content | max-content | auto ] )",
      "named-color": "transparent | aliceblue | antiquewhite | aqua | aquamarine | azure | beige | bisque | black | blanchedalmond | blue | blueviolet | brown | burlywood | cadetblue | chartreuse | chocolate | coral | cornflowerblue | cornsilk | crimson | cyan | darkblue | darkcyan | darkgoldenrod | darkgray | darkgreen | darkgrey | darkkhaki | darkmagenta | darkolivegreen | darkorange | darkorchid | darkred | darksalmon | darkseagreen | darkslateblue | darkslategray | darkslategrey | darkturquoise | darkviolet | deeppink | deepskyblue | dimgray | dimgrey | dodgerblue | firebrick | floralwhite | forestgreen | fuchsia | gainsboro | ghostwhite | gold | goldenrod | gray | green | greenyellow | grey | honeydew | hotpink | indianred | indigo | ivory | khaki | lavender | lavenderblush | lawngreen | lemonchiffon | lightblue | lightcoral | lightcyan | lightgoldenrodyellow | lightgray | lightgreen | lightgrey | lightpink | lightsalmon | lightseagreen | lightskyblue | lightslategray | lightslategrey | lightsteelblue | lightyellow | lime | limegreen | linen | magenta | maroon | mediumaquamarine | mediumblue | mediumorchid | mediumpurple | mediumseagreen | mediumslateblue | mediumspringgreen | mediumturquoise | mediumvioletred | midnightblue | mintcream | mistyrose | moccasin | navajowhite | navy | oldlace | olive | olivedrab | orange | orangered | orchid | palegoldenrod | palegreen | paleturquoise | palevioletred | papayawhip | peachpuff | peru | pink | plum | powderblue | purple | rebeccapurple | red | rosybrown | royalblue | saddlebrown | salmon | sandybrown | seagreen | seashell | sienna | silver | skyblue | slateblue | slategray | slategrey | snow | springgreen | steelblue | tan | teal | thistle | tomato | turquoise | violet | wheat | white | whitesmoke | yellow | yellowgreen | <-non-standard-color>",
      "namespace-prefix": "<ident>",
      "number-percentage": "<number> | <percentage>",
      "numeric-figure-values": "[ lining-nums | oldstyle-nums ]",
      "numeric-fraction-values": "[ diagonal-fractions | stacked-fractions ]",
      "numeric-spacing-values": "[ proportional-nums | tabular-nums ]",
      "opacity()": "opacity( [ <number-percentage> ] )",
      "overflow-position": "unsafe | safe",
      "outline-radius": "<border-radius>",
      "perspective()": "perspective( <length> )",
      "polygon()": "polygon( <fill-rule>? , [ <length-percentage> <length-percentage> ]# )",
      "position": "[ [ left | center | right ] || [ top | center | bottom ] | [ left | center | right | <length-percentage> ] [ top | center | bottom | <length-percentage> ]? | [ [ left | right ] <length-percentage> ] && [ [ top | bottom ] <length-percentage> ] ]",
      "quote": "open-quote | close-quote | no-open-quote | no-close-quote",
      "radial-gradient()": "radial-gradient( [ <ending-shape> || <size> ]? [ at <position> ]? , <color-stop-list> )",
      "relative-size": "larger | smaller",
      "repeat-style": "repeat-x | repeat-y | [ repeat | space | round | no-repeat ]{1,2}",
      "repeating-linear-gradient()": "repeating-linear-gradient( [ <angle> | to <side-or-corner> ]? , <color-stop-list> )",
      "repeating-radial-gradient()": "repeating-radial-gradient( [ <ending-shape> || <size> ]? [ at <position> ]? , <color-stop-list> )",
      "rgb()": "rgb( <percentage>{3} [ / <alpha-value> ]? ) | rgb( <number>{3} [ / <alpha-value> ]? ) | rgb( <percentage>#{3} , <alpha-value>? ) | rgb( <number>#{3} , <alpha-value>? )",
      "rgba()": "rgba( <percentage>{3} [ / <alpha-value> ]? ) | rgba( <number>{3} [ / <alpha-value> ]? ) | rgba( <percentage>#{3} , <alpha-value>? ) | rgba( <number>#{3} , <alpha-value>? )",
      "rotate()": "rotate( <angle> )",
      "rotate3d()": "rotate3d( <number> , <number> , <number> , <angle> )",
      "rotateX()": "rotateX( <angle> )",
      "rotateY()": "rotateY( <angle> )",
      "rotateZ()": "rotateZ( <angle> )",
      "saturate()": "saturate( <number-percentage> )",
      "scale()": "scale( <number> [, <number> ]? )",
      "scale3d()": "scale3d( <number> , <number> , <number> )",
      "scaleX()": "scaleX( <number> )",
      "scaleY()": "scaleY( <number> )",
      "scaleZ()": "scaleZ( <number> )",
      "self-position": "center | start | end | self-start | self-end | flex-start | flex-end",
      "shape-radius": "<length-percentage> | closest-side | farthest-side",
      "skew()": "skew( <angle> [, <angle> ]? )",
      "skewX()": "skewX( <angle> )",
      "skewY()": "skewY( <angle> )",
      "sepia()": "sepia( <number-percentage> )",
      "shadow": "inset? && <length>{2,4} && <color>?",
      "shadow-t": "[ <length>{2,3} && <color>? ]",
      "shape": "rect( [ [ <top> , <right> , <bottom> , <left> ] | [ <top> <right> <bottom> <left> ] ] )",
      "shape-box": "<box> | margin-box",
      "side-or-corner": "[ left | right ] || [ top | bottom ]",
      "single-animation": "<time> || <single-timing-function> || <time> || <single-animation-iteration-count> || <single-animation-direction> || <single-animation-fill-mode> || <single-animation-play-state> || [ none | <keyframes-name> ]",
      "single-animation-direction": "normal | reverse | alternate | alternate-reverse",
      "single-animation-fill-mode": "none | forwards | backwards | both",
      "single-animation-iteration-count": "infinite | <number>",
      "single-animation-play-state": "running | paused",
      "single-timing-function": "linear | <cubic-bezier-timing-function> | <step-timing-function> | <frames-timing-function>",
      "single-transition": "<single-transition-timing-function> || [ none | <single-transition-property> ] || <time> || <time>",
      "single-transition-timing-function": "<single-timing-function>",
      "single-transition-property": "all | <custom-ident>",
      "size": "closest-side | farthest-side | closest-corner | farthest-corner | <length> | <length-percentage>{2}",
      "step-timing-function": "step-start | step-end | steps( <integer> [, [ start | end ] ]? )",
      "symbol": "<string> | <image> | <custom-ident>",
      "target": "<target-counter()> | <target-counters()> | <target-text()>",
      "target-counter()": "target-counter( [ <string> | <url> ] , <custom-ident> , <counter-style>? )",
      "target-counters()": "target-counters( [ <string> | <url> ] , <custom-ident> , <string> , <counter-style>? )",
      "target-text()": "target-text( [ <string> | <url> ] , [ content | before | after | first-letter ]? )",
      "time-percentage": "<time> | <percentage>",
      "track-breadth": "<length-percentage> | <flex> | min-content | max-content | auto",
      "track-list": "[ <line-names>? [ <track-size> | <track-repeat> ] ]+ <line-names>?",
      "track-repeat": "repeat( [ <positive-integer> ] , [ <line-names>? <track-size> ]+ <line-names>? )",
      "track-size": "<track-breadth> | minmax( <inflexible-breadth> , <track-breadth> ) | fit-content( [ <length> | <percentage> ] )",
      "transform-function": "<matrix()> | <translate()> | <translateX()> | <translateY()> | <scale()> | <scaleX()> | <scaleY()> | <rotate()> | <skew()> | <skewX()> | <skewY()> | <matrix3d()> | <translate3d()> | <translateZ()> | <scale3d()> | <scaleZ()> | <rotate3d()> | <rotateX()> | <rotateY()> | <rotateZ()> | <perspective()>",
      "transform-list": "<transform-function>+",
      "translate()": "translate( <length-percentage> [, <length-percentage> ]? )",
      "translate3d()": "translate3d( <length-percentage> , <length-percentage> , <length> )",
      "translateX()": "translateX( <length-percentage> )",
      "translateY()": "translateY( <length-percentage> )",
      "translateZ()": "translateZ( <length> )",
      "type-or-unit": "string | integer | color | url | integer | number | length | angle | time | frequency | em | ex | px | rem | vw | vh | vmin | vmax | mm | q | cm | in | pt | pc | deg | grad | rad | ms | s | Hz | kHz | %",
      "viewport-length": "auto | <length-percentage>",
      "-legacy-gradient": "<-webkit-gradient()> | <-legacy-linear-gradient> | <-legacy-repeating-linear-gradient> | <-legacy-radial-gradient> | <-legacy-repeating-radial-gradient>",
      "-legacy-linear-gradient": "-moz-linear-gradient( <-legacy-linear-gradient-arguments> ) | -webkit-linear-gradient( <-legacy-linear-gradient-arguments> ) | -o-linear-gradient( <-legacy-linear-gradient-arguments> )",
      "-legacy-repeating-linear-gradient": "-moz-repeating-linear-gradient( <-legacy-linear-gradient-arguments> ) | -webkit-repeating-linear-gradient( <-legacy-linear-gradient-arguments> ) | -o-repeating-linear-gradient( <-legacy-linear-gradient-arguments> )",
      "-legacy-linear-gradient-arguments": "[ <angle> | <side-or-corner> ]? , <color-stop-list>",
      "-legacy-radial-gradient": "-moz-radial-gradient( <-legacy-radial-gradient-arguments> ) | -webkit-radial-gradient( <-legacy-radial-gradient-arguments> ) | -o-radial-gradient( <-legacy-radial-gradient-arguments> )",
      "-legacy-repeating-radial-gradient": "-moz-repeating-radial-gradient( <-legacy-radial-gradient-arguments> ) | -webkit-repeating-radial-gradient( <-legacy-radial-gradient-arguments> ) | -o-repeating-radial-gradient( <-legacy-radial-gradient-arguments> )",
      "-legacy-radial-gradient-arguments": "[ <position> , ]? [ [ [ <-legacy-radial-gradient-shape> || <-legacy-radial-gradient-size> ] | [ <length> | <percentage> ]{2} ] , ]? <color-stop-list>",
      "-legacy-radial-gradient-size": "closest-side | closest-corner | farthest-side | farthest-corner | contain | cover",
      "-legacy-radial-gradient-shape": "circle | ellipse",
      "-non-standard-font": "-apple-system-body | -apple-system-headline | -apple-system-subheadline | -apple-system-caption1 | -apple-system-caption2 | -apple-system-footnote | -apple-system-short-body | -apple-system-short-headline | -apple-system-short-subheadline | -apple-system-short-caption1 | -apple-system-short-footnote | -apple-system-tall-body",
      "-non-standard-color": "-moz-ButtonDefault | -moz-ButtonHoverFace | -moz-ButtonHoverText | -moz-CellHighlight | -moz-CellHighlightText | -moz-Combobox | -moz-ComboboxText | -moz-Dialog | -moz-DialogText | -moz-dragtargetzone | -moz-EvenTreeRow | -moz-Field | -moz-FieldText | -moz-html-CellHighlight | -moz-html-CellHighlightText | -moz-mac-accentdarkestshadow | -moz-mac-accentdarkshadow | -moz-mac-accentface | -moz-mac-accentlightesthighlight | -moz-mac-accentlightshadow | -moz-mac-accentregularhighlight | -moz-mac-accentregularshadow | -moz-mac-chrome-active | -moz-mac-chrome-inactive | -moz-mac-focusring | -moz-mac-menuselect | -moz-mac-menushadow | -moz-mac-menutextselect | -moz-MenuHover | -moz-MenuHoverText | -moz-MenuBarText | -moz-MenuBarHoverText | -moz-nativehyperlinktext | -moz-OddTreeRow | -moz-win-communicationstext | -moz-win-mediatext | -moz-activehyperlinktext | -moz-default-background-color | -moz-default-color | -moz-hyperlinktext | -moz-visitedhyperlinktext | -webkit-activelink | -webkit-focus-ring-color | -webkit-link | -webkit-text",
      "-non-standard-image-rendering": "optimize-contrast | -moz-crisp-edges | -o-crisp-edges | -webkit-optimize-contrast",
      "-non-standard-overflow": "-moz-scrollbars-none | -moz-scrollbars-horizontal | -moz-scrollbars-vertical | -moz-hidden-unscrollable",
      "-non-standard-width": "min-intrinsic | intrinsic | -moz-min-content | -moz-max-content | -webkit-min-content | -webkit-max-content",
      "-non-standard-word-break": "break-word",
      "-webkit-gradient()": "-webkit-gradient( <-webkit-gradient-type> , <-webkit-gradient-point> [, <-webkit-gradient-point> | , <-webkit-gradient-radius> , <-webkit-gradient-point> ] [, <-webkit-gradient-radius> ]? [, <-webkit-gradient-color-stop> ]* )",
      "-webkit-gradient-color-stop": "from( <color> ) | color-stop( [ <number-zero-one> | <percentage> ] , <color> ) | to( <color> )",
      "-webkit-gradient-point": "[ left | center | right | <length-percentage> ] [ top | center | bottom | <length-percentage> ]",
      "-webkit-gradient-radius": "<length> | <percentage>",
      "-webkit-gradient-type": "linear | radial",
      "-webkit-mask-box-repeat": "repeat | stretch | round",
      "-webkit-mask-clip-style": "border | border-box | padding | padding-box | content | content-box | text",
      "-ms-filter": "[ <progid> | FlipH | FlipV ]+",
      "age": "child | young | old",
      "border-radius": "<length-percentage>{1,2}",
      "bottom": "<length> | auto",
      "generic-voice": "[ <age>? <gender> <integer>? ]",
      "gender": "male | female | neutral",
      "left": "<length> | auto",
      "mask-image": "<mask-reference>#",
      "name-repeat": "repeat( [ <positive-integer> | auto-fill ] , <line-names>+ )",
      "paint": "none | currentColor | <color> | <url> [ none | currentColor | <color> ]?",
      "path()": "path( <string> )",
      "right": "<length> | auto",
      "svg-length": "<percentage> | <length> | <number>",
      "svg-writing-mode": "lr-tb | rl-tb | tb-rl | lr | rl | tb",
      "top": "<length> | auto",
      "x": "<number>",
      "y": "<number>"
    },
    "properties": {
      "-ms-accelerator": "false | true",
      "-ms-block-progression": "tb | rl | bt | lr",
      "-ms-content-zoom-chaining": "none | chained",
      "-ms-content-zooming": "none | zoom",
      "-ms-content-zoom-limit": "<'-ms-content-zoom-limit-min'> <'-ms-content-zoom-limit-max'>",
      "-ms-content-zoom-limit-max": "<percentage>",
      "-ms-content-zoom-limit-min": "<percentage>",
      "-ms-content-zoom-snap": "<'-ms-content-zoom-snap-type'> || <'-ms-content-zoom-snap-points'>",
      "-ms-content-zoom-snap-points": "snapInterval( <percentage> , <percentage> ) | snapList( <percentage># )",
      "-ms-content-zoom-snap-type": "none | proximity | mandatory",
      "-ms-filter": "<string>",
      "-ms-flow-from": "[ none | <custom-ident> ]#",
      "-ms-flow-into": "[ none | <custom-ident> ]#",
      "-ms-high-contrast-adjust": "auto | none",
      "-ms-hyphenate-limit-chars": "auto | <integer>{1,3}",
      "-ms-hyphenate-limit-lines": "no-limit | <integer>",
      "-ms-hyphenate-limit-zone": "<percentage> | <length>",
      "-ms-ime-align": "auto | after",
      "-ms-overflow-style": "auto | none | scrollbar | -ms-autohiding-scrollbar",
      "-ms-scrollbar-3dlight-color": "<color>",
      "-ms-scrollbar-arrow-color": "<color>",
      "-ms-scrollbar-base-color": "<color>",
      "-ms-scrollbar-darkshadow-color": "<color>",
      "-ms-scrollbar-face-color": "<color>",
      "-ms-scrollbar-highlight-color": "<color>",
      "-ms-scrollbar-shadow-color": "<color>",
      "-ms-scrollbar-track-color": "<color>",
      "-ms-scroll-chaining": "chained | none",
      "-ms-scroll-limit": "<'-ms-scroll-limit-x-min'> <'-ms-scroll-limit-y-min'> <'-ms-scroll-limit-x-max'> <'-ms-scroll-limit-y-max'>",
      "-ms-scroll-limit-x-max": "auto | <length>",
      "-ms-scroll-limit-x-min": "<length>",
      "-ms-scroll-limit-y-max": "auto | <length>",
      "-ms-scroll-limit-y-min": "<length>",
      "-ms-scroll-rails": "none | railed",
      "-ms-scroll-snap-points-x": "snapInterval( <length-percentage> , <length-percentage> ) | snapList( <length-percentage># )",
      "-ms-scroll-snap-points-y": "snapInterval( <length-percentage> , <length-percentage> ) | snapList( <length-percentage># )",
      "-ms-scroll-snap-type": "none | proximity | mandatory",
      "-ms-scroll-snap-x": "<'-ms-scroll-snap-type'> <'-ms-scroll-snap-points-x'>",
      "-ms-scroll-snap-y": "<'-ms-scroll-snap-type'> <'-ms-scroll-snap-points-y'>",
      "-ms-scroll-translation": "none | vertical-to-horizontal",
      "-ms-text-autospace": "none | ideograph-alpha | ideograph-numeric | ideograph-parenthesis | ideograph-space",
      "-ms-touch-select": "grippers | none",
      "-ms-user-select": "none | element | text",
      "-ms-wrap-flow": "auto | both | start | end | maximum | clear",
      "-ms-wrap-margin": "<length>",
      "-ms-wrap-through": "wrap | none",
      "-moz-appearance": "none | button | button-arrow-down | button-arrow-next | button-arrow-previous | button-arrow-up | button-bevel | button-focus | caret | checkbox | checkbox-container | checkbox-label | checkmenuitem | dualbutton | groupbox | listbox | listitem | menuarrow | menubar | menucheckbox | menuimage | menuitem | menuitemtext | menulist | menulist-button | menulist-text | menulist-textfield | menupopup | menuradio | menuseparator | meterbar | meterchunk | progressbar | progressbar-vertical | progresschunk | progresschunk-vertical | radio | radio-container | radio-label | radiomenuitem | range | range-thumb | resizer | resizerpanel | scale-horizontal | scalethumbend | scalethumb-horizontal | scalethumbstart | scalethumbtick | scalethumb-vertical | scale-vertical | scrollbarbutton-down | scrollbarbutton-left | scrollbarbutton-right | scrollbarbutton-up | scrollbarthumb-horizontal | scrollbarthumb-vertical | scrollbartrack-horizontal | scrollbartrack-vertical | searchfield | separator | sheet | spinner | spinner-downbutton | spinner-textfield | spinner-upbutton | splitter | statusbar | statusbarpanel | tab | tabpanel | tabpanels | tab-scroll-arrow-back | tab-scroll-arrow-forward | textfield | textfield-multiline | toolbar | toolbarbutton | toolbarbutton-dropdown | toolbargripper | toolbox | tooltip | treeheader | treeheadercell | treeheadersortarrow | treeitem | treeline | treetwisty | treetwistyopen | treeview | -moz-mac-unified-toolbar | -moz-win-borderless-glass | -moz-win-browsertabbar-toolbox | -moz-win-communicationstext | -moz-win-communications-toolbox | -moz-win-exclude-glass | -moz-win-glass | -moz-win-mediatext | -moz-win-media-toolbox | -moz-window-button-box | -moz-window-button-box-maximized | -moz-window-button-close | -moz-window-button-maximize | -moz-window-button-minimize | -moz-window-button-restore | -moz-window-frame-bottom | -moz-window-frame-left | -moz-window-frame-right | -moz-window-titlebar | -moz-window-titlebar-maximized",
      "-moz-binding": "<url> | none",
      "-moz-border-bottom-colors": "<color>+ | none",
      "-moz-border-left-colors": "<color>+ | none",
      "-moz-border-right-colors": "<color>+ | none",
      "-moz-border-top-colors": "<color>+ | none",
      "-moz-context-properties": "none | [ fill | fill-opacity | stroke | stroke-opacity ]#",
      "-moz-float-edge": "border-box | content-box | margin-box | padding-box",
      "-moz-force-broken-image-icon": "<integer>",
      "-moz-image-region": "<shape> | auto",
      "-moz-orient": "inline | block | horizontal | vertical",
      "-moz-outline-radius": "<outline-radius>{1,4} [ / <outline-radius>{1,4} ]?",
      "-moz-outline-radius-bottomleft": "<outline-radius>",
      "-moz-outline-radius-bottomright": "<outline-radius>",
      "-moz-outline-radius-topleft": "<outline-radius>",
      "-moz-outline-radius-topright": "<outline-radius>",
      "-moz-stack-sizing": "ignore | stretch-to-fit",
      "-moz-text-blink": "none | blink",
      "-moz-user-focus": "ignore | normal | select-after | select-before | select-menu | select-same | select-all | none",
      "-moz-user-input": "auto | none | enabled | disabled",
      "-moz-user-modify": "read-only | read-write | write-only",
      "-moz-window-dragging": "drag | no-drag",
      "-moz-window-shadow": "default | menu | tooltip | sheet | none",
      "-webkit-appearance": "none | button | button-bevel | caps-lock-indicator | caret | checkbox | default-button | listbox | listitem | media-fullscreen-button | media-mute-button | media-play-button | media-seek-back-button | media-seek-forward-button | media-slider | media-sliderthumb | menulist | menulist-button | menulist-text | menulist-textfield | push-button | radio | scrollbarbutton-down | scrollbarbutton-left | scrollbarbutton-right | scrollbarbutton-up | scrollbargripper-horizontal | scrollbargripper-vertical | scrollbarthumb-horizontal | scrollbarthumb-vertical | scrollbartrack-horizontal | scrollbartrack-vertical | searchfield | searchfield-cancel-button | searchfield-decoration | searchfield-results-button | searchfield-results-decoration | slider-horizontal | slider-vertical | sliderthumb-horizontal | sliderthumb-vertical | square-button | textarea | textfield",
      "-webkit-border-before": "<'border-width'> || <'border-style'> || <'color'>",
      "-webkit-border-before-color": "<'color'>",
      "-webkit-border-before-style": "<'border-style'>",
      "-webkit-border-before-width": "<'border-width'>",
      "-webkit-box-reflect": "[ above | below | right | left ]? <length>? <image>?",
      "-webkit-mask": "[ <mask-reference> || <position> [ / <bg-size> ]? || <repeat-style> || [ <box> | border | padding | content | text ] || [ <box> | border | padding | content ] ]#",
      "-webkit-mask-attachment": "<attachment>#",
      "-webkit-mask-clip": "<-webkit-mask-clip-style> [, <-webkit-mask-clip-style> ]*",
      "-webkit-mask-composite": "<composite-style>#",
      "-webkit-mask-image": "<mask-reference>#",
      "-webkit-mask-origin": "[ <box> | border | padding | content ]#",
      "-webkit-mask-position": "<position>#",
      "-webkit-mask-position-x": "[ <length-percentage> | left | center | right ]#",
      "-webkit-mask-position-y": "[ <length-percentage> | top | center | bottom ]#",
      "-webkit-mask-repeat": "<repeat-style>#",
      "-webkit-mask-repeat-x": "repeat | no-repeat | space | round",
      "-webkit-mask-repeat-y": "repeat | no-repeat | space | round",
      "-webkit-mask-size": "<bg-size>#",
      "-webkit-overflow-scrolling": "auto | touch",
      "-webkit-tap-highlight-color": "<color>",
      "-webkit-text-fill-color": "<color>",
      "-webkit-text-stroke": "<length> || <color>",
      "-webkit-text-stroke-color": "<color>",
      "-webkit-text-stroke-width": "<length>",
      "-webkit-touch-callout": "default | none",
      "-webkit-user-modify": "read-only | read-write | read-write-plaintext-only",
      "align-content": "normal | <baseline-position> | <content-distribution> | <overflow-position>? <content-position>",
      "align-items": "normal | stretch | <baseline-position> | [ <overflow-position>? <self-position> ]",
      "align-self": "auto | normal | stretch | <baseline-position> | <overflow-position>? <self-position>",
      "all": "initial | inherit | unset | revert",
      "animation": "<single-animation>#",
      "animation-delay": "<time>#",
      "animation-direction": "<single-animation-direction>#",
      "animation-duration": "<time>#",
      "animation-fill-mode": "<single-animation-fill-mode>#",
      "animation-iteration-count": "<single-animation-iteration-count>#",
      "animation-name": "[ none | <keyframes-name> ]#",
      "animation-play-state": "<single-animation-play-state>#",
      "animation-timing-function": "<single-timing-function>#",
      "appearance": "auto | none",
      "azimuth": "<angle> | [ [ left-side | far-left | left | center-left | center | center-right | right | far-right | right-side ] || behind ] | leftwards | rightwards",
      "backdrop-filter": "none | <filter-function-list>",
      "backface-visibility": "visible | hidden",
      "background": "[ <bg-layer> , ]* <final-bg-layer>",
      "background-attachment": "<attachment>#",
      "background-blend-mode": "<blend-mode>#",
      "background-clip": "<box>#",
      "background-color": "<color>",
      "background-image": "<bg-image>#",
      "background-origin": "<box>#",
      "background-position": "<bg-position>#",
      "background-position-x": "[ center | [ left | right | x-start | x-end ]? <length-percentage>? ]#",
      "background-position-y": "[ center | [ top | bottom | y-start | y-end ]? <length-percentage>? ]#",
      "background-repeat": "<repeat-style>#",
      "background-size": "<bg-size>#",
      "block-overflow": "clip | ellipsis | <string>",
      "block-size": "<'width'>",
      "border": "<br-width> || <br-style> || <color>",
      "border-block-end": "<'border-width'> || <'border-style'> || <'color'>",
      "border-block-end-color": "<'color'>",
      "border-block-end-style": "<'border-style'>",
      "border-block-end-width": "<'border-width'>",
      "border-block-start": "<'border-width'> || <'border-style'> || <'color'>",
      "border-block-start-color": "<'color'>",
      "border-block-start-style": "<'border-style'>",
      "border-block-start-width": "<'border-width'>",
      "border-bottom": "<br-width> || <br-style> || <color>",
      "border-bottom-color": "<color>",
      "border-bottom-left-radius": "<length-percentage>{1,2}",
      "border-bottom-right-radius": "<length-percentage>{1,2}",
      "border-bottom-style": "<br-style>",
      "border-bottom-width": "<br-width>",
      "border-collapse": "collapse | separate",
      "border-color": "<color>{1,4}",
      "border-image": "<'border-image-source'> || <'border-image-slice'> [ / <'border-image-width'> | / <'border-image-width'>? / <'border-image-outset'> ]? || <'border-image-repeat'>",
      "border-image-outset": "[ <length> | <number> ]{1,4}",
      "border-image-repeat": "[ stretch | repeat | round | space ]{1,2}",
      "border-image-slice": "<number-percentage>{1,4} && fill?",
      "border-image-source": "none | <image>",
      "border-image-width": "[ <length-percentage> | <number> | auto ]{1,4}",
      "border-inline-end": "<'border-width'> || <'border-style'> || <'color'>",
      "border-inline-end-color": "<'color'>",
      "border-inline-end-style": "<'border-style'>",
      "border-inline-end-width": "<'border-width'>",
      "border-inline-start": "<'border-width'> || <'border-style'> || <'color'>",
      "border-inline-start-color": "<'color'>",
      "border-inline-start-style": "<'border-style'>",
      "border-inline-start-width": "<'border-width'>",
      "border-left": "<br-width> || <br-style> || <color>",
      "border-left-color": "<color>",
      "border-left-style": "<br-style>",
      "border-left-width": "<br-width>",
      "border-radius": "<length-percentage>{1,4} [ / <length-percentage>{1,4} ]?",
      "border-right": "<br-width> || <br-style> || <color>",
      "border-right-color": "<color>",
      "border-right-style": "<br-style>",
      "border-right-width": "<br-width>",
      "border-spacing": "<length> <length>?",
      "border-style": "<br-style>{1,4}",
      "border-top": "<br-width> || <br-style> || <color>",
      "border-top-color": "<color>",
      "border-top-left-radius": "<length-percentage>{1,2}",
      "border-top-right-radius": "<length-percentage>{1,2}",
      "border-top-style": "<br-style>",
      "border-top-width": "<br-width>",
      "border-width": "<br-width>{1,4}",
      "bottom": "<length> | <percentage> | auto",
      "box-align": "start | center | end | baseline | stretch",
      "box-decoration-break": "slice | clone",
      "box-direction": "normal | reverse | inherit",
      "box-flex": "<number>",
      "box-flex-group": "<integer>",
      "box-lines": "single | multiple",
      "box-ordinal-group": "<integer>",
      "box-orient": "horizontal | vertical | inline-axis | block-axis | inherit",
      "box-pack": "start | center | end | justify",
      "box-shadow": "none | <shadow>#",
      "box-sizing": "content-box | border-box",
      "break-after": "auto | avoid | avoid-page | page | left | right | recto | verso | avoid-column | column | avoid-region | region",
      "break-before": "auto | avoid | avoid-page | page | left | right | recto | verso | avoid-column | column | avoid-region | region",
      "break-inside": "auto | avoid | avoid-page | avoid-column | avoid-region",
      "caption-side": "top | bottom | block-start | block-end | inline-start | inline-end",
      "caret-color": "auto | <color>",
      "clear": "none | left | right | both | inline-start | inline-end",
      "clip": "<shape> | auto",
      "clip-path": "<clip-source> | [ <basic-shape> || <geometry-box> ] | none",
      "color": "<color>",
      "color-adjust": "economy | exact",
      "column-count": "<integer> | auto",
      "column-fill": "auto | balance | balance-all",
      "column-gap": "normal | <length-percentage>",
      "column-rule": "<'column-rule-width'> || <'column-rule-style'> || <'column-rule-color'>",
      "column-rule-color": "<color>",
      "column-rule-style": "<'border-style'>",
      "column-rule-width": "<'border-width'>",
      "column-span": "none | all",
      "column-width": "<length> | auto",
      "columns": "<'column-width'> || <'column-count'>",
      "contain": "none | strict | content | [ size || layout || style || paint ]",
      "content": "normal | none | [ <content-replacement> | <content-list> ] [ / <string> ]?",
      "counter-increment": "[ <custom-ident> <integer>? ]+ | none",
      "counter-reset": "[ <custom-ident> <integer>? ]+ | none",
      "cursor": "[ [ <url> [ <x> <y> ]? , ]* [ auto | default | none | context-menu | help | pointer | progress | wait | cell | crosshair | text | vertical-text | alias | copy | move | no-drop | not-allowed | e-resize | n-resize | ne-resize | nw-resize | s-resize | se-resize | sw-resize | w-resize | ew-resize | ns-resize | nesw-resize | nwse-resize | col-resize | row-resize | all-scroll | zoom-in | zoom-out | grab | grabbing | hand | -webkit-grab | -webkit-grabbing | -webkit-zoom-in | -webkit-zoom-out | -moz-grab | -moz-grabbing | -moz-zoom-in | -moz-zoom-out ] ]",
      "direction": "ltr | rtl",
      "display": "none | inline | block | list-item | inline-list-item | inline-block | inline-table | table | table-cell | table-column | table-column-group | table-footer-group | table-header-group | table-row | table-row-group | flex | inline-flex | grid | inline-grid | run-in | ruby | ruby-base | ruby-text | ruby-base-container | ruby-text-container | contents | -ms-flexbox | -ms-inline-flexbox | -ms-grid | -ms-inline-grid | -webkit-flex | -webkit-inline-flex | -webkit-box | -webkit-inline-box | -moz-inline-stack | -moz-box | -moz-inline-box",
      "empty-cells": "show | hide",
      "filter": "none | <filter-function-list> | <-ms-filter>",
      "flex": "none | [ <'flex-grow'> <'flex-shrink'>? || <'flex-basis'> ]",
      "flex-basis": "content | <'width'>",
      "flex-direction": "row | row-reverse | column | column-reverse",
      "flex-flow": "<'flex-direction'> || <'flex-wrap'>",
      "flex-grow": "<number>",
      "flex-shrink": "<number>",
      "flex-wrap": "nowrap | wrap | wrap-reverse",
      "float": "left | right | none | inline-start | inline-end",
      "font": "[ [ <'font-style'> || <font-variant-css21> || <'font-weight'> || <'font-stretch'> ]? <'font-size'> [ / <'line-height'> ]? <'font-family'> ] | caption | icon | menu | message-box | small-caption | status-bar | <-non-standard-font>",
      "font-family": "[ <family-name> | <generic-family> ]#",
      "font-feature-settings": "normal | <feature-tag-value>#",
      "font-kerning": "auto | normal | none",
      "font-language-override": "normal | <string>",
      "font-optical-sizing": "auto | none",
      "font-variation-settings": "normal | [ <string> <number> ]#",
      "font-size": "<absolute-size> | <relative-size> | <length-percentage>",
      "font-size-adjust": "none | <number>",
      "font-stretch": "normal | ultra-condensed | extra-condensed | condensed | semi-condensed | semi-expanded | expanded | extra-expanded | ultra-expanded",
      "font-style": "normal | italic | oblique",
      "font-synthesis": "none | [ weight || style ]",
      "font-variant": "normal | none | [ <common-lig-values> || <discretionary-lig-values> || <historical-lig-values> || <contextual-alt-values> || stylistic( <feature-value-name> ) || historical-forms || styleset( <feature-value-name># ) || character-variant( <feature-value-name># ) || swash( <feature-value-name> ) || ornaments( <feature-value-name> ) || annotation( <feature-value-name> ) || [ small-caps | all-small-caps | petite-caps | all-petite-caps | unicase | titling-caps ] || <numeric-figure-values> || <numeric-spacing-values> || <numeric-fraction-values> || ordinal || slashed-zero || <east-asian-variant-values> || <east-asian-width-values> || ruby ]",
      "font-variant-alternates": "normal | [ stylistic( <feature-value-name> ) || historical-forms || styleset( <feature-value-name># ) || character-variant( <feature-value-name># ) || swash( <feature-value-name> ) || ornaments( <feature-value-name> ) || annotation( <feature-value-name> ) ]",
      "font-variant-caps": "normal | small-caps | all-small-caps | petite-caps | all-petite-caps | unicase | titling-caps",
      "font-variant-east-asian": "normal | [ <east-asian-variant-values> || <east-asian-width-values> || ruby ]",
      "font-variant-ligatures": "normal | none | [ <common-lig-values> || <discretionary-lig-values> || <historical-lig-values> || <contextual-alt-values> ]",
      "font-variant-numeric": "normal | [ <numeric-figure-values> || <numeric-spacing-values> || <numeric-fraction-values> || ordinal || slashed-zero ]",
      "font-variant-position": "normal | sub | super",
      "font-weight": "normal | bold | bolder | lighter | 100 | 200 | 300 | 400 | 500 | 600 | 700 | 800 | 900",
      "gap": "<'row-gap'> <'column-gap'>?",
      "grid": "<'grid-template'> | <'grid-template-rows'> / [ auto-flow && dense? ] <'grid-auto-columns'>? | [ auto-flow && dense? ] <'grid-auto-rows'>? / <'grid-template-columns'>",
      "grid-area": "<grid-line> [ / <grid-line> ]{0,3}",
      "grid-auto-columns": "<track-size>+",
      "grid-auto-flow": "[ row | column ] || dense",
      "grid-auto-rows": "<track-size>+",
      "grid-column": "<grid-line> [ / <grid-line> ]?",
      "grid-column-end": "<grid-line>",
      "grid-column-gap": "<length-percentage>",
      "grid-column-start": "<grid-line>",
      "grid-gap": "<'grid-row-gap'> <'grid-column-gap'>?",
      "grid-row": "<grid-line> [ / <grid-line> ]?",
      "grid-row-end": "<grid-line>",
      "grid-row-gap": "<length-percentage>",
      "grid-row-start": "<grid-line>",
      "grid-template": "none | [ <'grid-template-rows'> / <'grid-template-columns'> ] | [ <line-names>? <string> <track-size>? <line-names>? ]+ [ / <explicit-track-list> ]?",
      "grid-template-areas": "none | <string>+",
      "grid-template-columns": "none | <track-list> | <auto-track-list>",
      "grid-template-rows": "none | <track-list> | <auto-track-list>",
      "hanging-punctuation": "none | [ first || [ force-end | allow-end ] || last ]",
      "height": "[ <length> | <percentage> ] && [ border-box | content-box ]? | available | min-content | max-content | fit-content | auto",
      "hyphens": "none | manual | auto",
      "image-orientation": "from-image | <angle> | [ <angle>? flip ]",
      "image-rendering": "auto | crisp-edges | pixelated | optimizeSpeed | optimizeQuality | <-non-standard-image-rendering>",
      "image-resolution": "[ from-image || <resolution> ] && snap?",
      "ime-mode": "auto | normal | active | inactive | disabled",
      "initial-letter": "normal | [ <number> <integer>? ]",
      "initial-letter-align": "[ auto | alphabetic | hanging | ideographic ]",
      "inline-size": "<'width'>",
      "isolation": "auto | isolate",
      "justify-content": "normal | <content-distribution> | <overflow-position>? [ <content-position> | left | right ]",
      "justify-items": "normal | stretch | <baseline-position> | <overflow-position>? [ <self-position> | left | right ] | legacy | legacy && [ left | right | center ]",
      "justify-self": "auto | normal | stretch | <baseline-position> | <overflow-position>? [ <self-position> | left | right ]",
      "left": "<length> | <percentage> | auto",
      "letter-spacing": "normal | <length-percentage>",
      "line-break": "auto | loose | normal | strict",
      "line-clamp": "none | <integer>",
      "line-height": "normal | <number> | <length> | <percentage>",
      "line-height-step": "none | <length>",
      "list-style": "<'list-style-type'> || <'list-style-position'> || <'list-style-image'>",
      "list-style-image": "<url> | none",
      "list-style-position": "inside | outside",
      "list-style-type": "<counter-style> | <string> | none",
      "margin": "[ <length> | <percentage> | auto ]{1,4}",
      "margin-block-end": "<'margin-left'>",
      "margin-block-start": "<'margin-left'>",
      "margin-bottom": "<length> | <percentage> | auto",
      "margin-inline-end": "<'margin-left'>",
      "margin-inline-start": "<'margin-left'>",
      "margin-left": "<length> | <percentage> | auto",
      "margin-right": "<length> | <percentage> | auto",
      "margin-top": "<length> | <percentage> | auto",
      "mask": "<mask-layer>#",
      "mask-border": "<'mask-border-source'> || <'mask-border-slice'> [ / <'mask-border-width'>? [ / <'mask-border-outset'> ]? ]? || <'mask-border-repeat'> || <'mask-border-mode'>",
      "mask-border-mode": "luminance | alpha",
      "mask-border-outset": "[ <length> | <number> ]{1,4}",
      "mask-border-repeat": "[ stretch | repeat | round | space ]{1,2}",
      "mask-border-slice": "<number-percentage>{1,4} fill?",
      "mask-border-source": "none | <image>",
      "mask-border-width": "[ <length-percentage> | <number> | auto ]{1,4}",
      "mask-clip": "[ <geometry-box> | no-clip ]#",
      "mask-composite": "<compositing-operator>#",
      "mask-image": "<mask-reference>#",
      "mask-mode": "<masking-mode>#",
      "mask-origin": "<geometry-box>#",
      "mask-position": "<position>#",
      "mask-repeat": "<repeat-style>#",
      "mask-size": "<bg-size>#",
      "mask-type": "luminance | alpha",
      "max-block-size": "<'max-width'>",
      "max-height": "<length> | <percentage> | none | max-content | min-content | fit-content | fill-available",
      "max-inline-size": "<'max-width'>",
      "max-lines": "none | <integer>",
      "max-width": "<length> | <percentage> | none | max-content | min-content | fit-content | fill-available | <-non-standard-width>",
      "min-block-size": "<'min-width'>",
      "min-height": "<length> | <percentage> | auto | max-content | min-content | fit-content | fill-available",
      "min-inline-size": "<'min-width'>",
      "min-width": "<length> | <percentage> | auto | max-content | min-content | fit-content | fill-available | <-non-standard-width>",
      "mix-blend-mode": "<blend-mode>",
      "object-fit": "fill | contain | cover | none | scale-down",
      "object-position": "<position>",
      "offset": "[ <'offset-position'>? [ <'offset-path'> [ <'offset-distance'> || <'offset-rotate'> ]? ]? ]! [ / <'offset-anchor'> ]?",
      "offset-anchor": "auto | <position>",
      "offset-block-end": "<'left'>",
      "offset-block-start": "<'left'>",
      "offset-inline-end": "<'left'>",
      "offset-inline-start": "<'left'>",
      "offset-distance": "<length-percentage>",
      "offset-path": "none | ray( [ <angle> && <size>? && contain? ] ) | <path()> | <url> | [ <basic-shape> || <geometry-box> ]",
      "offset-position": "auto | <position>",
      "offset-rotate": "[ auto | reverse ] || <angle>",
      "opacity": "<number-zero-one>",
      "order": "<integer>",
      "orphans": "<integer>",
      "outline": "[ <'outline-color'> || <'outline-style'> || <'outline-width'> ]",
      "outline-color": "<color> | invert",
      "outline-offset": "<length>",
      "outline-style": "auto | <br-style>",
      "outline-width": "<br-width>",
      "overflow": "visible | hidden | scroll | auto | <-non-standard-overflow>",
      "overflow-anchor": "auto | none",
      "overflow-block": "<'overflow'>",
      "overflow-clip-box": "padding-box | content-box",
      "overflow-inline": "<'overflow'>",
      "overflow-wrap": "normal | break-word",
      "overflow-x": "visible | hidden | clip | scroll | auto",
      "overflow-y": "visible | hidden | clip | scroll | auto",
      "overscroll-behavior": "[ contain | none | auto ]{1,2}",
      "overscroll-behavior-x": "contain | none | auto",
      "overscroll-behavior-y": "contain | none | auto",
      "padding": "[ <length> | <percentage> ]{1,4}",
      "padding-block-end": "<'padding-left'>",
      "padding-block-start": "<'padding-left'>",
      "padding-bottom": "<length> | <percentage>",
      "padding-inline-end": "<'padding-left'>",
      "padding-inline-start": "<'padding-left'>",
      "padding-left": "<length> | <percentage>",
      "padding-right": "<length> | <percentage>",
      "padding-top": "<length> | <percentage>",
      "page-break-after": "auto | always | avoid | left | right | recto | verso",
      "page-break-before": "auto | always | avoid | left | right | recto | verso",
      "page-break-inside": "auto | avoid",
      "paint-order": "normal | [ fill || stroke || markers ]",
      "perspective": "none | <length>",
      "perspective-origin": "<position>",
      "place-content": "<'align-content'> <'justify-content'>?",
      "pointer-events": "auto | none | visiblePainted | visibleFill | visibleStroke | visible | painted | fill | stroke | all | inherit",
      "position": "static | relative | absolute | sticky | fixed | -webkit-sticky",
      "quotes": "none | [ <string> <string> ]+",
      "resize": "none | both | horizontal | vertical",
      "right": "<length> | <percentage> | auto",
      "rotate": "none | [ x | y | z | <number>{3} ]? && <angle>",
      "row-gap": "normal | <length-percentage>",
      "ruby-align": "start | center | space-between | space-around",
      "ruby-merge": "separate | collapse | auto",
      "ruby-position": "over | under | inter-character",
      "scale": "none | <number>{1,3}",
      "scroll-behavior": "auto | smooth",
      "scroll-snap-coordinate": "none | <position>#",
      "scroll-snap-destination": "<position>",
      "scroll-snap-points-x": "none | repeat( <length-percentage> )",
      "scroll-snap-points-y": "none | repeat( <length-percentage> )",
      "scroll-snap-type": "none | mandatory | proximity",
      "scroll-snap-type-x": "none | mandatory | proximity",
      "scroll-snap-type-y": "none | mandatory | proximity",
      "shape-image-threshold": "<number>",
      "shape-margin": "<length-percentage>",
      "shape-outside": "none | <shape-box> || <basic-shape> | <image>",
      "tab-size": "<integer> | <length>",
      "table-layout": "auto | fixed",
      "text-align": "start | end | left | right | center | justify | match-parent",
      "text-align-last": "auto | start | end | left | right | center | justify",
      "text-combine-upright": "none | all | [ digits <integer>? ]",
      "text-decoration": "<'text-decoration-line'> || <'text-decoration-style'> || <'text-decoration-color'>",
      "text-decoration-color": "<color>",
      "text-decoration-line": "none | [ underline || overline || line-through || blink ]",
      "text-decoration-skip": "none | [ objects || [ spaces | [ leading-spaces || trailing-spaces ] ] || edges || box-decoration ]",
      "text-decoration-skip-ink": "auto | none",
      "text-decoration-style": "solid | double | dotted | dashed | wavy",
      "text-emphasis": "<'text-emphasis-style'> || <'text-emphasis-color'>",
      "text-emphasis-color": "<color>",
      "text-emphasis-position": "[ over | under ] && [ right | left ]",
      "text-emphasis-style": "none | [ [ filled | open ] || [ dot | circle | double-circle | triangle | sesame ] ] | <string>",
      "text-indent": "<length-percentage> && hanging? && each-line?",
      "text-justify": "auto | inter-character | inter-word | none",
      "text-orientation": "mixed | upright | sideways",
      "text-overflow": "[ clip | ellipsis | <string> ]{1,2}",
      "text-rendering": "auto | optimizeSpeed | optimizeLegibility | geometricPrecision",
      "text-shadow": "none | <shadow-t>#",
      "text-size-adjust": "none | auto | <percentage>",
      "text-transform": "none | capitalize | uppercase | lowercase | full-width",
      "text-underline-position": "auto | [ under || [ left | right ] ]",
      "top": "<length> | <percentage> | auto",
      "touch-action": "auto | none | [ [ pan-x | pan-left | pan-right ] || [ pan-y | pan-up | pan-down ] || pinch-zoom ] | manipulation",
      "transform": "none | <transform-list>",
      "transform-box": "border-box | fill-box | view-box",
      "transform-origin": "[ [ <length-percentage> | left | center | right ] && [ <length-percentage> | top | center | bottom ] ] <length>? | [ <length-percentage> | left | center | right | top | bottom ]",
      "transform-style": "flat | preserve-3d",
      "transition": "<single-transition>#",
      "transition-delay": "<time>#",
      "transition-duration": "<time>#",
      "transition-property": "none | <single-transition-property>#",
      "transition-timing-function": "<single-transition-timing-function>#",
      "translate": "none | <length-percentage> [ <length-percentage> <length>? ]?",
      "unicode-bidi": "normal | embed | isolate | bidi-override | isolate-override | plaintext | -moz-isolate | -moz-isolate-override | -moz-plaintext | -webkit-isolate",
      "user-select": "auto | text | none | contain | all",
      "vertical-align": "baseline | sub | super | text-top | text-bottom | middle | top | bottom | <percentage> | <length>",
      "visibility": "visible | hidden | collapse",
      "white-space": "normal | pre | nowrap | pre-wrap | pre-line",
      "widows": "<integer>",
      "width": "[ <length> | <percentage> ] && [ border-box | content-box ]? | available | min-content | max-content | fit-content | auto",
      "will-change": "auto | <animateable-feature>#",
      "word-break": "normal | break-all | keep-all | <-non-standard-word-break>",
      "word-spacing": "normal | <length-percentage>",
      "word-wrap": "normal | break-word",
      "writing-mode": "horizontal-tb | vertical-rl | vertical-lr | sideways-rl | sideways-lr | <svg-writing-mode>",
      "z-index": "auto | <integer>",
      "zoom": "normal | reset | <number> | <percentage>",
      "-moz-background-clip": "padding | border",
      "-moz-border-radius-bottomleft": "<'border-bottom-left-radius'>",
      "-moz-border-radius-bottomright": "<'border-bottom-right-radius'>",
      "-moz-border-radius-topleft": "<'border-top-left-radius'>",
      "-moz-border-radius-topright": "<'border-bottom-right-radius'>",
      "-moz-osx-font-smoothing": "auto | grayscale",
      "-moz-user-select": "none | text | all | -moz-none",
      "-ms-flex-align": "start | end | center | baseline | stretch",
      "-ms-flex-item-align": "auto | start | end | center | baseline | stretch",
      "-ms-flex-line-pack": "start | end | center | justify | distribute | stretch",
      "-ms-flex-negative": "<'flex-shrink'>",
      "-ms-flex-pack": "start | end | center | justify | distribute",
      "-ms-flex-order": "<integer>",
      "-ms-flex-positive": "<'flex-grow'>",
      "-ms-flex-preferred-size": "<'flex-basis'>",
      "-ms-interpolation-mode": "nearest-neighbor | bicubic",
      "-ms-grid-column-align": "start | end | center | stretch",
      "-ms-grid-row-align": "start | end | center | stretch",
      "-webkit-background-clip": "[ <box> | border | padding | content | text ]#",
      "-webkit-column-break-after": "always | auto | avoid",
      "-webkit-column-break-before": "always | auto | avoid",
      "-webkit-column-break-inside": "always | auto | avoid",
      "-webkit-font-smoothing": "auto | none | antialiased | subpixel-antialiased",
      "-webkit-line-clamp": "<positive-integer>",
      "-webkit-mask-box-image": "[ <url> | <gradient> | none ] [ <length-percentage>{4} <-webkit-mask-box-repeat>{2} ]?",
      "-webkit-print-color-adjust": "economy | exact",
      "-webkit-text-security": "none | circle | disc | square",
      "-webkit-user-drag": "none | element | auto",
      "-webkit-user-select": "auto | none | text | all",
      "alignment-baseline": "auto | baseline | before-edge | text-before-edge | middle | central | after-edge | text-after-edge | ideographic | alphabetic | hanging | mathematical",
      "baseline-shift": "baseline | sub | super | <svg-length>",
      "behavior": "<url>+",
      "clip-rule": "nonzero | evenodd",
      "cue": "<'cue-before'> <'cue-after'>?",
      "cue-after": "<url> <decibel>? | none",
      "cue-before": "<url> <decibel>? | none",
      "dominant-baseline": "auto | use-script | no-change | reset-size | ideographic | alphabetic | hanging | mathematical | central | middle | text-after-edge | text-before-edge",
      "fill": "<paint>",
      "fill-opacity": "<number-zero-one>",
      "fill-rule": "nonzero | evenodd",
      "glyph-orientation-horizontal": "<angle>",
      "glyph-orientation-vertical": "<angle>",
      "kerning": "auto | <svg-length>",
      "marker": "none | <url>",
      "marker-end": "none | <url>",
      "marker-mid": "none | <url>",
      "marker-start": "none | <url>",
      "pause": "<'pause-before'> <'pause-after'>?",
      "pause-after": "<time> | none | x-weak | weak | medium | strong | x-strong",
      "pause-before": "<time> | none | x-weak | weak | medium | strong | x-strong",
      "rest": "<'rest-before'> <'rest-after'>?",
      "rest-after": "<time> | none | x-weak | weak | medium | strong | x-strong",
      "rest-before": "<time> | none | x-weak | weak | medium | strong | x-strong",
      "shape-rendering": "auto | optimizeSpeed | crispEdges | geometricPrecision",
      "src": "[ <url> [ format( <string># ) ]? | local( <family-name> ) ]#",
      "speak": "auto | none | normal",
      "speak-as": "normal | spell-out || digits || [ literal-punctuation | no-punctuation ]",
      "stroke": "<paint>",
      "stroke-dasharray": "none | [ <svg-length>+ ]#",
      "stroke-dashoffset": "<svg-length>",
      "stroke-linecap": "butt | round | square",
      "stroke-linejoin": "miter | round | bevel",
      "stroke-miterlimit": "<number-one-or-greater>",
      "stroke-opacity": "<number-zero-one>",
      "stroke-width": "<svg-length>",
      "text-anchor": "start | middle | end",
      "unicode-range": "<unicode-range>#",
      "voice-balance": "<number> | left | center | right | leftwards | rightwards",
      "voice-duration": "auto | <time>",
      "voice-family": "[ [ <family-name> | <generic-voice> ] , ]* [ <family-name> | <generic-voice> ] | preserve",
      "voice-pitch": "<frequency> && absolute | [ [ x-low | low | medium | high | x-high ] || [ <frequency> | <semitones> | <percentage> ] ]",
      "voice-range": "<frequency> && absolute | [ [ x-low | low | medium | high | x-high ] || [ <frequency> | <semitones> | <percentage> ] ]",
      "voice-rate": "[ normal | x-slow | slow | medium | fast | x-fast ] || <percentage>",
      "voice-stress": "normal | strong | moderate | none | reduced",
      "voice-volume": "silent | [ [ x-soft | soft | medium | loud | x-loud ] || <decibel> ]"
    }
  };
  /***/
},
/* 96 */

/***/
function (module, exports, __webpack_require__) {
  module.exports = {
    AnPlusB: __webpack_require__(97),
    Atrule: __webpack_require__(98),
    AtrulePrelude: __webpack_require__(99),
    AttributeSelector: __webpack_require__(100),
    Block: __webpack_require__(101),
    Brackets: __webpack_require__(102),
    CDC: __webpack_require__(103),
    CDO: __webpack_require__(104),
    ClassSelector: __webpack_require__(105),
    Combinator: __webpack_require__(106),
    Comment: __webpack_require__(107),
    Declaration: __webpack_require__(108),
    DeclarationList: __webpack_require__(109),
    Dimension: __webpack_require__(110),
    Function: __webpack_require__(111),
    HexColor: __webpack_require__(112),
    Identifier: __webpack_require__(113),
    IdSelector: __webpack_require__(114),
    MediaFeature: __webpack_require__(115),
    MediaQuery: __webpack_require__(116),
    MediaQueryList: __webpack_require__(117),
    Nth: __webpack_require__(118),
    Number: __webpack_require__(119),
    Operator: __webpack_require__(120),
    Parentheses: __webpack_require__(121),
    Percentage: __webpack_require__(122),
    PseudoClassSelector: __webpack_require__(123),
    PseudoElementSelector: __webpack_require__(124),
    Ratio: __webpack_require__(125),
    Raw: __webpack_require__(126),
    Rule: __webpack_require__(127),
    Selector: __webpack_require__(128),
    SelectorList: __webpack_require__(129),
    String: __webpack_require__(130),
    StyleSheet: __webpack_require__(131),
    TypeSelector: __webpack_require__(132),
    UnicodeRange: __webpack_require__(133),
    Url: __webpack_require__(134),
    Value: __webpack_require__(135),
    WhiteSpace: __webpack_require__(136)
  };
  /***/
},
/* 97 */

/***/
function (module, exports, __webpack_require__) {
  var cmpChar = __webpack_require__(53).cmpChar;

  var isNumber = __webpack_require__(53).isNumber;

  var TYPE = __webpack_require__(53).TYPE;

  var IDENTIFIER = TYPE.Identifier;
  var NUMBER = TYPE.Number;
  var PLUSSIGN = TYPE.PlusSign;
  var HYPHENMINUS = TYPE.HyphenMinus;
  var N = 110; // 'n'.charCodeAt(0)

  var DISALLOW_SIGN = true;
  var ALLOW_SIGN = false;

  function checkTokenIsInteger(scanner, disallowSign) {
    var pos = scanner.tokenStart;

    if (scanner.source.charCodeAt(pos) === PLUSSIGN || scanner.source.charCodeAt(pos) === HYPHENMINUS) {
      if (disallowSign) {
        scanner.error();
      }

      pos++;
    }

    for (; pos < scanner.tokenEnd; pos++) {
      if (!isNumber(scanner.source.charCodeAt(pos))) {
        scanner.error('Unexpected input', pos);
      }
    }
  } // An+B microsyntax https://www.w3.org/TR/css-syntax-3/#anb


  module.exports = {
    name: 'AnPlusB',
    structure: {
      a: [String, null],
      b: [String, null]
    },
    parse: function parse() {
      var start = this.scanner.tokenStart;
      var end = start;
      var prefix = '';
      var a = null;
      var b = null;

      if (this.scanner.tokenType === NUMBER || this.scanner.tokenType === PLUSSIGN) {
        checkTokenIsInteger(this.scanner, ALLOW_SIGN);
        prefix = this.scanner.getTokenValue();
        this.scanner.next();
        end = this.scanner.tokenStart;
      }

      if (this.scanner.tokenType === IDENTIFIER) {
        var bStart = this.scanner.tokenStart;

        if (cmpChar(this.scanner.source, bStart, HYPHENMINUS)) {
          if (prefix === '') {
            prefix = '-';
            bStart++;
          } else {
            this.scanner.error('Unexpected hyphen minus');
          }
        }

        if (!cmpChar(this.scanner.source, bStart, N)) {
          this.scanner.error();
        }

        a = prefix === '' ? '1' : prefix === '+' ? '+1' : prefix === '-' ? '-1' : prefix;
        var len = this.scanner.tokenEnd - bStart;

        if (len > 1) {
          // ..n-..
          if (this.scanner.source.charCodeAt(bStart + 1) !== HYPHENMINUS) {
            this.scanner.error('Unexpected input', bStart + 1);
          }

          if (len > 2) {
            // ..n-{number}..
            this.scanner.tokenStart = bStart + 2;
          } else {
            // ..n- {number}
            this.scanner.next();
            this.scanner.skipSC();
          }

          checkTokenIsInteger(this.scanner, DISALLOW_SIGN);
          b = '-' + this.scanner.getTokenValue();
          this.scanner.next();
          end = this.scanner.tokenStart;
        } else {
          prefix = '';
          this.scanner.next();
          end = this.scanner.tokenStart;
          this.scanner.skipSC();

          if (this.scanner.tokenType === HYPHENMINUS || this.scanner.tokenType === PLUSSIGN) {
            prefix = this.scanner.getTokenValue();
            this.scanner.next();
            this.scanner.skipSC();
          }

          if (this.scanner.tokenType === NUMBER) {
            checkTokenIsInteger(this.scanner, prefix !== '');

            if (!isNumber(this.scanner.source.charCodeAt(this.scanner.tokenStart))) {
              prefix = this.scanner.source.charAt(this.scanner.tokenStart);
              this.scanner.tokenStart++;
            }

            if (prefix === '') {
              // should be an operator before number
              this.scanner.error();
            } else if (prefix === '+') {
              // plus is using by default
              prefix = '';
            }

            b = prefix + this.scanner.getTokenValue();
            this.scanner.next();
            end = this.scanner.tokenStart;
          } else {
            if (prefix) {
              this.scanner.eat(NUMBER);
            }
          }
        }
      } else {
        if (prefix === '' || prefix === '+') {
          // no number
          this.scanner.error('Number or identifier is expected', this.scanner.tokenStart + (this.scanner.tokenType === PLUSSIGN || this.scanner.tokenType === HYPHENMINUS));
        }

        b = prefix;
      }

      return {
        type: 'AnPlusB',
        loc: this.getLocation(start, end),
        a: a,
        b: b
      };
    },
    generate: function generate(node) {
      var a = node.a !== null && node.a !== undefined;
      var b = node.b !== null && node.b !== undefined;

      if (a) {
        this.chunk(node.a === '+1' ? '+n' : node.a === '1' ? 'n' : node.a === '-1' ? '-n' : node.a + 'n');

        if (b) {
          b = String(node.b);

          if (b.charAt(0) === '-' || b.charAt(0) === '+') {
            this.chunk(b.charAt(0));
            this.chunk(b.substr(1));
          } else {
            this.chunk('+');
            this.chunk(b);
          }
        }
      } else {
        this.chunk(String(node.b));
      }
    }
  };
  /***/
},
/* 98 */

/***/
function (module, exports, __webpack_require__) {
  var TYPE = __webpack_require__(53).TYPE;

  var ATKEYWORD = TYPE.AtKeyword;
  var SEMICOLON = TYPE.Semicolon;
  var LEFTCURLYBRACKET = TYPE.LeftCurlyBracket;
  var RIGHTCURLYBRACKET = TYPE.RightCurlyBracket;

  function consumeRaw(startToken) {
    return this.Raw(startToken, SEMICOLON, LEFTCURLYBRACKET, false, true);
  }

  function isDeclarationBlockAtrule() {
    for (var offset = 1, type; type = this.scanner.lookupType(offset); offset++) {
      if (type === RIGHTCURLYBRACKET) {
        return true;
      }

      if (type === LEFTCURLYBRACKET || type === ATKEYWORD) {
        return false;
      }
    }

    return false;
  }

  module.exports = {
    name: 'Atrule',
    structure: {
      name: String,
      prelude: ['AtrulePrelude', 'Raw', null],
      block: ['Block', null]
    },
    parse: function parse() {
      var start = this.scanner.tokenStart;
      var name;
      var nameLowerCase;
      var prelude = null;
      var block = null;
      this.scanner.eat(ATKEYWORD);
      name = this.scanner.substrToCursor(start + 1);
      nameLowerCase = name.toLowerCase();
      this.scanner.skipSC(); // parse prelude

      if (this.scanner.eof === false && this.scanner.tokenType !== LEFTCURLYBRACKET && this.scanner.tokenType !== SEMICOLON) {
        if (this.parseAtrulePrelude) {
          prelude = this.parseWithFallback(this.AtrulePrelude.bind(this, name), consumeRaw); // turn empty AtrulePrelude into null

          if (prelude.type === 'AtrulePrelude' && prelude.children.head === null) {
            prelude = null;
          }
        } else {
          prelude = consumeRaw.call(this, this.scanner.currentToken);
        }

        this.scanner.skipSC();
      }

      switch (this.scanner.tokenType) {
        case SEMICOLON:
          this.scanner.next();
          break;

        case LEFTCURLYBRACKET:
          if (this.atrule.hasOwnProperty(nameLowerCase) && typeof this.atrule[nameLowerCase].block === 'function') {
            block = this.atrule[nameLowerCase].block.call(this);
          } else {
            // TODO: should consume block content as Raw?
            block = this.Block(isDeclarationBlockAtrule.call(this));
          }

          break;
      }

      return {
        type: 'Atrule',
        loc: this.getLocation(start, this.scanner.tokenStart),
        name: name,
        prelude: prelude,
        block: block
      };
    },
    generate: function generate(node) {
      this.chunk('@');
      this.chunk(node.name);

      if (node.prelude !== null) {
        this.chunk(' ');
        this.node(node.prelude);
      }

      if (node.block) {
        this.node(node.block);
      } else {
        this.chunk(';');
      }
    },
    walkContext: 'atrule'
  };
  /***/
},
/* 99 */

/***/
function (module, exports, __webpack_require__) {
  var TYPE = __webpack_require__(53).TYPE;

  var SEMICOLON = TYPE.Semicolon;
  var LEFTCURLYBRACKET = TYPE.LeftCurlyBracket;
  module.exports = {
    name: 'AtrulePrelude',
    structure: {
      children: [[]]
    },
    parse: function parse(name) {
      var children = null;

      if (name !== null) {
        name = name.toLowerCase();
      }

      this.scanner.skipSC();

      if (this.atrule.hasOwnProperty(name) && typeof this.atrule[name].prelude === 'function') {
        // custom consumer
        children = this.atrule[name].prelude.call(this);
      } else {
        // default consumer
        children = this.readSequence(this.scope.AtrulePrelude);
      }

      this.scanner.skipSC();

      if (this.scanner.eof !== true && this.scanner.tokenType !== LEFTCURLYBRACKET && this.scanner.tokenType !== SEMICOLON) {
        this.scanner.error('Semicolon or block is expected');
      }

      if (children === null) {
        children = this.createList();
      }

      return {
        type: 'AtrulePrelude',
        loc: this.getLocationFromList(children),
        children: children
      };
    },
    generate: function generate(node) {
      this.children(node);
    },
    walkContext: 'atrulePrelude'
  };
  /***/
},
/* 100 */

/***/
function (module, exports, __webpack_require__) {
  var TYPE = __webpack_require__(53).TYPE;

  var IDENTIFIER = TYPE.Identifier;
  var STRING = TYPE.String;
  var DOLLARSIGN = TYPE.DollarSign;
  var ASTERISK = TYPE.Asterisk;
  var COLON = TYPE.Colon;
  var EQUALSSIGN = TYPE.EqualsSign;
  var LEFTSQUAREBRACKET = TYPE.LeftSquareBracket;
  var RIGHTSQUAREBRACKET = TYPE.RightSquareBracket;
  var CIRCUMFLEXACCENT = TYPE.CircumflexAccent;
  var VERTICALLINE = TYPE.VerticalLine;
  var TILDE = TYPE.Tilde;

  function getAttributeName() {
    if (this.scanner.eof) {
      this.scanner.error('Unexpected end of input');
    }

    var start = this.scanner.tokenStart;
    var expectIdentifier = false;
    var checkColon = true;

    if (this.scanner.tokenType === ASTERISK) {
      expectIdentifier = true;
      checkColon = false;
      this.scanner.next();
    } else if (this.scanner.tokenType !== VERTICALLINE) {
      this.scanner.eat(IDENTIFIER);
    }

    if (this.scanner.tokenType === VERTICALLINE) {
      if (this.scanner.lookupType(1) !== EQUALSSIGN) {
        this.scanner.next();
        this.scanner.eat(IDENTIFIER);
      } else if (expectIdentifier) {
        this.scanner.error('Identifier is expected', this.scanner.tokenEnd);
      }
    } else if (expectIdentifier) {
      this.scanner.error('Vertical line is expected');
    }

    if (checkColon && this.scanner.tokenType === COLON) {
      this.scanner.next();
      this.scanner.eat(IDENTIFIER);
    }

    return {
      type: 'Identifier',
      loc: this.getLocation(start, this.scanner.tokenStart),
      name: this.scanner.substrToCursor(start)
    };
  }

  function getOperator() {
    var start = this.scanner.tokenStart;
    var tokenType = this.scanner.tokenType;

    if (tokenType !== EQUALSSIGN && // =
    tokenType !== TILDE && // ~=
    tokenType !== CIRCUMFLEXACCENT && // ^=
    tokenType !== DOLLARSIGN && // $=
    tokenType !== ASTERISK && // *=
    tokenType !== VERTICALLINE // |=
    ) {
        this.scanner.error('Attribute selector (=, ~=, ^=, $=, *=, |=) is expected');
      }

    if (tokenType === EQUALSSIGN) {
      this.scanner.next();
    } else {
      this.scanner.next();
      this.scanner.eat(EQUALSSIGN);
    }

    return this.scanner.substrToCursor(start);
  } // '[' S* attrib_name ']'
  // '[' S* attrib_name S* attrib_matcher S* [ IDENT | STRING ] S* attrib_flags? S* ']'


  module.exports = {
    name: 'AttributeSelector',
    structure: {
      name: 'Identifier',
      matcher: [String, null],
      value: ['String', 'Identifier', null],
      flags: [String, null]
    },
    parse: function parse() {
      var start = this.scanner.tokenStart;
      var name;
      var matcher = null;
      var value = null;
      var flags = null;
      this.scanner.eat(LEFTSQUAREBRACKET);
      this.scanner.skipSC();
      name = getAttributeName.call(this);
      this.scanner.skipSC();

      if (this.scanner.tokenType !== RIGHTSQUAREBRACKET) {
        // avoid case `[name i]`
        if (this.scanner.tokenType !== IDENTIFIER) {
          matcher = getOperator.call(this);
          this.scanner.skipSC();
          value = this.scanner.tokenType === STRING ? this.String() : this.Identifier();
          this.scanner.skipSC();
        } // attribute flags


        if (this.scanner.tokenType === IDENTIFIER) {
          flags = this.scanner.getTokenValue();
          this.scanner.next();
          this.scanner.skipSC();
        }
      }

      this.scanner.eat(RIGHTSQUAREBRACKET);
      return {
        type: 'AttributeSelector',
        loc: this.getLocation(start, this.scanner.tokenStart),
        name: name,
        matcher: matcher,
        value: value,
        flags: flags
      };
    },
    generate: function generate(node) {
      var flagsPrefix = ' ';
      this.chunk('[');
      this.node(node.name);

      if (node.matcher !== null) {
        this.chunk(node.matcher);

        if (node.value !== null) {
          this.node(node.value); // space between string and flags is not required

          if (node.value.type === 'String') {
            flagsPrefix = '';
          }
        }
      }

      if (node.flags !== null) {
        this.chunk(flagsPrefix);
        this.chunk(node.flags);
      }

      this.chunk(']');
    }
  };
  /***/
},
/* 101 */

/***/
function (module, exports, __webpack_require__) {
  var TYPE = __webpack_require__(53).TYPE;

  var WHITESPACE = TYPE.WhiteSpace;
  var COMMENT = TYPE.Comment;
  var SEMICOLON = TYPE.Semicolon;
  var ATKEYWORD = TYPE.AtKeyword;
  var LEFTCURLYBRACKET = TYPE.LeftCurlyBracket;
  var RIGHTCURLYBRACKET = TYPE.RightCurlyBracket;

  function consumeRaw(startToken) {
    return this.Raw(startToken, 0, 0, false, true);
  }

  function consumeRule() {
    return this.parseWithFallback(this.Rule, consumeRaw);
  }

  function consumeRawDeclaration(startToken) {
    return this.Raw(startToken, 0, SEMICOLON, true, true);
  }

  function consumeDeclaration() {
    if (this.scanner.tokenType === SEMICOLON) {
      return consumeRawDeclaration.call(this, this.scanner.currentToken);
    }

    var node = this.parseWithFallback(this.Declaration, consumeRawDeclaration);

    if (this.scanner.tokenType === SEMICOLON) {
      this.scanner.next();
    }

    return node;
  }

  module.exports = {
    name: 'Block',
    structure: {
      children: [['Atrule', 'Rule', 'Declaration']]
    },
    parse: function parse(isDeclaration) {
      var consumer = isDeclaration ? consumeDeclaration : consumeRule;
      var start = this.scanner.tokenStart;
      var children = this.createList();
      this.scanner.eat(LEFTCURLYBRACKET);

      scan: while (!this.scanner.eof) {
        switch (this.scanner.tokenType) {
          case RIGHTCURLYBRACKET:
            break scan;

          case WHITESPACE:
          case COMMENT:
            this.scanner.next();
            break;

          case ATKEYWORD:
            children.push(this.parseWithFallback(this.Atrule, consumeRaw));
            break;

          default:
            children.push(consumer.call(this));
        }
      }

      if (!this.scanner.eof) {
        this.scanner.eat(RIGHTCURLYBRACKET);
      }

      return {
        type: 'Block',
        loc: this.getLocation(start, this.scanner.tokenStart),
        children: children
      };
    },
    generate: function generate(node) {
      this.chunk('{');
      this.children(node, function (prev) {
        if (prev.type === 'Declaration') {
          this.chunk(';');
        }
      });
      this.chunk('}');
    },
    walkContext: 'block'
  };
  /***/
},
/* 102 */

/***/
function (module, exports, __webpack_require__) {
  var TYPE = __webpack_require__(53).TYPE;

  var LEFTSQUAREBRACKET = TYPE.LeftSquareBracket;
  var RIGHTSQUAREBRACKET = TYPE.RightSquareBracket;
  module.exports = {
    name: 'Brackets',
    structure: {
      children: [[]]
    },
    parse: function parse(readSequence, recognizer) {
      var start = this.scanner.tokenStart;
      var children = null;
      this.scanner.eat(LEFTSQUAREBRACKET);
      children = readSequence.call(this, recognizer);

      if (!this.scanner.eof) {
        this.scanner.eat(RIGHTSQUAREBRACKET);
      }

      return {
        type: 'Brackets',
        loc: this.getLocation(start, this.scanner.tokenStart),
        children: children
      };
    },
    generate: function generate(node) {
      this.chunk('[');
      this.children(node);
      this.chunk(']');
    }
  };
  /***/
},
/* 103 */

/***/
function (module, exports, __webpack_require__) {
  var CDC = __webpack_require__(53).TYPE.CDC;

  module.exports = {
    name: 'CDC',
    structure: [],
    parse: function parse() {
      var start = this.scanner.tokenStart;
      this.scanner.eat(CDC); // -->

      return {
        type: 'CDC',
        loc: this.getLocation(start, this.scanner.tokenStart)
      };
    },
    generate: function generate() {
      this.chunk('-->');
    }
  };
  /***/
},
/* 104 */

/***/
function (module, exports, __webpack_require__) {
  var CDO = __webpack_require__(53).TYPE.CDO;

  module.exports = {
    name: 'CDO',
    structure: [],
    parse: function parse() {
      var start = this.scanner.tokenStart;
      this.scanner.eat(CDO); // <!--

      return {
        type: 'CDO',
        loc: this.getLocation(start, this.scanner.tokenStart)
      };
    },
    generate: function generate() {
      this.chunk('<!--');
    }
  };
  /***/
},
/* 105 */

/***/
function (module, exports, __webpack_require__) {
  var TYPE = __webpack_require__(53).TYPE;

  var IDENTIFIER = TYPE.Identifier;
  var FULLSTOP = TYPE.FullStop; // '.' ident

  module.exports = {
    name: 'ClassSelector',
    structure: {
      name: String
    },
    parse: function parse() {
      this.scanner.eat(FULLSTOP);
      return {
        type: 'ClassSelector',
        loc: this.getLocation(this.scanner.tokenStart - 1, this.scanner.tokenEnd),
        name: this.scanner.consume(IDENTIFIER)
      };
    },
    generate: function generate(node) {
      this.chunk('.');
      this.chunk(node.name);
    }
  };
  /***/
},
/* 106 */

/***/
function (module, exports, __webpack_require__) {
  var TYPE = __webpack_require__(53).TYPE;

  var PLUSSIGN = TYPE.PlusSign;
  var SOLIDUS = TYPE.Solidus;
  var GREATERTHANSIGN = TYPE.GreaterThanSign;
  var TILDE = TYPE.Tilde; // + | > | ~ | /deep/

  module.exports = {
    name: 'Combinator',
    structure: {
      name: String
    },
    parse: function parse() {
      var start = this.scanner.tokenStart;

      switch (this.scanner.tokenType) {
        case GREATERTHANSIGN:
        case PLUSSIGN:
        case TILDE:
          this.scanner.next();
          break;

        case SOLIDUS:
          this.scanner.next();
          this.scanner.expectIdentifier('deep');
          this.scanner.eat(SOLIDUS);
          break;

        default:
          this.scanner.error('Combinator is expected');
      }

      return {
        type: 'Combinator',
        loc: this.getLocation(start, this.scanner.tokenStart),
        name: this.scanner.substrToCursor(start)
      };
    },
    generate: function generate(node) {
      this.chunk(node.name);
    }
  };
  /***/
},
/* 107 */

/***/
function (module, exports, __webpack_require__) {
  var TYPE = __webpack_require__(53).TYPE;

  var ASTERISK = TYPE.Asterisk;
  var SOLIDUS = TYPE.Solidus; // '/*' .* '*/'

  module.exports = {
    name: 'Comment',
    structure: {
      value: String
    },
    parse: function parse() {
      var start = this.scanner.tokenStart;
      var end = this.scanner.tokenEnd;

      if (end - start + 2 >= 2 && this.scanner.source.charCodeAt(end - 2) === ASTERISK && this.scanner.source.charCodeAt(end - 1) === SOLIDUS) {
        end -= 2;
      }

      this.scanner.next();
      return {
        type: 'Comment',
        loc: this.getLocation(start, this.scanner.tokenStart),
        value: this.scanner.source.substring(start + 2, end)
      };
    },
    generate: function generate(node) {
      this.chunk('/*');
      this.chunk(node.value);
      this.chunk('*/');
    }
  };
  /***/
},
/* 108 */

/***/
function (module, exports, __webpack_require__) {
  var isCustomProperty = __webpack_require__(62).isCustomProperty;

  var TYPE = __webpack_require__(53).TYPE;

  var IDENTIFIER = TYPE.Identifier;
  var COLON = TYPE.Colon;
  var EXCLAMATIONMARK = TYPE.ExclamationMark;
  var SOLIDUS = TYPE.Solidus;
  var ASTERISK = TYPE.Asterisk;
  var DOLLARSIGN = TYPE.DollarSign;
  var HYPHENMINUS = TYPE.HyphenMinus;
  var SEMICOLON = TYPE.Semicolon;
  var PLUSSIGN = TYPE.PlusSign;
  var NUMBERSIGN = TYPE.NumberSign;

  function consumeValueRaw(startToken) {
    return this.Raw(startToken, EXCLAMATIONMARK, SEMICOLON, false, true);
  }

  function consumeCustomPropertyRaw(startToken) {
    return this.Raw(startToken, EXCLAMATIONMARK, SEMICOLON, false, false);
  }

  function consumeValue() {
    var startValueToken = this.scanner.currentToken;
    var value = this.Value();

    if (value.type !== 'Raw' && this.scanner.eof === false && this.scanner.tokenType !== SEMICOLON && this.scanner.tokenType !== EXCLAMATIONMARK && this.scanner.isBalanceEdge(startValueToken) === false) {
      this.scanner.error();
    }

    return value;
  }

  module.exports = {
    name: 'Declaration',
    structure: {
      important: [Boolean, String],
      property: String,
      value: ['Value', 'Raw']
    },
    parse: function parse() {
      var start = this.scanner.tokenStart;
      var startToken = this.scanner.currentToken;
      var property = readProperty.call(this);
      var customProperty = isCustomProperty(property);
      var parseValue = customProperty ? this.parseCustomProperty : this.parseValue;
      var consumeRaw = customProperty ? consumeCustomPropertyRaw : consumeValueRaw;
      var important = false;
      var value;
      this.scanner.skipSC();
      this.scanner.eat(COLON);

      if (!customProperty) {
        this.scanner.skipSC();
      }

      if (parseValue) {
        value = this.parseWithFallback(consumeValue, consumeRaw);
      } else {
        value = consumeRaw.call(this, this.scanner.currentToken);
      }

      if (this.scanner.tokenType === EXCLAMATIONMARK) {
        important = getImportant(this.scanner);
        this.scanner.skipSC();
      } // Do not include semicolon to range per spec
      // https://drafts.csswg.org/css-syntax/#declaration-diagram


      if (this.scanner.eof === false && this.scanner.tokenType !== SEMICOLON && this.scanner.isBalanceEdge(startToken) === false) {
        this.scanner.error();
      }

      return {
        type: 'Declaration',
        loc: this.getLocation(start, this.scanner.tokenStart),
        important: important,
        property: property,
        value: value
      };
    },
    generate: function generate(node) {
      this.chunk(node.property);
      this.chunk(':');
      this.node(node.value);

      if (node.important) {
        this.chunk(node.important === true ? '!important' : '!' + node.important);
      }
    },
    walkContext: 'declaration'
  };

  function readProperty() {
    var start = this.scanner.tokenStart;
    var prefix = 0; // hacks

    switch (this.scanner.tokenType) {
      case ASTERISK:
      case DOLLARSIGN:
      case PLUSSIGN:
      case NUMBERSIGN:
        prefix = 1;
        break;
      // TODO: not sure we should support this hack

      case SOLIDUS:
        prefix = this.scanner.lookupType(1) === SOLIDUS ? 2 : 1;
        break;
    }

    if (this.scanner.lookupType(prefix) === HYPHENMINUS) {
      prefix++;
    }

    if (prefix) {
      this.scanner.skip(prefix);
    }

    this.scanner.eat(IDENTIFIER);
    return this.scanner.substrToCursor(start);
  } // ! ws* important


  function getImportant(scanner) {
    scanner.eat(EXCLAMATIONMARK);
    scanner.skipSC();
    var important = scanner.consume(IDENTIFIER); // store original value in case it differ from `important`
    // for better original source restoring and hacks like `!ie` support

    return important === 'important' ? true : important;
  }
  /***/

},
/* 109 */

/***/
function (module, exports, __webpack_require__) {
  var TYPE = __webpack_require__(53).TYPE;

  var WHITESPACE = TYPE.WhiteSpace;
  var COMMENT = TYPE.Comment;
  var SEMICOLON = TYPE.Semicolon;

  function consumeRaw(startToken) {
    return this.Raw(startToken, 0, SEMICOLON, true, true);
  }

  module.exports = {
    name: 'DeclarationList',
    structure: {
      children: [['Declaration']]
    },
    parse: function parse() {
      var children = this.createList();

      scan: while (!this.scanner.eof) {
        switch (this.scanner.tokenType) {
          case WHITESPACE:
          case COMMENT:
          case SEMICOLON:
            this.scanner.next();
            break;

          default:
            children.push(this.parseWithFallback(this.Declaration, consumeRaw));
        }
      }

      return {
        type: 'DeclarationList',
        loc: this.getLocationFromList(children),
        children: children
      };
    },
    generate: function generate(node) {
      this.children(node, function (prev) {
        if (prev.type === 'Declaration') {
          this.chunk(';');
        }
      });
    }
  };
  /***/
},
/* 110 */

/***/
function (module, exports, __webpack_require__) {
  var NUMBER = __webpack_require__(53).TYPE.Number; // special reader for units to avoid adjoined IE hacks (i.e. '1px\9')


  function readUnit(scanner) {
    var unit = scanner.getTokenValue();
    var backSlashPos = unit.indexOf('\\');

    if (backSlashPos > 0) {
      // patch token offset
      scanner.tokenStart += backSlashPos; // return part before backslash

      return unit.substring(0, backSlashPos);
    } // no backslash in unit name


    scanner.next();
    return unit;
  } // number ident


  module.exports = {
    name: 'Dimension',
    structure: {
      value: String,
      unit: String
    },
    parse: function parse() {
      var start = this.scanner.tokenStart;
      var value = this.scanner.consume(NUMBER);
      var unit = readUnit(this.scanner);
      return {
        type: 'Dimension',
        loc: this.getLocation(start, this.scanner.tokenStart),
        value: value,
        unit: unit
      };
    },
    generate: function generate(node) {
      this.chunk(node.value);
      this.chunk(node.unit);
    }
  };
  /***/
},
/* 111 */

/***/
function (module, exports, __webpack_require__) {
  var TYPE = __webpack_require__(53).TYPE;

  var RIGHTPARENTHESIS = TYPE.RightParenthesis; // <function-token> <sequence> ')'

  module.exports = {
    name: 'Function',
    structure: {
      name: String,
      children: [[]]
    },
    parse: function parse(readSequence, recognizer) {
      var start = this.scanner.tokenStart;
      var name = this.scanner.consumeFunctionName();
      var nameLowerCase = name.toLowerCase();
      var children;
      children = recognizer.hasOwnProperty(nameLowerCase) ? recognizer[nameLowerCase].call(this, recognizer) : readSequence.call(this, recognizer);

      if (!this.scanner.eof) {
        this.scanner.eat(RIGHTPARENTHESIS);
      }

      return {
        type: 'Function',
        loc: this.getLocation(start, this.scanner.tokenStart),
        name: name,
        children: children
      };
    },
    generate: function generate(node) {
      this.chunk(node.name);
      this.chunk('(');
      this.children(node);
      this.chunk(')');
    },
    walkContext: 'function'
  };
  /***/
},
/* 112 */

/***/
function (module, exports, __webpack_require__) {
  var isHex = __webpack_require__(53).isHex;

  var TYPE = __webpack_require__(53).TYPE;

  var IDENTIFIER = TYPE.Identifier;
  var NUMBER = TYPE.Number;
  var NUMBERSIGN = TYPE.NumberSign;

  function consumeHexSequence(scanner, required) {
    if (!isHex(scanner.source.charCodeAt(scanner.tokenStart))) {
      if (required) {
        scanner.error('Unexpected input', scanner.tokenStart);
      } else {
        return;
      }
    }

    for (var pos = scanner.tokenStart + 1; pos < scanner.tokenEnd; pos++) {
      var code = scanner.source.charCodeAt(pos); // break on non-hex char

      if (!isHex(code)) {
        // break token, exclude symbol
        scanner.tokenStart = pos;
        return;
      }
    } // token is full hex sequence, go to next token


    scanner.next();
  } // # ident


  module.exports = {
    name: 'HexColor',
    structure: {
      value: String
    },
    parse: function parse() {
      var start = this.scanner.tokenStart;
      this.scanner.eat(NUMBERSIGN);

      scan: switch (this.scanner.tokenType) {
        case NUMBER:
          consumeHexSequence(this.scanner, true); // if token is identifier then number consists of hex only,
          // try to add identifier to result

          if (this.scanner.tokenType === IDENTIFIER) {
            consumeHexSequence(this.scanner, false);
          }

          break;

        case IDENTIFIER:
          consumeHexSequence(this.scanner, true);
          break;

        default:
          this.scanner.error('Number or identifier is expected');
      }

      return {
        type: 'HexColor',
        loc: this.getLocation(start, this.scanner.tokenStart),
        value: this.scanner.substrToCursor(start + 1) // skip #

      };
    },
    generate: function generate(node) {
      this.chunk('#');
      this.chunk(node.value);
    }
  };
  /***/
},
/* 113 */

/***/
function (module, exports, __webpack_require__) {
  var TYPE = __webpack_require__(53).TYPE;

  var IDENTIFIER = TYPE.Identifier;
  module.exports = {
    name: 'Identifier',
    structure: {
      name: String
    },
    parse: function parse() {
      return {
        type: 'Identifier',
        loc: this.getLocation(this.scanner.tokenStart, this.scanner.tokenEnd),
        name: this.scanner.consume(IDENTIFIER)
      };
    },
    generate: function generate(node) {
      this.chunk(node.name);
    }
  };
  /***/
},
/* 114 */

/***/
function (module, exports, __webpack_require__) {
  var TYPE = __webpack_require__(53).TYPE;

  var IDENTIFIER = TYPE.Identifier;
  var NUMBERSIGN = TYPE.NumberSign; // '#' ident

  module.exports = {
    name: 'IdSelector',
    structure: {
      name: String
    },
    parse: function parse() {
      this.scanner.eat(NUMBERSIGN);
      return {
        type: 'IdSelector',
        loc: this.getLocation(this.scanner.tokenStart - 1, this.scanner.tokenEnd),
        name: this.scanner.consume(IDENTIFIER)
      };
    },
    generate: function generate(node) {
      this.chunk('#');
      this.chunk(node.name);
    }
  };
  /***/
},
/* 115 */

/***/
function (module, exports, __webpack_require__) {
  var TYPE = __webpack_require__(53).TYPE;

  var IDENTIFIER = TYPE.Identifier;
  var NUMBER = TYPE.Number;
  var LEFTPARENTHESIS = TYPE.LeftParenthesis;
  var RIGHTPARENTHESIS = TYPE.RightParenthesis;
  var COLON = TYPE.Colon;
  var SOLIDUS = TYPE.Solidus;
  module.exports = {
    name: 'MediaFeature',
    structure: {
      name: String,
      value: ['Identifier', 'Number', 'Dimension', 'Ratio', null]
    },
    parse: function parse() {
      var start = this.scanner.tokenStart;
      var name;
      var value = null;
      this.scanner.eat(LEFTPARENTHESIS);
      this.scanner.skipSC();
      name = this.scanner.consume(IDENTIFIER);
      this.scanner.skipSC();

      if (this.scanner.tokenType !== RIGHTPARENTHESIS) {
        this.scanner.eat(COLON);
        this.scanner.skipSC();

        switch (this.scanner.tokenType) {
          case NUMBER:
            if (this.scanner.lookupType(1) === IDENTIFIER) {
              value = this.Dimension();
            } else if (this.scanner.lookupNonWSType(1) === SOLIDUS) {
              value = this.Ratio();
            } else {
              value = this.Number();
            }

            break;

          case IDENTIFIER:
            value = this.Identifier();
            break;

          default:
            this.scanner.error('Number, dimension, ratio or identifier is expected');
        }

        this.scanner.skipSC();
      }

      this.scanner.eat(RIGHTPARENTHESIS);
      return {
        type: 'MediaFeature',
        loc: this.getLocation(start, this.scanner.tokenStart),
        name: name,
        value: value
      };
    },
    generate: function generate(node) {
      this.chunk('(');
      this.chunk(node.name);

      if (node.value !== null) {
        this.chunk(':');
        this.node(node.value);
      }

      this.chunk(')');
    }
  };
  /***/
},
/* 116 */

/***/
function (module, exports, __webpack_require__) {
  var TYPE = __webpack_require__(53).TYPE;

  var WHITESPACE = TYPE.WhiteSpace;
  var COMMENT = TYPE.Comment;
  var IDENTIFIER = TYPE.Identifier;
  var LEFTPARENTHESIS = TYPE.LeftParenthesis;
  module.exports = {
    name: 'MediaQuery',
    structure: {
      children: [['Identifier', 'MediaFeature', 'WhiteSpace']]
    },
    parse: function parse() {
      this.scanner.skipSC();
      var children = this.createList();
      var child = null;
      var space = null;

      scan: while (!this.scanner.eof) {
        switch (this.scanner.tokenType) {
          case COMMENT:
            this.scanner.next();
            continue;

          case WHITESPACE:
            space = this.WhiteSpace();
            continue;

          case IDENTIFIER:
            child = this.Identifier();
            break;

          case LEFTPARENTHESIS:
            child = this.MediaFeature();
            break;

          default:
            break scan;
        }

        if (space !== null) {
          children.push(space);
          space = null;
        }

        children.push(child);
      }

      if (child === null) {
        this.scanner.error('Identifier or parenthesis is expected');
      }

      return {
        type: 'MediaQuery',
        loc: this.getLocationFromList(children),
        children: children
      };
    },
    generate: function generate(node) {
      this.children(node);
    }
  };
  /***/
},
/* 117 */

/***/
function (module, exports, __webpack_require__) {
  var COMMA = __webpack_require__(53).TYPE.Comma;

  module.exports = {
    name: 'MediaQueryList',
    structure: {
      children: [['MediaQuery']]
    },
    parse: function parse(relative) {
      var children = this.createList();
      this.scanner.skipSC();

      while (!this.scanner.eof) {
        children.push(this.MediaQuery(relative));

        if (this.scanner.tokenType !== COMMA) {
          break;
        }

        this.scanner.next();
      }

      return {
        type: 'MediaQueryList',
        loc: this.getLocationFromList(children),
        children: children
      };
    },
    generate: function generate(node) {
      this.children(node, function () {
        this.chunk(',');
      });
    }
  };
  /***/
},
/* 118 */

/***/
function (module, exports) {
  // https://drafts.csswg.org/css-syntax-3/#the-anb-type
  module.exports = {
    name: 'Nth',
    structure: {
      nth: ['AnPlusB', 'Identifier'],
      selector: ['SelectorList', null]
    },
    parse: function parse(allowOfClause) {
      this.scanner.skipSC();
      var start = this.scanner.tokenStart;
      var end = start;
      var selector = null;
      var query;

      if (this.scanner.lookupValue(0, 'odd') || this.scanner.lookupValue(0, 'even')) {
        query = this.Identifier();
      } else {
        query = this.AnPlusB();
      }

      this.scanner.skipSC();

      if (allowOfClause && this.scanner.lookupValue(0, 'of')) {
        this.scanner.next();
        selector = this.SelectorList();

        if (this.needPositions) {
          end = this.getLastListNode(selector.children).loc.end.offset;
        }
      } else {
        if (this.needPositions) {
          end = query.loc.end.offset;
        }
      }

      return {
        type: 'Nth',
        loc: this.getLocation(start, end),
        nth: query,
        selector: selector
      };
    },
    generate: function generate(node) {
      this.node(node.nth);

      if (node.selector !== null) {
        this.chunk(' of ');
        this.node(node.selector);
      }
    }
  };
  /***/
},
/* 119 */

/***/
function (module, exports, __webpack_require__) {
  var NUMBER = __webpack_require__(53).TYPE.Number;

  module.exports = {
    name: 'Number',
    structure: {
      value: String
    },
    parse: function parse() {
      return {
        type: 'Number',
        loc: this.getLocation(this.scanner.tokenStart, this.scanner.tokenEnd),
        value: this.scanner.consume(NUMBER)
      };
    },
    generate: function generate(node) {
      this.chunk(node.value);
    }
  };
  /***/
},
/* 120 */

/***/
function (module, exports) {
  // '/' | '*' | ',' | ':' | '+' | '-'
  module.exports = {
    name: 'Operator',
    structure: {
      value: String
    },
    parse: function parse() {
      var start = this.scanner.tokenStart;
      this.scanner.next();
      return {
        type: 'Operator',
        loc: this.getLocation(start, this.scanner.tokenStart),
        value: this.scanner.substrToCursor(start)
      };
    },
    generate: function generate(node) {
      this.chunk(node.value);
    }
  };
  /***/
},
/* 121 */

/***/
function (module, exports, __webpack_require__) {
  var TYPE = __webpack_require__(53).TYPE;

  var LEFTPARENTHESIS = TYPE.LeftParenthesis;
  var RIGHTPARENTHESIS = TYPE.RightParenthesis;
  module.exports = {
    name: 'Parentheses',
    structure: {
      children: [[]]
    },
    parse: function parse(readSequence, recognizer) {
      var start = this.scanner.tokenStart;
      var children = null;
      this.scanner.eat(LEFTPARENTHESIS);
      children = readSequence.call(this, recognizer);

      if (!this.scanner.eof) {
        this.scanner.eat(RIGHTPARENTHESIS);
      }

      return {
        type: 'Parentheses',
        loc: this.getLocation(start, this.scanner.tokenStart),
        children: children
      };
    },
    generate: function generate(node) {
      this.chunk('(');
      this.children(node);
      this.chunk(')');
    }
  };
  /***/
},
/* 122 */

/***/
function (module, exports, __webpack_require__) {
  var TYPE = __webpack_require__(53).TYPE;

  var NUMBER = TYPE.Number;
  var PERCENTSIGN = TYPE.PercentSign;
  module.exports = {
    name: 'Percentage',
    structure: {
      value: String
    },
    parse: function parse() {
      var start = this.scanner.tokenStart;
      var number = this.scanner.consume(NUMBER);
      this.scanner.eat(PERCENTSIGN);
      return {
        type: 'Percentage',
        loc: this.getLocation(start, this.scanner.tokenStart),
        value: number
      };
    },
    generate: function generate(node) {
      this.chunk(node.value);
      this.chunk('%');
    }
  };
  /***/
},
/* 123 */

/***/
function (module, exports, __webpack_require__) {
  var TYPE = __webpack_require__(53).TYPE;

  var IDENTIFIER = TYPE.Identifier;
  var FUNCTION = TYPE.Function;
  var COLON = TYPE.Colon;
  var RIGHTPARENTHESIS = TYPE.RightParenthesis; // : ident [ '(' .. ')' ]?

  module.exports = {
    name: 'PseudoClassSelector',
    structure: {
      name: String,
      children: [['Raw'], null]
    },
    parse: function parse() {
      var start = this.scanner.tokenStart;
      var children = null;
      var name;
      var nameLowerCase;
      this.scanner.eat(COLON);

      if (this.scanner.tokenType === FUNCTION) {
        name = this.scanner.consumeFunctionName();
        nameLowerCase = name.toLowerCase();

        if (this.pseudo.hasOwnProperty(nameLowerCase)) {
          this.scanner.skipSC();
          children = this.pseudo[nameLowerCase].call(this);
          this.scanner.skipSC();
        } else {
          children = this.createList();
          children.push(this.Raw(this.scanner.currentToken, 0, 0, false, false));
        }

        this.scanner.eat(RIGHTPARENTHESIS);
      } else {
        name = this.scanner.consume(IDENTIFIER);
      }

      return {
        type: 'PseudoClassSelector',
        loc: this.getLocation(start, this.scanner.tokenStart),
        name: name,
        children: children
      };
    },
    generate: function generate(node) {
      this.chunk(':');
      this.chunk(node.name);

      if (node.children !== null) {
        this.chunk('(');
        this.children(node);
        this.chunk(')');
      }
    },
    walkContext: 'function'
  };
  /***/
},
/* 124 */

/***/
function (module, exports, __webpack_require__) {
  var TYPE = __webpack_require__(53).TYPE;

  var IDENTIFIER = TYPE.Identifier;
  var FUNCTION = TYPE.Function;
  var COLON = TYPE.Colon;
  var RIGHTPARENTHESIS = TYPE.RightParenthesis; // :: ident [ '(' .. ')' ]?

  module.exports = {
    name: 'PseudoElementSelector',
    structure: {
      name: String,
      children: [['Raw'], null]
    },
    parse: function parse() {
      var start = this.scanner.tokenStart;
      var children = null;
      var name;
      var nameLowerCase;
      this.scanner.eat(COLON);
      this.scanner.eat(COLON);

      if (this.scanner.tokenType === FUNCTION) {
        name = this.scanner.consumeFunctionName();
        nameLowerCase = name.toLowerCase();

        if (this.pseudo.hasOwnProperty(nameLowerCase)) {
          this.scanner.skipSC();
          children = this.pseudo[nameLowerCase].call(this);
          this.scanner.skipSC();
        } else {
          children = this.createList();
          children.push(this.Raw(this.scanner.currentToken, 0, 0, false, false));
        }

        this.scanner.eat(RIGHTPARENTHESIS);
      } else {
        name = this.scanner.consume(IDENTIFIER);
      }

      return {
        type: 'PseudoElementSelector',
        loc: this.getLocation(start, this.scanner.tokenStart),
        name: name,
        children: children
      };
    },
    generate: function generate(node) {
      this.chunk('::');
      this.chunk(node.name);

      if (node.children !== null) {
        this.chunk('(');
        this.children(node);
        this.chunk(')');
      }
    },
    walkContext: 'function'
  };
  /***/
},
/* 125 */

/***/
function (module, exports, __webpack_require__) {
  var isNumber = __webpack_require__(53).isNumber;

  var TYPE = __webpack_require__(53).TYPE;

  var NUMBER = TYPE.Number;
  var SOLIDUS = TYPE.Solidus;
  var FULLSTOP = TYPE.FullStop; // Terms of <ratio> should to be a positive number (not zero or negative)
  // (see https://drafts.csswg.org/mediaqueries-3/#values)
  // However, -o-min-device-pixel-ratio takes fractional values as a ratio's term
  // and this is using by various sites. Therefore we relax checking on parse
  // to test a term is unsigned number without exponent part.
  // Additional checks may to be applied on lexer validation.

  function consumeNumber(scanner) {
    var value = scanner.consumeNonWS(NUMBER);

    for (var i = 0; i < value.length; i++) {
      var code = value.charCodeAt(i);

      if (!isNumber(code) && code !== FULLSTOP) {
        scanner.error('Unsigned number is expected', scanner.tokenStart - value.length + i);
      }
    }

    if (Number(value) === 0) {
      scanner.error('Zero number is not allowed', scanner.tokenStart - value.length);
    }

    return value;
  } // <positive-integer> S* '/' S* <positive-integer>


  module.exports = {
    name: 'Ratio',
    structure: {
      left: String,
      right: String
    },
    parse: function parse() {
      var start = this.scanner.tokenStart;
      var left = consumeNumber(this.scanner);
      var right;
      this.scanner.eatNonWS(SOLIDUS);
      right = consumeNumber(this.scanner);
      return {
        type: 'Ratio',
        loc: this.getLocation(start, this.scanner.tokenStart),
        left: left,
        right: right
      };
    },
    generate: function generate(node) {
      this.chunk(node.left);
      this.chunk('/');
      this.chunk(node.right);
    }
  };
  /***/
},
/* 126 */

/***/
function (module, exports) {
  module.exports = {
    name: 'Raw',
    structure: {
      value: String
    },
    parse: function parse(startToken, endTokenType1, endTokenType2, includeTokenType2, excludeWhiteSpace) {
      var startOffset = this.scanner.getTokenStart(startToken);
      var endOffset;
      this.scanner.skip(this.scanner.getRawLength(startToken, endTokenType1, endTokenType2, includeTokenType2));

      if (excludeWhiteSpace && this.scanner.tokenStart > startOffset) {
        endOffset = this.scanner.getOffsetExcludeWS();
      } else {
        endOffset = this.scanner.tokenStart;
      }

      return {
        type: 'Raw',
        loc: this.getLocation(startOffset, endOffset),
        value: this.scanner.source.substring(startOffset, endOffset)
      };
    },
    generate: function generate(node) {
      this.chunk(node.value);
    }
  };
  /***/
},
/* 127 */

/***/
function (module, exports, __webpack_require__) {
  var TYPE = __webpack_require__(53).TYPE;

  var LEFTCURLYBRACKET = TYPE.LeftCurlyBracket;

  function consumeRaw(startToken) {
    return this.Raw(startToken, LEFTCURLYBRACKET, 0, false, true);
  }

  function consumePrelude() {
    var prelude = this.SelectorList();

    if (prelude.type !== 'Raw' && this.scanner.eof === false && this.scanner.tokenType !== LEFTCURLYBRACKET) {
      this.scanner.error();
    }

    return prelude;
  }

  module.exports = {
    name: 'Rule',
    structure: {
      prelude: ['SelectorList', 'Raw'],
      block: ['Block']
    },
    parse: function parse() {
      var startToken = this.scanner.currentToken;
      var startOffset = this.scanner.tokenStart;
      var prelude;
      var block;

      if (this.parseRulePrelude) {
        prelude = this.parseWithFallback(consumePrelude, consumeRaw);
      } else {
        prelude = consumeRaw.call(this, startToken);
      }

      block = this.Block(true);
      return {
        type: 'Rule',
        loc: this.getLocation(startOffset, this.scanner.tokenStart),
        prelude: prelude,
        block: block
      };
    },
    generate: function generate(node) {
      this.node(node.prelude);
      this.node(node.block);
    },
    walkContext: 'rule'
  };
  /***/
},
/* 128 */

/***/
function (module, exports) {
  module.exports = {
    name: 'Selector',
    structure: {
      children: [['TypeSelector', 'IdSelector', 'ClassSelector', 'AttributeSelector', 'PseudoClassSelector', 'PseudoElementSelector', 'Combinator', 'WhiteSpace']]
    },
    parse: function parse() {
      var children = this.readSequence(this.scope.Selector); // nothing were consumed

      if (this.getFirstListNode(children) === null) {
        this.scanner.error('Selector is expected');
      }

      return {
        type: 'Selector',
        loc: this.getLocationFromList(children),
        children: children
      };
    },
    generate: function generate(node) {
      this.children(node);
    }
  };
  /***/
},
/* 129 */

/***/
function (module, exports, __webpack_require__) {
  var TYPE = __webpack_require__(53).TYPE;

  var COMMA = TYPE.Comma;
  module.exports = {
    name: 'SelectorList',
    structure: {
      children: [['Selector', 'Raw']]
    },
    parse: function parse() {
      var children = this.createList();

      while (!this.scanner.eof) {
        children.push(this.Selector());

        if (this.scanner.tokenType === COMMA) {
          this.scanner.next();
          continue;
        }

        break;
      }

      return {
        type: 'SelectorList',
        loc: this.getLocationFromList(children),
        children: children
      };
    },
    generate: function generate(node) {
      this.children(node, function () {
        this.chunk(',');
      });
    },
    walkContext: 'selector'
  };
  /***/
},
/* 130 */

/***/
function (module, exports, __webpack_require__) {
  var STRING = __webpack_require__(53).TYPE.String;

  module.exports = {
    name: 'String',
    structure: {
      value: String
    },
    parse: function parse() {
      return {
        type: 'String',
        loc: this.getLocation(this.scanner.tokenStart, this.scanner.tokenEnd),
        value: this.scanner.consume(STRING)
      };
    },
    generate: function generate(node) {
      this.chunk(node.value);
    }
  };
  /***/
},
/* 131 */

/***/
function (module, exports, __webpack_require__) {
  var TYPE = __webpack_require__(53).TYPE;

  var WHITESPACE = TYPE.WhiteSpace;
  var COMMENT = TYPE.Comment;
  var EXCLAMATIONMARK = TYPE.ExclamationMark;
  var ATKEYWORD = TYPE.AtKeyword;
  var CDO = TYPE.CDO;
  var CDC = TYPE.CDC;

  function consumeRaw(startToken) {
    return this.Raw(startToken, 0, 0, false, false);
  }

  module.exports = {
    name: 'StyleSheet',
    structure: {
      children: [['Comment', 'CDO', 'CDC', 'Atrule', 'Rule', 'Raw']]
    },
    parse: function parse() {
      var start = this.scanner.tokenStart;
      var children = this.createList();
      var child;

      scan: while (!this.scanner.eof) {
        switch (this.scanner.tokenType) {
          case WHITESPACE:
            this.scanner.next();
            continue;

          case COMMENT:
            // ignore comments except exclamation comments (i.e. /*! .. */) on top level
            if (this.scanner.source.charCodeAt(this.scanner.tokenStart + 2) !== EXCLAMATIONMARK) {
              this.scanner.next();
              continue;
            }

            child = this.Comment();
            break;

          case CDO:
            // <!--
            child = this.CDO();
            break;

          case CDC:
            // -->
            child = this.CDC();
            break;
          // CSS Syntax Module Level 3
          // §2.2 Error handling
          // At the "top level" of a stylesheet, an <at-keyword-token> starts an at-rule.

          case ATKEYWORD:
            child = this.parseWithFallback(this.Atrule, consumeRaw);
            break;
          // Anything else starts a qualified rule ...

          default:
            child = this.parseWithFallback(this.Rule, consumeRaw);
        }

        children.push(child);
      }

      return {
        type: 'StyleSheet',
        loc: this.getLocation(start, this.scanner.tokenStart),
        children: children
      };
    },
    generate: function generate(node) {
      this.children(node);
    },
    walkContext: 'stylesheet'
  };
  /***/
},
/* 132 */

/***/
function (module, exports, __webpack_require__) {
  var TYPE = __webpack_require__(53).TYPE;

  var IDENTIFIER = TYPE.Identifier;
  var ASTERISK = TYPE.Asterisk;
  var VERTICALLINE = TYPE.VerticalLine;

  function eatIdentifierOrAsterisk() {
    if (this.scanner.tokenType !== IDENTIFIER && this.scanner.tokenType !== ASTERISK) {
      this.scanner.error('Identifier or asterisk is expected');
    }

    this.scanner.next();
  } // ident
  // ident|ident
  // ident|*
  // *
  // *|ident
  // *|*
  // |ident
  // |*


  module.exports = {
    name: 'TypeSelector',
    structure: {
      name: String
    },
    parse: function parse() {
      var start = this.scanner.tokenStart;

      if (this.scanner.tokenType === VERTICALLINE) {
        this.scanner.next();
        eatIdentifierOrAsterisk.call(this);
      } else {
        eatIdentifierOrAsterisk.call(this);

        if (this.scanner.tokenType === VERTICALLINE) {
          this.scanner.next();
          eatIdentifierOrAsterisk.call(this);
        }
      }

      return {
        type: 'TypeSelector',
        loc: this.getLocation(start, this.scanner.tokenStart),
        name: this.scanner.substrToCursor(start)
      };
    },
    generate: function generate(node) {
      this.chunk(node.name);
    }
  };
  /***/
},
/* 133 */

/***/
function (module, exports, __webpack_require__) {
  var isHex = __webpack_require__(53).isHex;

  var TYPE = __webpack_require__(53).TYPE;

  var IDENTIFIER = TYPE.Identifier;
  var NUMBER = TYPE.Number;
  var PLUSSIGN = TYPE.PlusSign;
  var HYPHENMINUS = TYPE.HyphenMinus;
  var FULLSTOP = TYPE.FullStop;
  var QUESTIONMARK = TYPE.QuestionMark;

  function scanUnicodeNumber(scanner) {
    for (var pos = scanner.tokenStart + 1; pos < scanner.tokenEnd; pos++) {
      var code = scanner.source.charCodeAt(pos); // break on fullstop or hyperminus/plussign after exponent

      if (code === FULLSTOP || code === PLUSSIGN) {
        // break token, exclude symbol
        scanner.tokenStart = pos;
        return false;
      }
    }

    return true;
  } // https://drafts.csswg.org/css-syntax-3/#urange


  function scanUnicodeRange(scanner) {
    var hexStart = scanner.tokenStart + 1; // skip +

    var hexLength = 0;

    scan: {
      if (scanner.tokenType === NUMBER) {
        if (scanner.source.charCodeAt(scanner.tokenStart) !== FULLSTOP && scanUnicodeNumber(scanner)) {
          scanner.next();
        } else if (scanner.source.charCodeAt(scanner.tokenStart) !== HYPHENMINUS) {
          break scan;
        }
      } else {
        scanner.next(); // PLUSSIGN
      }

      if (scanner.tokenType === HYPHENMINUS) {
        scanner.next();
      }

      if (scanner.tokenType === NUMBER) {
        scanner.next();
      }

      if (scanner.tokenType === IDENTIFIER) {
        scanner.next();
      }

      if (scanner.tokenStart === hexStart) {
        scanner.error('Unexpected input', hexStart);
      }
    } // validate for U+x{1,6} or U+x{1,6}-x{1,6}
    // where x is [0-9a-fA-F]


    for (var i = hexStart, wasHyphenMinus = false; i < scanner.tokenStart; i++) {
      var code = scanner.source.charCodeAt(i);

      if (isHex(code) === false && (code !== HYPHENMINUS || wasHyphenMinus)) {
        scanner.error('Unexpected input', i);
      }

      if (code === HYPHENMINUS) {
        // hex sequence shouldn't be an empty
        if (hexLength === 0) {
          scanner.error('Unexpected input', i);
        }

        wasHyphenMinus = true;
        hexLength = 0;
      } else {
        hexLength++; // too long hex sequence

        if (hexLength > 6) {
          scanner.error('Too long hex sequence', i);
        }
      }
    } // check we have a non-zero sequence


    if (hexLength === 0) {
      scanner.error('Unexpected input', i - 1);
    } // U+abc???


    if (!wasHyphenMinus) {
      // consume as many U+003F QUESTION MARK (?) code points as possible
      for (; hexLength < 6 && !scanner.eof; scanner.next()) {
        if (scanner.tokenType !== QUESTIONMARK) {
          break;
        }

        hexLength++;
      }
    }
  }

  module.exports = {
    name: 'UnicodeRange',
    structure: {
      value: String
    },
    parse: function parse() {
      var start = this.scanner.tokenStart;
      this.scanner.next(); // U or u

      scanUnicodeRange(this.scanner);
      return {
        type: 'UnicodeRange',
        loc: this.getLocation(start, this.scanner.tokenStart),
        value: this.scanner.substrToCursor(start)
      };
    },
    generate: function generate(node) {
      this.chunk(node.value);
    }
  };
  /***/
},
/* 134 */

/***/
function (module, exports, __webpack_require__) {
  var TYPE = __webpack_require__(53).TYPE;

  var STRING = TYPE.String;
  var URL = TYPE.Url;
  var RAW = TYPE.Raw;
  var RIGHTPARENTHESIS = TYPE.RightParenthesis; // url '(' S* (string | raw) S* ')'

  module.exports = {
    name: 'Url',
    structure: {
      value: ['String', 'Raw']
    },
    parse: function parse() {
      var start = this.scanner.tokenStart;
      var value;
      this.scanner.eat(URL);
      this.scanner.skipSC();

      switch (this.scanner.tokenType) {
        case STRING:
          value = this.String();
          break;

        case RAW:
          value = this.Raw(this.scanner.currentToken, 0, RAW, true, false);
          break;

        default:
          this.scanner.error('String or Raw is expected');
      }

      this.scanner.skipSC();
      this.scanner.eat(RIGHTPARENTHESIS);
      return {
        type: 'Url',
        loc: this.getLocation(start, this.scanner.tokenStart),
        value: value
      };
    },
    generate: function generate(node) {
      this.chunk('url');
      this.chunk('(');
      this.node(node.value);
      this.chunk(')');
    }
  };
  /***/
},
/* 135 */

/***/
function (module, exports) {
  module.exports = {
    name: 'Value',
    structure: {
      children: [[]]
    },
    parse: function parse() {
      var start = this.scanner.tokenStart;
      var children = this.readSequence(this.scope.Value);
      return {
        type: 'Value',
        loc: this.getLocation(start, this.scanner.tokenStart),
        children: children
      };
    },
    generate: function generate(node) {
      this.children(node);
    }
  };
  /***/
},
/* 136 */

/***/
function (module, exports, __webpack_require__) {
  var WHITESPACE = __webpack_require__(53).TYPE.WhiteSpace;

  var SPACE = Object.freeze({
    type: 'WhiteSpace',
    loc: null,
    value: ' '
  });
  module.exports = {
    name: 'WhiteSpace',
    structure: {
      value: String
    },
    parse: function parse() {
      this.scanner.eat(WHITESPACE);
      return SPACE; // return {
      //     type: 'WhiteSpace',
      //     loc: this.getLocation(this.scanner.tokenStart, this.scanner.tokenEnd),
      //     value: this.scanner.consume(WHITESPACE)
      // };
    },
    generate: function generate(node) {
      this.chunk(node.value);
    }
  };
  /***/
},
/* 137 */

/***/
function (module, exports, __webpack_require__) {
  module.exports = {
    parseContext: {
      "default": 'StyleSheet',
      stylesheet: 'StyleSheet',
      atrule: 'Atrule',
      atrulePrelude: function atrulePrelude(options) {
        return this.AtrulePrelude(options.atrule ? String(options.atrule) : null);
      },
      mediaQueryList: 'MediaQueryList',
      mediaQuery: 'MediaQuery',
      rule: 'Rule',
      selectorList: 'SelectorList',
      selector: 'Selector',
      block: function block() {
        return this.Block(true);
      },
      declarationList: 'DeclarationList',
      declaration: 'Declaration',
      value: 'Value'
    },
    scope: __webpack_require__(138),
    atrule: __webpack_require__(146),
    pseudo: __webpack_require__(152),
    node: __webpack_require__(96)
  };
  /***/
},
/* 138 */

/***/
function (module, exports, __webpack_require__) {
  module.exports = {
    AtrulePrelude: __webpack_require__(139),
    Selector: __webpack_require__(141),
    Value: __webpack_require__(142)
  };
  /***/
},
/* 139 */

/***/
function (module, exports, __webpack_require__) {
  module.exports = {
    getNode: __webpack_require__(140)
  };
  /***/
},
/* 140 */

/***/
function (module, exports, __webpack_require__) {
  var cmpChar = __webpack_require__(53).cmpChar;

  var TYPE = __webpack_require__(53).TYPE;

  var IDENTIFIER = TYPE.Identifier;
  var STRING = TYPE.String;
  var NUMBER = TYPE.Number;
  var FUNCTION = TYPE.Function;
  var URL = TYPE.Url;
  var NUMBERSIGN = TYPE.NumberSign;
  var LEFTPARENTHESIS = TYPE.LeftParenthesis;
  var LEFTSQUAREBRACKET = TYPE.LeftSquareBracket;
  var PLUSSIGN = TYPE.PlusSign;
  var HYPHENMINUS = TYPE.HyphenMinus;
  var COMMA = TYPE.Comma;
  var SOLIDUS = TYPE.Solidus;
  var ASTERISK = TYPE.Asterisk;
  var PERCENTSIGN = TYPE.PercentSign;
  var BACKSLASH = TYPE.Backslash;
  var U = 117; // 'u'.charCodeAt(0)

  module.exports = function defaultRecognizer(context) {
    switch (this.scanner.tokenType) {
      case NUMBERSIGN:
        return this.HexColor();

      case COMMA:
        context.space = null;
        context.ignoreWSAfter = true;
        return this.Operator();

      case SOLIDUS:
      case ASTERISK:
      case PLUSSIGN:
      case HYPHENMINUS:
        return this.Operator();

      case LEFTPARENTHESIS:
        return this.Parentheses(this.readSequence, context.recognizer);

      case LEFTSQUAREBRACKET:
        return this.Brackets(this.readSequence, context.recognizer);

      case STRING:
        return this.String();

      case NUMBER:
        switch (this.scanner.lookupType(1)) {
          case PERCENTSIGN:
            return this.Percentage();

          case IDENTIFIER:
            // edge case: number with folowing \0 and \9 hack shouldn't to be a Dimension
            if (cmpChar(this.scanner.source, this.scanner.tokenEnd, BACKSLASH)) {
              return this.Number();
            } else {
              return this.Dimension();
            }

          default:
            return this.Number();
        }

      case FUNCTION:
        return this.Function(this.readSequence, context.recognizer);

      case URL:
        return this.Url();

      case IDENTIFIER:
        // check for unicode range, it should start with u+ or U+
        if (cmpChar(this.scanner.source, this.scanner.tokenStart, U) && cmpChar(this.scanner.source, this.scanner.tokenStart + 1, PLUSSIGN)) {
          return this.UnicodeRange();
        } else {
          return this.Identifier();
        }

    }
  };
  /***/

},
/* 141 */

/***/
function (module, exports, __webpack_require__) {
  var TYPE = __webpack_require__(53).TYPE;

  var IDENTIFIER = TYPE.Identifier;
  var NUMBER = TYPE.Number;
  var NUMBERSIGN = TYPE.NumberSign;
  var LEFTSQUAREBRACKET = TYPE.LeftSquareBracket;
  var PLUSSIGN = TYPE.PlusSign;
  var SOLIDUS = TYPE.Solidus;
  var ASTERISK = TYPE.Asterisk;
  var FULLSTOP = TYPE.FullStop;
  var COLON = TYPE.Colon;
  var GREATERTHANSIGN = TYPE.GreaterThanSign;
  var VERTICALLINE = TYPE.VerticalLine;
  var TILDE = TYPE.Tilde;

  function getNode(context) {
    switch (this.scanner.tokenType) {
      case PLUSSIGN:
      case GREATERTHANSIGN:
      case TILDE:
        context.space = null;
        context.ignoreWSAfter = true;
        return this.Combinator();

      case SOLIDUS:
        // /deep/
        return this.Combinator();

      case FULLSTOP:
        return this.ClassSelector();

      case LEFTSQUAREBRACKET:
        return this.AttributeSelector();

      case NUMBERSIGN:
        return this.IdSelector();

      case COLON:
        if (this.scanner.lookupType(1) === COLON) {
          return this.PseudoElementSelector();
        } else {
          return this.PseudoClassSelector();
        }

      case IDENTIFIER:
      case ASTERISK:
      case VERTICALLINE:
        return this.TypeSelector();

      case NUMBER:
        return this.Percentage();
    }
  }

  ;
  module.exports = {
    getNode: getNode
  };
  /***/
},
/* 142 */

/***/
function (module, exports, __webpack_require__) {
  module.exports = {
    getNode: __webpack_require__(140),
    '-moz-element': __webpack_require__(143),
    'element': __webpack_require__(143),
    'expression': __webpack_require__(144),
    'var': __webpack_require__(145)
  };
  /***/
},
/* 143 */

/***/
function (module, exports) {
  // https://drafts.csswg.org/css-images-4/#element-notation
  // https://developer.mozilla.org/en-US/docs/Web/CSS/element
  module.exports = function () {
    this.scanner.skipSC();
    var children = this.createSingleNodeList(this.IdSelector());
    this.scanner.skipSC();
    return children;
  };
  /***/

},
/* 144 */

/***/
function (module, exports) {
  // legacy IE function
  // expression '(' raw ')'
  module.exports = function () {
    return this.createSingleNodeList(this.Raw(this.scanner.currentToken, 0, 0, false, false));
  };
  /***/

},
/* 145 */

/***/
function (module, exports, __webpack_require__) {
  var TYPE = __webpack_require__(53).TYPE;

  var IDENTIFIER = TYPE.Identifier;
  var COMMA = TYPE.Comma;
  var SEMICOLON = TYPE.Semicolon;
  var HYPHENMINUS = TYPE.HyphenMinus;
  var EXCLAMATIONMARK = TYPE.ExclamationMark; // var '(' ident (',' <value>? )? ')'

  module.exports = function () {
    var children = this.createList();
    this.scanner.skipSC();
    var identStart = this.scanner.tokenStart;
    this.scanner.eat(HYPHENMINUS);

    if (this.scanner.source.charCodeAt(this.scanner.tokenStart) !== HYPHENMINUS) {
      this.scanner.error('HyphenMinus is expected');
    }

    this.scanner.eat(IDENTIFIER);
    children.push({
      type: 'Identifier',
      loc: this.getLocation(identStart, this.scanner.tokenStart),
      name: this.scanner.substrToCursor(identStart)
    });
    this.scanner.skipSC();

    if (this.scanner.tokenType === COMMA) {
      children.push(this.Operator());
      children.push(this.parseCustomProperty ? this.Value(null) : this.Raw(this.scanner.currentToken, EXCLAMATIONMARK, SEMICOLON, false, false));
    }

    return children;
  };
  /***/

},
/* 146 */

/***/
function (module, exports, __webpack_require__) {
  module.exports = {
    'font-face': __webpack_require__(147),
    'import': __webpack_require__(148),
    'media': __webpack_require__(149),
    'page': __webpack_require__(150),
    'supports': __webpack_require__(151)
  };
  /***/
},
/* 147 */

/***/
function (module, exports) {
  module.exports = {
    parse: {
      prelude: null,
      block: function block() {
        return this.Block(true);
      }
    }
  };
  /***/
},
/* 148 */

/***/
function (module, exports, __webpack_require__) {
  var TYPE = __webpack_require__(53).TYPE;

  var STRING = TYPE.String;
  var IDENTIFIER = TYPE.Identifier;
  var URL = TYPE.Url;
  var LEFTPARENTHESIS = TYPE.LeftParenthesis;
  module.exports = {
    parse: {
      prelude: function prelude() {
        var children = this.createList();
        this.scanner.skipSC();

        switch (this.scanner.tokenType) {
          case STRING:
            children.push(this.String());
            break;

          case URL:
            children.push(this.Url());
            break;

          default:
            this.scanner.error('String or url() is expected');
        }

        if (this.scanner.lookupNonWSType(0) === IDENTIFIER || this.scanner.lookupNonWSType(0) === LEFTPARENTHESIS) {
          children.push(this.WhiteSpace());
          children.push(this.MediaQueryList());
        }

        return children;
      },
      block: null
    }
  };
  /***/
},
/* 149 */

/***/
function (module, exports) {
  module.exports = {
    parse: {
      prelude: function prelude() {
        return this.createSingleNodeList(this.MediaQueryList());
      },
      block: function block() {
        return this.Block(false);
      }
    }
  };
  /***/
},
/* 150 */

/***/
function (module, exports) {
  module.exports = {
    parse: {
      prelude: function prelude() {
        return this.createSingleNodeList(this.SelectorList());
      },
      block: function block() {
        return this.Block(true);
      }
    }
  };
  /***/
},
/* 151 */

/***/
function (module, exports, __webpack_require__) {
  var TYPE = __webpack_require__(53).TYPE;

  var WHITESPACE = TYPE.WhiteSpace;
  var COMMENT = TYPE.Comment;
  var IDENTIFIER = TYPE.Identifier;
  var FUNCTION = TYPE.Function;
  var LEFTPARENTHESIS = TYPE.LeftParenthesis;
  var HYPHENMINUS = TYPE.HyphenMinus;
  var COLON = TYPE.Colon;

  function consumeRaw() {
    return this.createSingleNodeList(this.Raw(this.scanner.currentToken, 0, 0, false, false));
  }

  function parentheses() {
    var index = 0;
    this.scanner.skipSC(); // TODO: make it simplier

    if (this.scanner.tokenType === IDENTIFIER) {
      index = 1;
    } else if (this.scanner.tokenType === HYPHENMINUS && this.scanner.lookupType(1) === IDENTIFIER) {
      index = 2;
    }

    if (index !== 0 && this.scanner.lookupNonWSType(index) === COLON) {
      return this.createSingleNodeList(this.Declaration());
    }

    return readSequence.call(this);
  }

  function readSequence() {
    var children = this.createList();
    var space = null;
    var child;
    this.scanner.skipSC();

    scan: while (!this.scanner.eof) {
      switch (this.scanner.tokenType) {
        case WHITESPACE:
          space = this.WhiteSpace();
          continue;

        case COMMENT:
          this.scanner.next();
          continue;

        case FUNCTION:
          child = this.Function(consumeRaw, this.scope.AtrulePrelude);
          break;

        case IDENTIFIER:
          child = this.Identifier();
          break;

        case LEFTPARENTHESIS:
          child = this.Parentheses(parentheses, this.scope.AtrulePrelude);
          break;

        default:
          break scan;
      }

      if (space !== null) {
        children.push(space);
        space = null;
      }

      children.push(child);
    }

    return children;
  }

  module.exports = {
    parse: {
      prelude: function prelude() {
        var children = readSequence.call(this);

        if (this.getFirstListNode(children) === null) {
          this.scanner.error('Condition is expected');
        }

        return children;
      },
      block: function block() {
        return this.Block(false);
      }
    }
  };
  /***/
},
/* 152 */

/***/
function (module, exports, __webpack_require__) {
  module.exports = {
    'dir': __webpack_require__(153),
    'has': __webpack_require__(154),
    'lang': __webpack_require__(155),
    'matches': __webpack_require__(156),
    'not': __webpack_require__(158),
    'nth-child': __webpack_require__(159),
    'nth-last-child': __webpack_require__(161),
    'nth-last-of-type': __webpack_require__(162),
    'nth-of-type': __webpack_require__(164),
    'slotted': __webpack_require__(165)
  };
  /***/
},
/* 153 */

/***/
function (module, exports) {
  module.exports = {
    parse: function parse() {
      return this.createSingleNodeList(this.Identifier());
    }
  };
  /***/
},
/* 154 */

/***/
function (module, exports) {
  module.exports = {
    parse: function parse() {
      return this.createSingleNodeList(this.SelectorList());
    }
  };
  /***/
},
/* 155 */

/***/
function (module, exports) {
  module.exports = {
    parse: function parse() {
      return this.createSingleNodeList(this.Identifier());
    }
  };
  /***/
},
/* 156 */

/***/
function (module, exports, __webpack_require__) {
  module.exports = __webpack_require__(157);
  /***/
},
/* 157 */

/***/
function (module, exports) {
  module.exports = {
    parse: function selectorList() {
      return this.createSingleNodeList(this.SelectorList());
    }
  };
  /***/
},
/* 158 */

/***/
function (module, exports, __webpack_require__) {
  module.exports = __webpack_require__(157);
  /***/
},
/* 159 */

/***/
function (module, exports, __webpack_require__) {
  module.exports = __webpack_require__(160);
  /***/
},
/* 160 */

/***/
function (module, exports) {
  var ALLOW_OF_CLAUSE = true;
  module.exports = {
    parse: function nthWithOfClause() {
      return this.createSingleNodeList(this.Nth(ALLOW_OF_CLAUSE));
    }
  };
  /***/
},
/* 161 */

/***/
function (module, exports, __webpack_require__) {
  module.exports = __webpack_require__(160);
  /***/
},
/* 162 */

/***/
function (module, exports, __webpack_require__) {
  module.exports = __webpack_require__(163);
  /***/
},
/* 163 */

/***/
function (module, exports) {
  var DISALLOW_OF_CLAUSE = false;
  module.exports = {
    parse: function nth() {
      return this.createSingleNodeList(this.Nth(DISALLOW_OF_CLAUSE));
    }
  };
  /***/
},
/* 164 */

/***/
function (module, exports, __webpack_require__) {
  module.exports = __webpack_require__(163);
  /***/
},
/* 165 */

/***/
function (module, exports) {
  module.exports = {
    parse: function compoundSelector() {
      return this.createSingleNodeList(this.Selector());
    }
  };
  /***/
},
/* 166 */

/***/
function (module, exports, __webpack_require__) {
  module.exports = {
    node: __webpack_require__(96)
  };
  /***/
},
/* 167 */

/***/
function (module, __webpack_exports__, __webpack_require__) {
  ;

  __webpack_require__.r(__webpack_exports__);
  /* harmony export (binding) */


  __webpack_require__.d(__webpack_exports__, "Flare", function () {
    return Flare;
  });
  /* harmony export (binding) */


  __webpack_require__.d(__webpack_exports__, "css", function () {
    return css;
  });
  /* harmony import */


  var _Utilities_helpers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(4);
  /* harmony import */


  var _Utilities_Is__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(6);
  /* harmony import */


  var _Component__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(40);
  /* harmony import */


  var _Form_Node__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(35);
  /* harmony import */


  var _Props_Props__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(38);
  /* harmony import */


  var _Events__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(37);
  /* harmony import */


  var _CSS__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(43);
  /* harmony import */


  var _Utilities_murmurHash__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(47);
  /* harmony import */


  var _Utilities_alphaStringFromHash__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(46);
  /* harmony import */


  var _Elements_Area__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(168);
  /* harmony import */


  var _Elements_Aside__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(169);
  /* harmony import */


  var _Elements_Button__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(170);
  /* harmony import */


  var _Elements_Col__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(171);
  /* harmony import */


  var _Elements_Colgroup__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(172);
  /* harmony import */


  var _Elements_Footer__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(173);
  /* harmony import */


  var _Elements_H1__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(174);
  /* harmony import */


  var _Elements_H2__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(175);
  /* harmony import */


  var _Elements_H3__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(176);
  /* harmony import */


  var _Elements_H4__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(177);
  /* harmony import */


  var _Elements_H5__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(178);
  /* harmony import */


  var _Elements_H6__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(179);
  /* harmony import */


  var _Elements_Header__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(180);
  /* harmony import */


  var _Elements_Input__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(181);
  /* harmony import */


  var _Elements_Paragraph__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(182);
  /* harmony import */


  var _Elements_Section__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(183);
  /* harmony import */


  var _Elements_Span__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(184);
  /* harmony import */


  var _Elements_Table__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(185);
  /* harmony import */


  var _Elements_Textarea__WEBPACK_IMPORTED_MODULE_27__ = __webpack_require__(186);

  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  function _defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    return Constructor;
  }

  function _defineProperty(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }

    return obj;
  }
  /*
  ** Flare.js
  **
  ** Flare.js is essentially a styled-components clone in the way that
  ** Valence.js is a React.js clone. Flare simply provides a way to use
  ** the styled-components style api with Valence.js... It is very simple at
  ** this time and by no means encompasses all that styled-components
  ** has to offer.
  **
  ** Eric James Foster, Fostware LLC, MIT License.
  ***/

  /* TODO's **********************************
  
  ** TODO-MACRO Flare Features to incorporate
  ********************************************/
  //TODO:[X] Ability to extend all element types.. 1
  //TODO:[X] Ability to extend a component.. 2
  //TODO:[X] Stylis integration.. 4
  //TODO:[X] Ability to Inject global styles.. 5
  //TODO:[X] Keyframe Animations.. 7
  //TODO:[X] Variables, functions (tagged template literals).. 3
  //TODO:[X] Media Queries.. 6
  //TODO:[ ] Incorporate SVG.. 8

  /*
  ** TODO-MICRO Flare work to complete
  ********************************************/
  //TODO:[X] Finish work on all element component classes...
  //TODO:[ ] Move from static class structure to singleton structure...
  //TODO:[ ]

  /*
  ** TODO-RELATED spin-off projects to do....
  ********************************************/
  //TODO:[ ] Replicator library...
  //TODO:[ ] DeeplicateObject library...
  //TODO:[ ] stylisDirectChild middleware plugin
  // Grab utilities...
  // Get value validation...
  // Get Component Class...
  // Get Node and Props classes...
  // Get Events....
  // import CSS class...
  // Get unique identity creating functions...

  /* Flare Styling related libraries......*/
  // import our extensible element constructors...
  // Globalize common helpers..


  var dir = console.dir;
  var log = _Utilities_helpers__WEBPACK_IMPORTED_MODULE_0__["log"]; // Valence class dealing with JS context, css styling of components...

  var Flare =
  /*#__PURE__*/
  function () {
    function Flare() {
      _classCallCheck(this, Flare);
    }

    _createClass(Flare, null, [{
      key: "assume",
      // A public helper method for setting Flare assumptions, config options...
      value: function assume(userAssumptions) {
        this._assumptions = _CSS__WEBPACK_IMPORTED_MODULE_6__["CSS"].assume(_Utilities_helpers__WEBPACK_IMPORTED_MODULE_0__["combineObjects"](this._assumptions, userAssumptions));
        return this._assumptions;
      } // Static member to hold element tag name to be created...

    }, {
      key: "_createFlareId",
      // An internal static method for first, creating a 10 digit hash from a string of
      // css, then a 7 digit alphabetical string from the hash....
      value: function _createFlareId(array) {
        // Create string from template array...
        var string = array[0].join('').replace(/\s|\n/g, ''); // Create and return unique id...

        return Object(_Utilities_alphaStringFromHash__WEBPACK_IMPORTED_MODULE_8__["default"])(Object(_Utilities_murmurHash__WEBPACK_IMPORTED_MODULE_7__["default"])(string));
      } // A publick method for processing a tagged template literal with stylis...

    }, {
      key: "css",
      value: function css() {
        for (var _len = arguments.length, tempLit = new Array(_len), _key = 0; _key < _len; _key++) {
          tempLit[_key] = arguments[_key];
        }

        if (tempLit[0][0].indexOf('{') < 5) {
          return _CSS__WEBPACK_IMPORTED_MODULE_6__["CSS"].processStyles(tempLit, ':host');
        }

        return _CSS__WEBPACK_IMPORTED_MODULE_6__["CSS"].processStyles(tempLit, '');
      } // A helper method for accessing the Flare class and defining it's components...

    }, {
      key: "createComponent",
      value: function createComponent(comTag, elTag, tagTempLit) {
        var props = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {}; // log(`Tag name is: ${comTag}`, ['orange', 'white']);dir(props)
        // Determine whether or not the component will utilize shadow dom by default...

        if (!Reflect.has(props, 'shadow')) {
          // If 'shadow' is not set in props, and if 'shadow' is 'on' by default...
          if (this.options.shadowByDefault) {
            // Set the 'shadow' prop to true...
            props.shadow = true;
          } else {
            // Otherwise, set it to false..
            props.shadow = false;
          }
        }

        _CSS__WEBPACK_IMPORTED_MODULE_6__["CSS"]._superProps[props.flareId] = [comTag, props]; // If a flare component does not use shadow dom...

        if (!props.shadow) {
          // it will not need to append anything to it's shadow root later on...
          props.noChild = true; // Define component and add Styles..

          this._define(comTag, props, elTag);

          _CSS__WEBPACK_IMPORTED_MODULE_6__["CSS"].addStyles(true, comTag, elTag, props, tagTempLit);
        } else {
          // Define component and add Styles..
          this._define(comTag, props, elTag, _CSS__WEBPACK_IMPORTED_MODULE_6__["CSS"].addStyles(false, comTag, elTag, props, tagTempLit));
        }
      } // DEPRECATED: NOT CURRENTLY IN USE

    }, {
      key: "_resetFlags",
      value: function _resetFlags() {
        // Reset these, they were flipped for Component definition, and would typically
        // be reset in the flow of component creation just after the call to doc.createEl(),
        // but when creating components with Flare, element instantiation is delayed...
        window.useNativeShim = true;
        window.HTMLElement = window.HTMLElement_;
      } // Static method used for defining Flare components...

    }, {
      key: "_define",
      value: function _define(name) {
        var props = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        var el = arguments.length > 2 ? arguments[2] : undefined;
        var template = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false; //log('Looka Here', ['white', 'red']);log(`name is: ${name}`);log(`el is: ${el}`);dir(props)
        // Declare element constructior var..

        var elemCtor,
            // Create function will create the component element definition..
        create = function create() {
          // Pulling a switch here, so that we can choose what type of constructor we'd
          // like to use for our component...
          switch (el) {
            case 'area':
              // Grab the extensible area element constructor..
              elemCtor = _Elements_Area__WEBPACK_IMPORTED_MODULE_9__["Area"].createComponent(props, template);
              break;

            case 'aside':
              // Grab the extensible aside element constructor..
              elemCtor = _Elements_Aside__WEBPACK_IMPORTED_MODULE_10__["Aside"].createComponent(props, template);
              break;

            case 'button':
              // Grab the extensible input element constructor..
              elemCtor = _Elements_Button__WEBPACK_IMPORTED_MODULE_11__["Button"].createComponent(props, template);
              break;

            case 'col':
              // Grab the extensible col element constructor..
              elemCtor = _Elements_Col__WEBPACK_IMPORTED_MODULE_12__["Col"].createComponent(props, template);
              break;

            case 'colgroup':
              // Grab the extensible colgroup element constructor..
              elemCtor = _Elements_Colgroup__WEBPACK_IMPORTED_MODULE_13__["Colgroup"].createComponent(props, template);
              break;

            case 'div':
              // Do CreateComponent..
              elemCtor = _Component__WEBPACK_IMPORTED_MODULE_2__["default"].createComponent([name, template, el], props);
              break;

            case 'footer':
              // Grab the extensible footer element constructor..
              elemCtor = _Elements_Footer__WEBPACK_IMPORTED_MODULE_14__["Footer"].createComponent(props, template);
              break;

            case 'h1':
              // Grab the extensible h1 element constructor..
              elemCtor = _Elements_H1__WEBPACK_IMPORTED_MODULE_15__["H1"].createComponent(props, template);
              break;

            case 'h2':
              // Grab the extensible h2 element constructor..
              elemCtor = _Elements_H2__WEBPACK_IMPORTED_MODULE_16__["H2"].createComponent(props, template);
              break;

            case 'h3':
              // Grab the extensible h3 element constructor..
              elemCtor = _Elements_H3__WEBPACK_IMPORTED_MODULE_17__["H3"].createComponent(props, template);
              break;

            case 'h4':
              // Grab the extensible h4 element constructor..
              elemCtor = _Elements_H4__WEBPACK_IMPORTED_MODULE_18__["H4"].createComponent(props, template);
              break;

            case 'h5':
              // Grab the extensible h5 element constructor..
              elemCtor = _Elements_H5__WEBPACK_IMPORTED_MODULE_19__["H5"].createComponent(props, template);
              break;

            case 'h6':
              // Grab the extensible h6 element constructor..
              elemCtor = _Elements_H6__WEBPACK_IMPORTED_MODULE_20__["H6"].createComponent(props, template);
              break;

            case 'header':
              // Grab the extensible header element constructor..
              elemCtor = _Elements_Header__WEBPACK_IMPORTED_MODULE_21__["Header"].createComponent(props, template);
              break;

            case 'input':
              // Grab the extensible input element constructor..
              elemCtor = _Elements_Input__WEBPACK_IMPORTED_MODULE_22__["Input"].createComponent(props, template);
              break;

            case 'p':
              // Grab the extensible p element constructor..
              elemCtor = _Elements_Paragraph__WEBPACK_IMPORTED_MODULE_23__["Paragraph"].createComponent(props, template);
              break;

            case 'section':
              // Grab the extensible section element constructor..
              elemCtor = _Elements_Section__WEBPACK_IMPORTED_MODULE_24__["Section"].createComponent(props, template);
              break;

            case 'span':
              // Grab the extensible span element constructor..
              elemCtor = _Elements_Span__WEBPACK_IMPORTED_MODULE_25__["Span"].createComponent(props, template);
              break;

            case 'table':
              // Grab the extensible table element constructor..
              elemCtor = _Elements_Table__WEBPACK_IMPORTED_MODULE_26__["Table"].createComponent(props, template);
              break;

            case 'textarea':
              // Grab the extensible textarea element constructor..
              elemCtor = _Elements_Textarea__WEBPACK_IMPORTED_MODULE_27__["Textarea"].createComponent(props, template);
              break;

            case 'default':
              break;
          } // Process props...


          var processed = _Form_Node__WEBPACK_IMPORTED_MODULE_3__["Node"].processNodeProps(props, elemCtor); // Add flareComponent property to flare component constructor...


          processed.ctor.prototype.flareComponent = true; // Define component...

          window.customElements.define(name, processed.ctor); // Reset nativeShim flags..
          // Flare._resetFlags()
          // Listen for element instantiation, grab element...

          _Events__WEBPACK_IMPORTED_MODULE_5__["Events"].listen(name, function (e) {
            // Set props on new element..
            _Props_Props__WEBPACK_IMPORTED_MODULE_4__["Props"].set(e.detail.element, props); // props = {}

          });
        }; // Add isStatelessComponent flag to props for Component...


        props.isStatelessComponent = true; // Do CreateComponent..

        create();
      } // A static public method for instantiating a keyframes instance for css animation...

    }, {
      key: "keyframes",
      value: function keyframes() {
        var obj = {};

        for (var _len2 = arguments.length, tempLit = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
          tempLit[_key2] = arguments[_key2];
        }

        obj.array = [].concat(tempLit);
        obj.extended = false; // Send the ttLiteral object over to CSS for processing and inserting into the stylesheet...

        return _CSS__WEBPACK_IMPORTED_MODULE_6__["CSS"].keyframes(obj);
      } //A static public method for inserting global rules into the styleSheet...

    }, {
      key: "global",
      value: function global() {
        var obj = {};

        for (var _len3 = arguments.length, tempLit = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
          tempLit[_key3] = arguments[_key3];
        }

        obj.array = [].concat(tempLit);
        obj.extended = false; // Send the ttLiteral object over to CSS for processing and inserting into the stylesheet...

        _CSS__WEBPACK_IMPORTED_MODULE_6__["CSS"].insertGlobal(obj);
      } // An internal method used for retrieving a css template literal..

    }, {
      key: "_getTemplateLiteral",
      value: function _getTemplateLiteral() {
        for (var _len4 = arguments.length, tempLit = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
          tempLit[_key4] = arguments[_key4];
        }

        var tmpl,
            // Store ref functions with tempLit in an array
        array = [].concat(tempLit),
            props = Flare._propObj; // Set a unique id on the component's props...

        props.flareId = "".concat(Flare._createFlareId(array)); //

        if (Flare._extend) {
          /* An object holding the styles of the extended component, and also,
          an array holding the broken up tempLit and ref functions... Once the Props
          from component instantiation are merged with the existing prop object, the
          resulting object will be injected into each ref function as they are called  so that
          the css can be completed...*/
          tmpl = {
            extended: true,
            "super": Flare._superTempLit,
            superEl: Flare._superTag,
            superId: Flare._superId,
            array: array
          };
        } else {
          tmpl = {
            extended: false,
            array: array
          };
        }

        return {
          flare: true,
          taggedTempLit: tmpl,
          props: props,
          el: tmpl.extended ? Flare._superTag : Flare._elementTag,
          tag: Flare._componentTag
        };
      } // Component extend Static API Method
      // A public method for extending user-defined flare components...

    }, {
      key: "extend",
      value: function (_extend) {
        function extend(_x) {
          return _extend.apply(this, arguments);
        }

        extend.toString = function () {
          return _extend.toString();
        };

        return extend;
      }(function (component) {
        var attrs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false; // Get tagName...

        var tagName = _Utilities_helpers__WEBPACK_IMPORTED_MODULE_0__["convertFuncNameToTagName"](extend.caller.name); // Get a copy of the component so that we don't delete any of the extended component's attrs...


        var superComponent = _Utilities_helpers__WEBPACK_IMPORTED_MODULE_0__["deeplicateObj"](component(valenceGlobals.flareComponents[component({}).tag])); // Filter component arg's props for id and classname properties, which can
        // not, obviously, be shared with other elements/components...


        if ('id' in superComponent.props) {
          delete superComponent.props.id;
        }

        if ('className' in superComponent.props) {
          delete superComponent.props.className;
        } // If arg is an object...


        if (attrs) {
          // Let's first combine prop objects so as to override any common props...
          var props = _Utilities_helpers__WEBPACK_IMPORTED_MODULE_0__["combineObjects"](superComponent.props, attrs); // Set the Flare component indicator...


          props.Flare = true; // Set stateless-component flag for the component..

          props.isStatelessComponent = true; // Pass the prop object, and element tag name  on to the global members..

          Flare._propObj = props;
        } // Set a unique id on the component's props...


        Flare._elementTag = "X".concat(superComponent.el);
        Flare._componentTag = tagName;
        Flare._superId = superComponent.props.flareId;
        Flare._superTag = superComponent.el;
        Flare._superTempLit = superComponent.taggedTempLit.array;
        Flare._extend = true; // Get css..

        return Flare._getTemplateLiteral;
      }) // Div Static API Method

    }, {
      key: "div",
      value: function (_div) {
        function div() {
          return _div.apply(this, arguments);
        }

        div.toString = function () {
          return _div.toString();
        };

        return div;
      }(function () {
        // Get tagName...
        var tagName = _Utilities_helpers__WEBPACK_IMPORTED_MODULE_0__["convertFuncNameToTagName"](div.caller.name); //log('TAGNAME', ['green', 'bold']);log(tagName)
        // If the argument is not an array, it's probably our props object...


        for (var _len5 = arguments.length, arg = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
          arg[_key5] = arguments[_key5];
        }

        if (!_Utilities_Is__WEBPACK_IMPORTED_MODULE_1__["Is"].array(arg[0])) {
          var props = arg[0]; // Set the Flare component indicator...

          props.Flare = true; // Set stateless-component flag for the component..

          props.isStatelessComponent = true; // Pass the prop object, and element tag name  on to the global members..

          Flare._propObj = props;
          Flare._elementTag = 'div';
          Flare._componentTag = tagName; // Define component..

          return Flare._getTemplateLiteral;
        } else {
          var array = [].concat(arg),
              _privateProps = {}; //

          _privateProps.Flare = true;
          _privateProps.isStatelessComponent = true;
          _privateProps.flareId = "".concat(Flare._createFlareId(array));
          return {
            flare: true,
            taggedTempLit: {
              extended: false,
              array: array
            },
            props: _privateProps,
            el: 'div',
            tag: tagName
          };
        }
      })
      /**********************************************************
      ***********************************************************
      ************* Flare Component Elements ********************
      ***********************************************************
      **********************************************************/
      // Input Static API Method

    }, {
      key: "input",
      value: function (_input) {
        function input() {
          return _input.apply(this, arguments);
        }

        input.toString = function () {
          return _input.toString();
        };

        return input;
      }(function () {
        // Get tagName...
        var tagName = _Utilities_helpers__WEBPACK_IMPORTED_MODULE_0__["convertFuncNameToTagName"](input.caller.name); //log('TAGNAME', ['green', 'bold']);log(tagName)
        // If the argument is not an array, it's probably our props object...


        for (var _len6 = arguments.length, arg = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {
          arg[_key6] = arguments[_key6];
        }

        if (!_Utilities_Is__WEBPACK_IMPORTED_MODULE_1__["Is"].array(arg[0])) {
          var props = arg[0]; // Set the Flare component indicator...

          props.Flare = true; // Set stateless-component flag for the component..

          props.isStatelessComponent = true; // Pass the prop object, and element tag name  on to the global members..

          Flare._propObj = props;
          Flare._elementTag = 'input';
          Flare._componentTag = tagName; // Define component..

          return Flare._getTemplateLiteral;
        } else {
          var array = [].concat(arg),
              _privateProps = {}; // Add some properties to the private props object....

          _privateProps.Flare = true;
          _privateProps.isStatelessComponent = true;
          _privateProps.flareId = "".concat(Flare._createFlareId(array)); // Add private props to return object and... return..

          return {
            flare: true,
            taggedTempLit: {
              extended: false,
              array: array
            },
            props: _privateProps,
            el: 'input',
            tag: tagName
          };
        }
      }) // Button Static API Method

    }, {
      key: "button",
      value: function (_button) {
        function button() {
          return _button.apply(this, arguments);
        }

        button.toString = function () {
          return _button.toString();
        };

        return button;
      }(function () {
        // Get tagName...
        var tagName = _Utilities_helpers__WEBPACK_IMPORTED_MODULE_0__["convertFuncNameToTagName"](button.caller.name); // log('TAGNAME', ['green', 'bold'])
        //  log(tagName)


        for (var _len7 = arguments.length, arg = new Array(_len7), _key7 = 0; _key7 < _len7; _key7++) {
          arg[_key7] = arguments[_key7];
        }

        var args = [].concat(arg); // If the argument is not an array, it's probably our props object...

        if (!_Utilities_Is__WEBPACK_IMPORTED_MODULE_1__["Is"].array(arg[0])) {
          var props = arg[0]; // Set the Flare component indicator...

          props.Flare = true; // Set stateless-component flag for the component..

          props.isStatelessComponent = true; // Pass the prop object, and element tag name  on to the global members..

          Flare._propObj = props;
          Flare._elementTag = 'button';
          Flare._componentTag = tagName; // Define component..

          return Flare._getTemplateLiteral;
        } else {
          var array = [].concat(arg),
              _privateProps = {}; // Add some properties to the private props object....

          _privateProps.Flare = true;
          _privateProps.isStatelessComponent = true;
          _privateProps.flareId = "".concat(Flare._createFlareId(array)); // Add private props to return object and... return..

          return {
            flare: true,
            taggedTempLit: {
              extended: false,
              array: array
            },
            props: _privateProps,
            el: 'button',
            tag: tagName
          };
        }
      }) // P API Method

    }, {
      key: "p",
      value: function (_p) {
        function p() {
          return _p.apply(this, arguments);
        }

        p.toString = function () {
          return _p.toString();
        };

        return p;
      }(function () {
        // Get tagName...
        var tagName = _Utilities_helpers__WEBPACK_IMPORTED_MODULE_0__["convertFuncNameToTagName"](p.caller.name); // log('TAGNAME', ['green', 'bold'])
        //  log(tagName)
        // If the argument is not an array, it's probably our props object...


        for (var _len8 = arguments.length, arg = new Array(_len8), _key8 = 0; _key8 < _len8; _key8++) {
          arg[_key8] = arguments[_key8];
        }

        if (!_Utilities_Is__WEBPACK_IMPORTED_MODULE_1__["Is"].array(arg[0])) {
          var props = arg[0]; // Set the Flare component indicator...

          props.Flare = true; // Set stateless-component flag for the component..

          props.isStatelessComponent = true; // Pass the prop object, and element tag name  on to the global members..

          Flare._propObj = props;
          Flare._elementTag = 'p';
          Flare._componentTag = tagName; // Define component..

          return Flare._getTemplateLiteral;
        } else {
          var array = [].concat(arg),
              _privateProps = {}; // Add some properties to the private props object....

          _privateProps.Flare = true;
          _privateProps.isStatelessComponent = true;
          _privateProps.flareId = "".concat(Flare._createFlareId(array)); // Add private props to return object and... return..

          return {
            flare: true,
            taggedTempLit: {
              extended: false,
              array: array
            },
            props: _privateProps,
            el: 'p',
            tag: tagName
          };
        }
      }) // H1 API Method

    }, {
      key: "h1",
      value: function (_h) {
        function h1() {
          return _h.apply(this, arguments);
        }

        h1.toString = function () {
          return _h.toString();
        };

        return h1;
      }(function () {
        // Get tagName...
        var tagName = _Utilities_helpers__WEBPACK_IMPORTED_MODULE_0__["convertFuncNameToTagName"](h1.caller.name); // log('TAGNAME', ['green', 'bold'])
        //  log(tagName)
        // If the argument is not an array, it's probably our props object...


        for (var _len9 = arguments.length, arg = new Array(_len9), _key9 = 0; _key9 < _len9; _key9++) {
          arg[_key9] = arguments[_key9];
        }

        if (!_Utilities_Is__WEBPACK_IMPORTED_MODULE_1__["Is"].array(arg[0])) {
          var props = arg[0]; // Set the Flare component indicator...

          props.Flare = true; // Set stateless-component flag for the component..

          props.isStatelessComponent = true; // Pass the prop object, and element tag name  on to the global members..

          Flare._propObj = props;
          Flare._elementTag = 'h1';
          Flare._componentTag = tagName; // Define component..

          return Flare._getTemplateLiteral;
        } else {
          var array = [].concat(arg),
              _privateProps = {}; // Add some properties to the private props object....

          _privateProps.Flare = true;
          _privateProps.isStatelessComponent = true;
          _privateProps.flareId = "".concat(Flare._createFlareId(array)); // Add private props to return object and... return..

          return {
            flare: true,
            taggedTempLit: {
              extended: false,
              array: array
            },
            props: _privateProps,
            el: 'h1',
            tag: tagName
          };
        }
      }) // H2 API Method

    }, {
      key: "h2",
      value: function (_h2) {
        function h2() {
          return _h2.apply(this, arguments);
        }

        h2.toString = function () {
          return _h2.toString();
        };

        return h2;
      }(function () {
        // Get tagName...
        var tagName = _Utilities_helpers__WEBPACK_IMPORTED_MODULE_0__["convertFuncNameToTagName"](h2.caller.name); // log('TAGNAME', ['green', 'bold'])
        //  log(tagName)
        // If the argument is not an array, it's probably our props object...


        for (var _len10 = arguments.length, arg = new Array(_len10), _key10 = 0; _key10 < _len10; _key10++) {
          arg[_key10] = arguments[_key10];
        }

        if (!_Utilities_Is__WEBPACK_IMPORTED_MODULE_1__["Is"].array(arg[0])) {
          var props = arg[0]; // Set the Flare component indicator...

          props.Flare = true; // Set stateless-component flag for the component..

          props.isStatelessComponent = true; // Pass the prop object, and element tag name  on to the global members..

          Flare._propObj = props;
          Flare._elementTag = 'h2';
          Flare._componentTag = tagName; // Define component..

          return Flare._getTemplateLiteral;
        } else {
          var array = [].concat(arg),
              _privateProps = {}; // Add some properties to the private props object....

          _privateProps.Flare = true;
          _privateProps.isStatelessComponent = true;
          _privateProps.flareId = "".concat(Flare._createFlareId(array)); // Add private props to return object and... return..

          return {
            flare: true,
            taggedTempLit: {
              extended: false,
              array: array
            },
            props: _privateProps,
            el: 'h2',
            tag: tagName
          };
        }
      }) // H3 API Method

    }, {
      key: "h3",
      value: function (_h3) {
        function h3() {
          return _h3.apply(this, arguments);
        }

        h3.toString = function () {
          return _h3.toString();
        };

        return h3;
      }(function () {
        // Get tagName...
        var tagName = _Utilities_helpers__WEBPACK_IMPORTED_MODULE_0__["convertFuncNameToTagName"](h3.caller.name); // log('TAGNAME', ['green', 'bold'])
        //  log(tagName)
        // If the argument is not an array, it's probably our props object...


        for (var _len11 = arguments.length, arg = new Array(_len11), _key11 = 0; _key11 < _len11; _key11++) {
          arg[_key11] = arguments[_key11];
        }

        if (!_Utilities_Is__WEBPACK_IMPORTED_MODULE_1__["Is"].array(arg[0])) {
          var props = arg[0]; // Set the Flare component indicator...

          props.Flare = true; // Set stateless-component flag for the component..

          props.isStatelessComponent = true; // Pass the prop object, and element tag name  on to the global members..

          Flare._propObj = props;
          Flare._elementTag = 'h3';
          Flare._componentTag = tagName; // Define component..

          return Flare._getTemplateLiteral;
        } else {
          var array = [].concat(arg),
              _privateProps = {}; // Add some properties to the private props object....

          _privateProps.Flare = true;
          _privateProps.isStatelessComponent = true;
          _privateProps.flareId = "".concat(Flare._createFlareId(array)); // Add private props to return object and... return..

          return {
            flare: true,
            taggedTempLit: {
              extended: false,
              array: array
            },
            props: _privateProps,
            el: 'h3',
            tag: tagName
          };
        }
      }) // H4 API Method

    }, {
      key: "h4",
      value: function (_h4) {
        function h4() {
          return _h4.apply(this, arguments);
        }

        h4.toString = function () {
          return _h4.toString();
        };

        return h4;
      }(function () {
        /// Get tagName...
        var tagName = _Utilities_helpers__WEBPACK_IMPORTED_MODULE_0__["convertFuncNameToTagName"](h4.caller.name); // log('TAGNAME', ['green', 'bold'])
        //  log(tagName)
        // If the argument is not an array, it's probably our props object...


        for (var _len12 = arguments.length, arg = new Array(_len12), _key12 = 0; _key12 < _len12; _key12++) {
          arg[_key12] = arguments[_key12];
        }

        if (!_Utilities_Is__WEBPACK_IMPORTED_MODULE_1__["Is"].array(arg[0])) {
          var props = arg[0]; // Set the Flare component indicator...

          props.Flare = true; // Set stateless-component flag for the component..

          props.isStatelessComponent = true; // Pass the prop object, and element tag name  on to the global members..

          Flare._propObj = props;
          Flare._elementTag = 'h4';
          Flare._componentTag = tagName; // Define component..

          return Flare._getTemplateLiteral;
        } else {
          var array = [].concat(arg),
              _privateProps = {}; // Add some properties to the private props object....

          _privateProps.Flare = true;
          _privateProps.isStatelessComponent = true;
          _privateProps.flareId = "".concat(Flare._createFlareId(array)); // Add private props to return object and... return..

          return {
            flare: true,
            taggedTempLit: {
              extended: false,
              array: array
            },
            props: _privateProps,
            el: 'h4',
            tag: tagName
          };
        }
      }) // H5 API Method

    }, {
      key: "h5",
      value: function (_h5) {
        function h5() {
          return _h5.apply(this, arguments);
        }

        h5.toString = function () {
          return _h5.toString();
        };

        return h5;
      }(function () {
        /// Get tagName...
        var tagName = _Utilities_helpers__WEBPACK_IMPORTED_MODULE_0__["convertFuncNameToTagName"](h5.caller.name); // log('TAGNAME', ['green', 'bold'])
        //  log(tagName)
        // If the argument is not an array, it's probably our props object...


        for (var _len13 = arguments.length, arg = new Array(_len13), _key13 = 0; _key13 < _len13; _key13++) {
          arg[_key13] = arguments[_key13];
        }

        if (!_Utilities_Is__WEBPACK_IMPORTED_MODULE_1__["Is"].array(arg[0])) {
          var props = arg[0]; // Set the Flare component indicator...

          props.Flare = true; // Set stateless-component flag for the component..

          props.isStatelessComponent = true; // Pass the prop object, and element tag name  on to the global members..

          Flare._propObj = props;
          Flare._elementTag = 'h5';
          Flare._componentTag = tagName; // Define component..

          return Flare._getTemplateLiteral;
        } else {
          var array = [].concat(arg),
              _privateProps = {}; // Add some properties to the private props object....

          _privateProps.Flare = true;
          _privateProps.isStatelessComponent = true;
          _privateProps.flareId = "".concat(Flare._createFlareId(array)); // Add private props to return object and... return..

          return {
            flare: true,
            taggedTempLit: {
              extended: false,
              array: array
            },
            props: _privateProps,
            el: 'h5',
            tag: tagName
          };
        }
      }) // H6 API Function

    }, {
      key: "h6",
      value: function (_h6) {
        function h6() {
          return _h6.apply(this, arguments);
        }

        h6.toString = function () {
          return _h6.toString();
        };

        return h6;
      }(function () {
        /// Get tagName...
        var tagName = _Utilities_helpers__WEBPACK_IMPORTED_MODULE_0__["convertFuncNameToTagName"](h6.caller.name); // log('TAGNAME', ['green', 'bold'])
        //  log(tagName)
        // If the argument is not an array, it's probably our props object...


        for (var _len14 = arguments.length, arg = new Array(_len14), _key14 = 0; _key14 < _len14; _key14++) {
          arg[_key14] = arguments[_key14];
        }

        if (!_Utilities_Is__WEBPACK_IMPORTED_MODULE_1__["Is"].array(arg[0])) {
          var props = arg[0]; // Set the Flare component indicator...

          props.Flare = true; // Set stateless-component flag for the component..

          props.isStatelessComponent = true; // Pass the prop object, and element tag name  on to the global members..

          Flare._propObj = props;
          Flare._elementTag = 'h6';
          Flare._componentTag = tagName; // Define component..

          return Flare._getTemplateLiteral;
        } else {
          var array = [].concat(arg),
              _privateProps = {}; // Add some properties to the private props object....

          _privateProps.Flare = true;
          _privateProps.isStatelessComponent = true;
          _privateProps.flareId = "".concat(Flare._createFlareId(array)); // Add private props to return object and... return..

          return {
            flare: true,
            taggedTempLit: {
              extended: false,
              array: array
            },
            props: _privateProps,
            el: 'h6',
            tag: tagName
          };
        }
      }) // HEADER API Method

    }, {
      key: "header",
      value: function (_header) {
        function header() {
          return _header.apply(this, arguments);
        }

        header.toString = function () {
          return _header.toString();
        };

        return header;
      }(function () {
        /// Get tagName...
        var tagName = _Utilities_helpers__WEBPACK_IMPORTED_MODULE_0__["convertFuncNameToTagName"](header.caller.name); // log('TAGNAME', ['green', 'bold'])
        //  log(tagName)
        // If the argument is not an array, it's probably our props object...


        for (var _len15 = arguments.length, arg = new Array(_len15), _key15 = 0; _key15 < _len15; _key15++) {
          arg[_key15] = arguments[_key15];
        }

        if (!_Utilities_Is__WEBPACK_IMPORTED_MODULE_1__["Is"].array(arg[0])) {
          var props = arg[0]; // Set the Flare component indicator...

          props.Flare = true; // Set stateless-component flag for the component..

          props.isStatelessComponent = true; // Pass the prop object, and element tag name  on to the global members..

          Flare._propObj = props;
          Flare._elementTag = 'header';
          Flare._componentTag = tagName; // Define component..

          return Flare._getTemplateLiteral;
        } else {
          var array = [].concat(arg),
              _privateProps = {}; // Add some properties to the private props object....

          _privateProps.Flare = true;
          _privateProps.isStatelessComponent = true;
          _privateProps.flareId = "".concat(Flare._createFlareId(array)); // Add private props to return object and... return..

          return {
            flare: true,
            taggedTempLit: {
              extended: false,
              array: array
            },
            props: _privateProps,
            el: 'header',
            tag: tagName
          };
        }
      }) // AREA API Method

    }, {
      key: "area",
      value: function (_area) {
        function area() {
          return _area.apply(this, arguments);
        }

        area.toString = function () {
          return _area.toString();
        };

        return area;
      }(function () {
        /// Get tagName...
        var tagName = _Utilities_helpers__WEBPACK_IMPORTED_MODULE_0__["convertFuncNameToTagName"](area.caller.name); // log('TAGNAME', ['green', 'bold'])
        //  log(tagName)
        // If the argument is not an array, it's probably our props object...


        for (var _len16 = arguments.length, arg = new Array(_len16), _key16 = 0; _key16 < _len16; _key16++) {
          arg[_key16] = arguments[_key16];
        }

        if (!_Utilities_Is__WEBPACK_IMPORTED_MODULE_1__["Is"].array(arg[0])) {
          var props = arg[0]; // Set the Flare component indicator...

          props.Flare = true; // Set stateless-component flag for the component..

          props.isStatelessComponent = true; // Pass the prop object, and element tag name  on to the global members..

          Flare._propObj = props;
          Flare._elementTag = 'area';
          Flare._componentTag = tagName; // Define component..

          return Flare._getTemplateLiteral;
        } else {
          var array = [].concat(arg),
              _privateProps = {}; // Add some properties to the private props object....

          _privateProps.Flare = true;
          _privateProps.isStatelessComponent = true;
          _privateProps.flareId = "".concat(Flare._createFlareId(array)); // Add private props to return object and... return..

          return {
            flare: true,
            taggedTempLit: {
              extended: false,
              array: array
            },
            props: _privateProps,
            el: 'area',
            tag: tagName
          };
        }
      }) // ASIDE API Method

    }, {
      key: "aside",
      value: function (_aside) {
        function aside() {
          return _aside.apply(this, arguments);
        }

        aside.toString = function () {
          return _aside.toString();
        };

        return aside;
      }(function () {
        /// Get tagName...
        var tagName = _Utilities_helpers__WEBPACK_IMPORTED_MODULE_0__["convertFuncNameToTagName"](aside.caller.name); // log('TAGNAME', ['green', 'bold'])
        //  log(tagName)
        // If the argument is not an array, it's probably our props object...


        for (var _len17 = arguments.length, arg = new Array(_len17), _key17 = 0; _key17 < _len17; _key17++) {
          arg[_key17] = arguments[_key17];
        }

        if (!_Utilities_Is__WEBPACK_IMPORTED_MODULE_1__["Is"].array(arg[0])) {
          var props = arg[0]; // Set the Flare component indicator...

          props.Flare = true; // Set stateless-component flag for the component..

          props.isStatelessComponent = true; // Pass the prop object, and element tag name  on to the global members..

          Flare._propObj = props;
          Flare._elementTag = 'aside';
          Flare._componentTag = tagName; // Define component..

          return Flare._getTemplateLiteral;
        } else {
          var array = [].concat(arg),
              _privateProps = {}; // Add some properties to the private props object....

          _privateProps.Flare = true;
          _privateProps.isStatelessComponent = true;
          _privateProps.flareId = "".concat(Flare._createFlareId(array)); // Add private props to return object and... return..

          return {
            flare: true,
            taggedTempLit: {
              extended: false,
              array: array
            },
            props: _privateProps,
            el: 'aside',
            tag: tagName
          };
        }
      }) // COL API Method

    }, {
      key: "col",
      value: function (_col) {
        function col() {
          return _col.apply(this, arguments);
        }

        col.toString = function () {
          return _col.toString();
        };

        return col;
      }(function () {
        /// Get tagName...
        var tagName = _Utilities_helpers__WEBPACK_IMPORTED_MODULE_0__["convertFuncNameToTagName"](col.caller.name); // log('TAGNAME', ['green', 'bold'])
        //  log(tagName)
        // If the argument is not an array, it's probably our props object...


        for (var _len18 = arguments.length, arg = new Array(_len18), _key18 = 0; _key18 < _len18; _key18++) {
          arg[_key18] = arguments[_key18];
        }

        if (!_Utilities_Is__WEBPACK_IMPORTED_MODULE_1__["Is"].array(arg[0])) {
          var props = arg[0]; // Set the Flare component indicator...

          props.Flare = true; // Set stateless-component flag for the component..

          props.isStatelessComponent = true; // Pass the prop object, and element tag name  on to the global members..

          Flare._propObj = props;
          Flare._elementTag = 'col';
          Flare._componentTag = tagName; // Define component..

          return Flare._getTemplateLiteral;
        } else {
          var array = [].concat(arg),
              _privateProps = {}; // Add some properties to the private props object....

          _privateProps.Flare = true;
          _privateProps.isStatelessComponent = true;
          _privateProps.flareId = "".concat(Flare._createFlareId(array)); // Add private props to return object and... return..

          return {
            flare: true,
            taggedTempLit: {
              extended: false,
              array: array
            },
            props: _privateProps,
            el: 'col',
            tag: tagName
          };
        }
      }) // COLGROUP API Method

    }, {
      key: "colgroup",
      value: function (_colgroup) {
        function colgroup() {
          return _colgroup.apply(this, arguments);
        }

        colgroup.toString = function () {
          return _colgroup.toString();
        };

        return colgroup;
      }(function () {
        /// Get tagName...
        var tagName = _Utilities_helpers__WEBPACK_IMPORTED_MODULE_0__["convertFuncNameToTagName"](colgroup.caller.name); // log('TAGNAME', ['green', 'bold'])
        //  log(tagName)
        // If the argument is not an array, it's probably our props object...


        for (var _len19 = arguments.length, arg = new Array(_len19), _key19 = 0; _key19 < _len19; _key19++) {
          arg[_key19] = arguments[_key19];
        }

        if (!_Utilities_Is__WEBPACK_IMPORTED_MODULE_1__["Is"].array(arg[0])) {
          var props = arg[0]; // Set the Flare component indicator...

          props.Flare = true; // Set stateless-component flag for the component..

          props.isStatelessComponent = true; // Pass the prop object, and element tag name  on to the global members..

          Flare._propObj = props;
          Flare._elementTag = 'colgroup';
          Flare._componentTag = tagName; // Define component..

          return Flare._getTemplateLiteral;
        } else {
          var array = [].concat(arg),
              _privateProps = {}; // Add some properties to the private props object....

          _privateProps.Flare = true;
          _privateProps.isStatelessComponent = true;
          _privateProps.flareId = "".concat(Flare._createFlareId(array)); // Add private props to return object and... return..

          return {
            flare: true,
            taggedTempLit: {
              extended: false,
              array: array
            },
            props: _privateProps,
            el: 'colgroup',
            tag: tagName
          };
        }
      }) // SPAN API Method

    }, {
      key: "span",
      value: function (_span) {
        function span() {
          return _span.apply(this, arguments);
        }

        span.toString = function () {
          return _span.toString();
        };

        return span;
      }(function () {
        /// Get tagName...
        var tagName = _Utilities_helpers__WEBPACK_IMPORTED_MODULE_0__["convertFuncNameToTagName"](span.caller.name); // log('TAGNAME', ['green', 'bold'])
        //  log(tagName)
        // If the argument is not an array, it's probably our props object...


        for (var _len20 = arguments.length, arg = new Array(_len20), _key20 = 0; _key20 < _len20; _key20++) {
          arg[_key20] = arguments[_key20];
        }

        if (!_Utilities_Is__WEBPACK_IMPORTED_MODULE_1__["Is"].array(arg[0])) {
          var props = arg[0]; // Set the Flare component indicator...

          props.Flare = true; // Set stateless-component flag for the component..

          props.isStatelessComponent = true; // Pass the prop object, and element tag name  on to the global members..

          Flare._propObj = props;
          Flare._elementTag = 'span';
          Flare._componentTag = tagName; // Define component..

          return Flare._getTemplateLiteral;
        } else {
          var array = [].concat(arg),
              _privateProps = {}; // Add some properties to the private props object....

          _privateProps.Flare = true;
          _privateProps.isStatelessComponent = true;
          _privateProps.flareId = "".concat(Flare._createFlareId(array)); // Add private props to return object and... return..

          return {
            flare: true,
            taggedTempLit: {
              extended: false,
              array: array
            },
            props: _privateProps,
            el: 'span',
            tag: tagName
          };
        }
      }) // SECTION API Method

    }, {
      key: "section",
      value: function (_section) {
        function section() {
          return _section.apply(this, arguments);
        }

        section.toString = function () {
          return _section.toString();
        };

        return section;
      }(function () {
        /// Get tagName...
        var tagName = _Utilities_helpers__WEBPACK_IMPORTED_MODULE_0__["convertFuncNameToTagName"](section.caller.name); // log('TAGNAME', ['green', 'bold'])
        //  log(tagName)
        // If the argument is not an array, it's probably our props object...


        for (var _len21 = arguments.length, arg = new Array(_len21), _key21 = 0; _key21 < _len21; _key21++) {
          arg[_key21] = arguments[_key21];
        }

        if (!_Utilities_Is__WEBPACK_IMPORTED_MODULE_1__["Is"].array(arg[0])) {
          var props = arg[0]; // Set the Flare component indicator...

          props.Flare = true; // Set stateless-component flag for the component..

          props.isStatelessComponent = true; // Pass the prop object, and element tag name  on to the global members..

          Flare._propObj = props;
          Flare._elementTag = 'section';
          Flare._componentTag = tagName; // Define component..

          return Flare._getTemplateLiteral;
        } else {
          var array = [].concat(arg),
              _privateProps = {}; // Add some properties to the private props object....

          _privateProps.Flare = true;
          _privateProps.isStatelessComponent = true;
          _privateProps.flareId = "".concat(Flare._createFlareId(array)); // Add private props to return object and... return..

          return {
            flare: true,
            taggedTempLit: {
              extended: false,
              array: array
            },
            props: _privateProps,
            el: 'section',
            tag: tagName
          };
        }
      }) // TABLE API Function

    }, {
      key: "table",
      value: function (_table) {
        function table() {
          return _table.apply(this, arguments);
        }

        table.toString = function () {
          return _table.toString();
        };

        return table;
      }(function () {
        // Get tagName...
        var tagName = _Utilities_helpers__WEBPACK_IMPORTED_MODULE_0__["convertFuncNameToTagName"](table.caller.name); // log('TAGNAME', ['green', 'bold'])
        //  log(tagName)
        // If the argument is not an array, it's probably our props object...


        for (var _len22 = arguments.length, arg = new Array(_len22), _key22 = 0; _key22 < _len22; _key22++) {
          arg[_key22] = arguments[_key22];
        }

        if (!_Utilities_Is__WEBPACK_IMPORTED_MODULE_1__["Is"].array(arg[0])) {
          var props = arg[0]; // Set the Flare component indicator...

          props.Flare = true; // Set stateless-component flag for the component..

          props.isStatelessComponent = true; // Pass the prop object, and element tag name  on to the global members..

          Flare._propObj = props;
          Flare._elementTag = 'table';
          Flare._componentTag = tagName; // Define component..

          return Flare._getTemplateLiteral;
        } else {
          var array = [].concat(arg),
              _privateProps = {}; // Add some properties to the private props object....

          _privateProps.Flare = true;
          _privateProps.isStatelessComponent = true;
          _privateProps.flareId = "".concat(Flare._createFlareId(array)); // Add private props to return object and... return..

          return {
            flare: true,
            taggedTempLit: {
              extended: false,
              array: array
            },
            props: _privateProps,
            el: 'table',
            tag: tagName
          };
        }
      }) // TEXTAREA API Function

    }, {
      key: "textarea",
      value: function (_textarea) {
        function textarea() {
          return _textarea.apply(this, arguments);
        }

        textarea.toString = function () {
          return _textarea.toString();
        };

        return textarea;
      }(function () {
        // Get tagName...
        var tagName = _Utilities_helpers__WEBPACK_IMPORTED_MODULE_0__["convertFuncNameToTagName"](textarea.caller.name); // log('TAGNAME', ['green', 'bold'])
        //  log(tagName)
        // If the argument is not an array, it's probably our props object...


        for (var _len23 = arguments.length, arg = new Array(_len23), _key23 = 0; _key23 < _len23; _key23++) {
          arg[_key23] = arguments[_key23];
        }

        if (!_Utilities_Is__WEBPACK_IMPORTED_MODULE_1__["Is"].array(arg[0])) {
          var props = arg[0]; // Set the Flare component indicator...

          props.Flare = true; // Set stateless-component flag for the component..

          props.isStatelessComponent = true; // Pass the prop object, and element tag name  on to the global members..

          Flare._propObj = props;
          Flare._elementTag = 'textarea';
          Flare._componentTag = tagName; // Define component..

          return Flare._getTemplateLiteral;
        } else {
          var array = [].concat(arg),
              _privateProps = {}; // Add some properties to the private props object....

          _privateProps.Flare = true;
          _privateProps.isStatelessComponent = true;
          _privateProps.flareId = "".concat(Flare._createFlareId(array)); // Add private props to return object and... return..

          return {
            flare: true,
            taggedTempLit: {
              extended: false,
              array: array
            },
            props: _privateProps,
            el: 'textarea',
            tag: tagName
          };
        }
      }) // FOOTER API Function

    }, {
      key: "footer",
      value: function (_footer) {
        function footer() {
          return _footer.apply(this, arguments);
        }

        footer.toString = function () {
          return _footer.toString();
        };

        return footer;
      }(function () {
        // Get tagName...
        var tagName = _Utilities_helpers__WEBPACK_IMPORTED_MODULE_0__["convertFuncNameToTagName"](footer.caller.name); // log('TAGNAME', ['green', 'bold'])
        //  log(tagName)
        // If the argument is not an array, it's probably our props object...


        for (var _len24 = arguments.length, arg = new Array(_len24), _key24 = 0; _key24 < _len24; _key24++) {
          arg[_key24] = arguments[_key24];
        }

        if (!_Utilities_Is__WEBPACK_IMPORTED_MODULE_1__["Is"].array(arg[0])) {
          var props = arg[0]; // Set the Flare component indicator...

          props.Flare = true; // Set stateless-component flag for the component..

          props.isStatelessComponent = true; // Pass the prop object, and element tag name  on to the global members..

          Flare._propObj = props;
          Flare._elementTag = 'footer';
          Flare._componentTag = tagName; // Define component..

          return Flare._getTemplateLiteral;
        } else {
          var array = [].concat(arg),
              _privateProps = {}; // Add some properties to the private props object....

          _privateProps.Flare = true;
          _privateProps.isStatelessComponent = true;
          _privateProps.flareId = "".concat(Flare._createFlareId(array)); // Add private props to return object and... return..

          return {
            flare: true,
            taggedTempLit: {
              extended: false,
              array: array
            },
            props: _privateProps,
            el: 'footer',
            tag: tagName
          };
        }
      })
    }, {
      key: "options",
      // The config options object.. with default assumptions...
      get: function get() {
        return Flare._assumptions;
      }
    }, {
      key: "_tagQueue",
      // Getter for the component tagName queue...
      get: function get() {
        // If we have an array in the queue, return it, otherwise return the main array....
        if (Flare._tagNameArrayQueue.length > 0) {
          if (Flare._tagNameArrayQueue[0].length < 1) {
            Flare._tagNameArrayQueue.shift();

            return Flare._flareComponentNames.shift();
          } else {
            return Flare._tagNameArrayQueue.shift();
          }
        } else {
          return Flare._flareComponentNames.shift();
        }
      } // Setter for the tag queue...
      ,
      set: function set(array) {
        /* If the main array is empty, pass the argument to it, otherwise, shift the argument
         in to the beginning of the queue array...*/
        if (Flare._flareComponentNames.length === 0) {
          Flare._flareComponentNames.unshift(array);
        } else {
          Flare._tagNameArrayQueue.unshift(array);
        }
      } // Number places for _numeral

    }, {
      key: "_incrementor",
      // A simple getter for static _numeral
      get: function get() {
        // Increment ones place first, then rest accordingly...
        if (Flare._ones_ < 9) {
          ++Flare._ones_;
        } else {
          Flare._ones_ = 0;

          if (Flare._tens_ < 9) {
            ++Flare._tens_;
          } else {
            Flare._tens_ = 0;

            if (Flare._huns_ < 9) {
              ++Flare._huns_;
            } else {
              Flare._huns_ = 0;
            }
          }
        } // Assemble the numeral string...


        Flare._numeral = "".concat(Flare._huns_).concat(Flare._tens_).concat(Flare._ones_); // Return..

        return Flare._numeral;
      }
    }]);

    return Flare;
  }();

  _defineProperty(Flare, "_assumptions", {
    shadowByDefault: true,
    kebabCase: true,
    globalFunctions: true,
    underscoreGlobal: false
  });

  _defineProperty(Flare, "_elementTag", '');

  _defineProperty(Flare, "_superTag", '');

  _defineProperty(Flare, "_superId", '');

  _defineProperty(Flare, "_id", '');

  _defineProperty(Flare, "_propObj", {});

  _defineProperty(Flare, "_superTempLit", "");

  _defineProperty(Flare, "_superProps", {});

  _defineProperty(Flare, "_extend", false);

  _defineProperty(Flare, "_tagNameArrayQueue", []);

  _defineProperty(Flare, "_flareComponentNames", [[]]);

  _defineProperty(Flare, "_ones_", 0);

  _defineProperty(Flare, "_tens_", 0);

  _defineProperty(Flare, "_huns_", 0);

  _defineProperty(Flare, "_numeral", -1);

  var css = Flare.css;
  /***/
},
/* 168 */

/***/
function (module, __webpack_exports__, __webpack_require__) {
  ;

  __webpack_require__.r(__webpack_exports__);
  /* harmony export (binding) */


  __webpack_require__.d(__webpack_exports__, "Area", function () {
    return Area;
  });
  /* harmony import */


  var _Utilities_helpers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(4);
  /* harmony import */


  var _Utilities_data__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(5);
  /* harmony import */


  var _Events__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(37);
  /* harmony import */


  var _CSS__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(43);
  /* harmony import */


  var _Form_Node__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(35);

  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  function _defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    return Constructor;
  }

  function _defineProperty(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }

    return obj;
  }
  /*
  ** Area.js
  **
  ** Area.js is an extensible HTML5 Web Component wrapper, built around the Area
  ** element. It's aim is in providing an area element that is able to be
  ** extended via the v1 web components api...
  **
  ** Eric James Foster, Fostware LLC, MIT License.
  ***/
  // Get utilities...
  // Get data...
  // Get Events...
  // Get CSS...
  // Get Node class...
  // Globalize common utility functions...


  var dir = console.dir;
  var log = _Utilities_helpers__WEBPACK_IMPORTED_MODULE_0__["log"];
  var el = _Utilities_helpers__WEBPACK_IMPORTED_MODULE_0__["el"];
  var dom = _Utilities_helpers__WEBPACK_IMPORTED_MODULE_0__["dom"];

  var Area =
  /*#__PURE__*/
  function () {
    function Area() {
      _classCallCheck(this, Area);
    }

    _createClass(Area, null, [{
      key: "_appendStyleNode",
      // A CSS template literal, holding default styles for an area...
      // Static method for appending child nodes to parent elements...
      value: function _appendStyleNode(root, child) {
        return root.appendChild(_Form_Node__WEBPACK_IMPORTED_MODULE_4__["Node"].createNode(child()));
      } // Static method for defining a flare area element...

    }, {
      key: "createComponent",
      value: function createComponent() {
        var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        var template = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false; // log('props', ['orange', 'bold'])
        // dir(props)
        // Declarations..

        var _HTMLAreaComponent,
            eListeners = [],
            customProps = [],
            shadowBool,
            shadow = props.shadow,
            area,
            self,
            obj;
        /* Doing some finaglery with the native-shim and HTMLElement object.  This will
        be necessary until web components are fully supported in all browsers... */


        window.useNativeShim = false;
        window.HTMLElement = window._HTMLElement; // Get attribute names and Listeners...

        if (props) {
          obj = _Utilities_helpers__WEBPACK_IMPORTED_MODULE_0__["processData"](_Utilities_helpers__WEBPACK_IMPORTED_MODULE_0__["propsArray"](props)); // Store attribute and Listener pairs...

          customProps = obj.props;
          eListeners = obj.eventListeners;
        } // Create an HTMLAreaElement...


        area = document.createElement('area'); // Some default settings for area elements...
        // Set flare identifier flag..

        area.flare = true; // Pass props from flare component declaration on to the inner area el...

        for (var _i = 0, _Object$keys = Object.keys(props); _i < _Object$keys.length; _i++) {
          var key = _Object$keys[_i]; // Check all keys in area el object...

          if (key in area) {
            // Pass on the ones that match...
            // log(`${key} in area`, ['yellow', 'bold'])
            area["".concat(key)] = props["".concat(key)]; // Or if they are style properties...,
          } else if (key in area.style) {
            // log(`${key} in area`, ['pink', 'bold'])
            // Put them here...
            area.style["".concat(key)] = props["".concat(key)];
          }
        } // // Check for '-----' attribute,
        //     if ('-----' in props) {
        //       area.textContent = props.-----
        //       // area.style.margin = '5'
        //     }
        // The area component element's constructor definition...


        _HTMLAreaComponent = function HTMLAreaComponent() {
          var shadowRoot; // Construct an element, store as self...

          self = Reflect.construct(HTMLElement, [], _HTMLAreaComponent);

          if (shadow) {
            // Create shadow root...
            shadowRoot = self.attachShadow({
              mode: 'open'
            }); // Append to shadow root...

            shadowRoot.appendChild(area); // Create a node from the template function, and append to shadowRoot....

            Area._appendStyleNode(shadowRoot, template);
          } // Return constructor...


          return self;
        }; // Add superclass prototype...


        _HTMLAreaComponent.prototype = Object.create(HTMLAreaElement.prototype); // Add constructor...

        _HTMLAreaComponent.prototype.constructor = _HTMLAreaComponent; // Register event listener methods..

        _Events__WEBPACK_IMPORTED_MODULE_2__["Events"].registerCallbacks(_HTMLAreaComponent, eListeners); // console.dir(HTMLComponent)
        // Add connectedCallback method appending children if shadow is false...


        if (!shadow) {
          _HTMLAreaComponent.prototype.connectedCallback = function () {
            self.appendChild(area);
          };
        } // Return component to the caller...


        return _HTMLAreaComponent;
      }
    }]);

    return Area;
  }();

  _defineProperty(Area, "_tempLiteral", ":host {\n\n                        }");
  /***/

},
/* 169 */

/***/
function (module, __webpack_exports__, __webpack_require__) {
  ;

  __webpack_require__.r(__webpack_exports__);
  /* harmony export (binding) */


  __webpack_require__.d(__webpack_exports__, "Aside", function () {
    return Aside;
  });
  /* harmony import */


  var _Utilities_helpers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(4);
  /* harmony import */


  var _Utilities_data__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(5);
  /* harmony import */


  var _Events__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(37);
  /* harmony import */


  var _CSS__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(43);
  /* harmony import */


  var _Form_Node__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(35);

  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  function _defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    return Constructor;
  }

  function _defineProperty(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }

    return obj;
  }
  /*
  ** Aside.js
  **
  ** Aside.js is an extensible HTML5 Web Component wrapper, built around the Aside
  ** element. It's aim is in providing an aside element that is able to be
  ** extended via the v1 web components api...
  **
  ** Eric James Foster, Fostware LLC, MIT License.
  ***/
  // Get utilities...
  // Get data...
  // Get Events...
  // Get CSS...
  // Get Node class...
  // Globalize common utility functions...


  var dir = console.dir;
  var log = _Utilities_helpers__WEBPACK_IMPORTED_MODULE_0__["log"];
  var el = _Utilities_helpers__WEBPACK_IMPORTED_MODULE_0__["el"];
  var dom = _Utilities_helpers__WEBPACK_IMPORTED_MODULE_0__["dom"];

  var Aside =
  /*#__PURE__*/
  function () {
    function Aside() {
      _classCallCheck(this, Aside);
    }

    _createClass(Aside, null, [{
      key: "_appendStyleNode",
      // A CSS template literal, holding default styles for an aside...
      // Static method for appending child nodes to parent elements...
      value: function _appendStyleNode(root, child) {
        return root.appendChild(_Form_Node__WEBPACK_IMPORTED_MODULE_4__["Node"].createNode(child()));
      } // Static method for defining a flare aside element...

    }, {
      key: "createComponent",
      value: function createComponent() {
        var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        var template = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false; // log('props', ['orange', 'bold'])
        // dir(props)
        // Declarations..

        var _HTMLAsideComponent,
            eListeners = [],
            customProps = [],
            shadowBool,
            shadow = props.shadow,
            aside,
            self,
            obj;
        /* Doing some finaglery with the native-shim and HTMLElement object.  This will
        be necessary until web components are fully supported in all browsers... */


        window.useNativeShim = false;
        window.HTMLElement = window._HTMLElement; // Get attribute names and Listeners...

        if (props) {
          obj = _Utilities_helpers__WEBPACK_IMPORTED_MODULE_0__["processData"](_Utilities_helpers__WEBPACK_IMPORTED_MODULE_0__["propsArray"](props)); // Store attribute and Listener pairs...

          customProps = obj.props;
          eListeners = obj.eventListeners;
        } // Create an HTMLAsideElement...


        aside = document.createElement('aside'); // Some default settings for aside elements...
        // Set flare identifier flag..

        aside.flare = true; // Pass props from flare component declaration on to the inner aside el...

        for (var _i = 0, _Object$keys = Object.keys(props); _i < _Object$keys.length; _i++) {
          var key = _Object$keys[_i]; // Check all keys in aside el object...

          if (key in aside) {
            // Pass on the ones that match...
            // log(`${key} in aside`, ['yellow', 'bold'])
            aside["".concat(key)] = props["".concat(key)]; // Or if they are style properties...,
          } else if (key in aside.style) {
            // log(`${key} in aside`, ['pink', 'bold'])
            // Put them here...
            aside.style["".concat(key)] = props["".concat(key)];
          }
        } // // Check for '-----' attribute,
        //     if ('-----' in props) {
        //       aside.textContent = props.-----
        //       // aside.style.margin = '5'
        //     }
        // The aside component element's constructor definition...


        _HTMLAsideComponent = function HTMLAsideComponent() {
          var shadowRoot; // Construct an element, store as self...

          self = Reflect.construct(HTMLElement, [], _HTMLAsideComponent);

          if (shadow) {
            // Create shadow root...
            shadowRoot = self.attachShadow({
              mode: 'open'
            }); // Append to shadow root...

            shadowRoot.appendChild(aside); // Create a node from the template function, and append to shadowRoot....

            Aside._appendStyleNode(shadowRoot, template);
          } // Return constructor...


          return self;
        }; // Add superclass prototype...


        _HTMLAsideComponent.prototype = Object.create(HTMLAsideElement.prototype); // Add constructor...

        _HTMLAsideComponent.prototype.constructor = _HTMLAsideComponent; // Register event listener methods..

        _Events__WEBPACK_IMPORTED_MODULE_2__["Events"].registerCallbacks(_HTMLAsideComponent, eListeners); // console.dir(HTMLComponent)
        // Add connectedCallback method appending children if shadow is false...


        if (!shadow) {
          _HTMLAsideComponent.prototype.connectedCallback = function () {
            self.appendChild(aside);
          };
        } // Return component to the caller...


        return _HTMLAsideComponent;
      }
    }]);

    return Aside;
  }();

  _defineProperty(Aside, "_tempLiteral", ":host {\n\n                        }");
  /***/

},
/* 170 */

/***/
function (module, __webpack_exports__, __webpack_require__) {
  ;

  __webpack_require__.r(__webpack_exports__);
  /* harmony export (binding) */


  __webpack_require__.d(__webpack_exports__, "Button", function () {
    return Button;
  });
  /* harmony import */


  var _Utilities_helpers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(4);
  /* harmony import */


  var _Utilities_data__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(5);
  /* harmony import */


  var _Events__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(37);
  /* harmony import */


  var _CSS__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(43);
  /* harmony import */


  var _Form_Node__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(35);

  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  function _defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    return Constructor;
  }

  function _defineProperty(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }

    return obj;
  }
  /*
  ** Button.js
  **
  ** Button.js is an extensible HTML5 Web Component wrapper, built around the Button
  ** element. It's aim is in providing an button element that is able to be
  ** extended via the v1 web components api...
  **
  ** Eric James Foster, Fostware LLC, MIT License.
  ***/
  // Get utilities...
  // Get data...
  // Get Events...
  // Get CSS...
  // Get Node class...
  // Globalize common utility functions...


  var dir = console.dir;
  var log = _Utilities_helpers__WEBPACK_IMPORTED_MODULE_0__["log"];
  var el = _Utilities_helpers__WEBPACK_IMPORTED_MODULE_0__["el"];
  var dom = _Utilities_helpers__WEBPACK_IMPORTED_MODULE_0__["dom"];

  var Button =
  /*#__PURE__*/
  function () {
    function Button() {
      _classCallCheck(this, Button);
    }

    _createClass(Button, null, [{
      key: "_appendStyleNode",
      // A CSS template literal, holding default styles for a button...
      // Static method for appending child nodes to parent elements...
      value: function _appendStyleNode(root, child) {
        return root.appendChild(_Form_Node__WEBPACK_IMPORTED_MODULE_4__["Node"].createNode(child()));
      } // Static method for defining a flare button element...

    }, {
      key: "createComponent",
      value: function createComponent() {
        var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        var template = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
        log('props', ['orange', 'bold']);
        dir(props); // Declarations..

        var _HTMLButtonComponent,
            eListeners = [],
            customProps = [],
            shadowBool,
            shadow = props.shadow,
            button,
            self,
            obj;
        /* Doing some finaglery with the native-shim and HTMLElement object.  This will
        be necessary until web components are fully supported in all browsers... */


        window.useNativeShim = false;
        window.HTMLElement = window._HTMLElement; // Get attribute names and Listeners...

        if (props) {
          obj = _Utilities_helpers__WEBPACK_IMPORTED_MODULE_0__["processData"](_Utilities_helpers__WEBPACK_IMPORTED_MODULE_0__["propsArray"](props)); // Store attribute and Listener pairs...

          customProps = obj.props;
          eListeners = obj.eventListeners;
        } // Create an HTMLButtonElement...


        button = document.createElement('button'); // Some default settings for button elements...
        // Set flare identifier flag..
        // button.flare = true
        // if (props.type == 'text') {
        //
        // }
        // Pass props from flare component declaration on to the inner button el...

        for (var _i = 0, _Object$keys = Object.keys(props); _i < _Object$keys.length; _i++) {
          var key = _Object$keys[_i]; // Check all keys in button el object...

          if (key in button) {
            // Pass on the ones that match...
            log("".concat(key, " in button"), ['yellow', 'bold']);
            button["".concat(key)] = props["".concat(key)]; // Or if they are style properties...,
          } else if (key in button.style) {
            log("".concat(key, " in button"), ['pink', 'bold']); // Put them here...

            button.style["".concat(key)] = props["".concat(key)];
          }
        } // Check for 'label' attribute,


        if ('label' in props) {
          button.textContent = props.label;
          button.style.fontSize = '24px'; // button.style.margin = '5'
        } // The button component element's constructor definition...


        _HTMLButtonComponent = function HTMLButtonComponent() {
          var shadowRoot; // Construct an element, store as self...

          self = Reflect.construct(HTMLElement, [], _HTMLButtonComponent);

          if (shadow) {
            // Create shadow root...
            shadowRoot = self.attachShadow({
              mode: 'open'
            }); // Append to shadow root...

            shadowRoot.appendChild(button); // Create a node from the template function, and append to shadowRoot....

            Button._appendStyleNode(shadowRoot, template);
          } // Return constructor...


          return self;
        }; // Add superclass prototype...


        _HTMLButtonComponent.prototype = Object.create(HTMLButtonElement.prototype); // Add constructor...

        _HTMLButtonComponent.prototype.constructor = _HTMLButtonComponent; // Register event listener methods..

        _Events__WEBPACK_IMPORTED_MODULE_2__["Events"].registerCallbacks(_HTMLButtonComponent, eListeners); // console.dir(HTMLComponent)
        // Add connectedCallback method appending children if shadow is false...


        if (!shadow) {
          _HTMLButtonComponent.prototype.connectedCallback = function () {
            log('ConnectedCallback', ['red', 'bold']);
            dir(self);

            if (self) {
              log('self', ['yellow', 'bold']);
              self.appendChild(button); // Add a few default styles for the outer root element....

              self.style.width = '100%';
              self.style.paddingLeft = '10px';
              self.style.paddingRight = '10px';
              self.style.marginLeft = 'auto';
              self.style.marginRight = 'auto';
            } else if (this) {
              log('this', ['yellow', 'bold']);
              dir(this);
              this.appendChild(button); // Add a few default styles for the outer root element....

              this.style.width = '100%';
              this.style.paddingLeft = '10px';
              this.style.paddingRight = '10px';
              this.style.marginLeft = 'auto';
              this.style.marginRight = 'auto';
            } else {
              throw Error('ConnectedCallbackError: A problem has occured while appending component children.');
            }
          };
        } // Return component to the caller...


        return _HTMLButtonComponent;
      }
    }]);

    return Button;
  }();

  _defineProperty(Button, "_tempLiteral", ":host {\n                          background-color: black;\n                          border-radius: 5%;\n                        }");
  /***/

},
/* 171 */

/***/
function (module, __webpack_exports__, __webpack_require__) {
  ;

  __webpack_require__.r(__webpack_exports__);
  /* harmony export (binding) */


  __webpack_require__.d(__webpack_exports__, "Col", function () {
    return Col;
  });
  /* harmony import */


  var _Utilities_helpers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(4);
  /* harmony import */


  var _Utilities_data__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(5);
  /* harmony import */


  var _Events__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(37);
  /* harmony import */


  var _CSS__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(43);
  /* harmony import */


  var _Form_Node__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(35);

  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  function _defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    return Constructor;
  }

  function _defineProperty(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }

    return obj;
  }
  /*
  ** Col.js
  **
  ** Col.js is an extensible HTML5 Web Component wrapper, built around the Col
  ** element. It's aim is in providing an col element that is able to be
  ** extended via the v1 web components api...
  **
  ** Eric James Foster, Fostware LLC, MIT License.
  ***/
  // Get utilities...
  // Get data...
  // Get Events...
  // Get CSS...
  // Get Node class...
  // Globalize common utility functions...


  var dir = console.dir;
  var log = _Utilities_helpers__WEBPACK_IMPORTED_MODULE_0__["log"];
  var el = _Utilities_helpers__WEBPACK_IMPORTED_MODULE_0__["el"];
  var dom = _Utilities_helpers__WEBPACK_IMPORTED_MODULE_0__["dom"];

  var Col =
  /*#__PURE__*/
  function () {
    function Col() {
      _classCallCheck(this, Col);
    }

    _createClass(Col, null, [{
      key: "_appendStyleNode",
      // A CSS template literal, holding default styles for an col...
      // Static method for appending child nodes to parent elements...
      value: function _appendStyleNode(root, child) {
        return root.appendChild(_Form_Node__WEBPACK_IMPORTED_MODULE_4__["Node"].createNode(child()));
      } // Static method for defining a flare col element...

    }, {
      key: "createComponent",
      value: function createComponent() {
        var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        var template = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false; // log('props', ['orange', 'bold'])
        // dir(props)
        // Declarations..

        var _HTMLColComponent,
            eListeners = [],
            customProps = [],
            shadowBool,
            shadow = props.shadow,
            col,
            self,
            obj;
        /* Doing some finaglery with the native-shim and HTMLElement object.  This will
        be necessary until web components are fully supported in all browsers... */


        window.useNativeShim = false;
        window.HTMLElement = window._HTMLElement; // Get attribute names and Listeners...

        if (props) {
          obj = _Utilities_helpers__WEBPACK_IMPORTED_MODULE_0__["processData"](_Utilities_helpers__WEBPACK_IMPORTED_MODULE_0__["propsArray"](props)); // Store attribute and Listener pairs...

          customProps = obj.props;
          eListeners = obj.eventListeners;
        } // Create an HTMLColElement...


        col = document.createElement('col'); // Some default settings for col elements...
        // Set flare identifier flag..

        col.flare = true; // Pass props from flare component declaration on to the inner col el...

        for (var _i = 0, _Object$keys = Object.keys(props); _i < _Object$keys.length; _i++) {
          var key = _Object$keys[_i]; // Check all keys in col el object...

          if (key in col) {
            // Pass on the ones that match...
            // log(`${key} in col`, ['yellow', 'bold'])
            col["".concat(key)] = props["".concat(key)]; // Or if they are style properties...,
          } else if (key in col.style) {
            // log(`${key} in col`, ['pink', 'bold'])
            // Put them here...
            col.style["".concat(key)] = props["".concat(key)];
          }
        } // // Check for '-----' attribute,
        //     if ('-----' in props) {
        //       col.textContent = props.-----
        //       // col.style.margin = '5'
        //     }
        // The col component element's constructor definition...


        _HTMLColComponent = function HTMLColComponent() {
          var shadowRoot; // Construct an element, store as self...

          self = Reflect.construct(HTMLElement, [], _HTMLColComponent);

          if (shadow) {
            // Create shadow root...
            shadowRoot = self.attachShadow({
              mode: 'open'
            }); // Append to shadow root...

            shadowRoot.appendChild(col); // Create a node from the template function, and append to shadowRoot....

            Col._appendStyleNode(shadowRoot, template);
          } // Return constructor...


          return self;
        }; // Add superclass prototype...


        _HTMLColComponent.prototype = Object.create(HTMLColElement.prototype); // Add constructor...

        _HTMLColComponent.prototype.constructor = _HTMLColComponent; // Register event listener methods..

        _Events__WEBPACK_IMPORTED_MODULE_2__["Events"].registerCallbacks(_HTMLColComponent, eListeners); // console.dir(HTMLComponent)
        // Add connectedCallback method appending children if shadow is false...


        if (!shadow) {
          _HTMLColComponent.prototype.connectedCallback = function () {
            self.appendChild(col);
          };
        } // Return component to the caller...


        return _HTMLColComponent;
      }
    }]);

    return Col;
  }();

  _defineProperty(Col, "_tempLiteral", ":host {\n\n                        }");
  /***/

},
/* 172 */

/***/
function (module, __webpack_exports__, __webpack_require__) {
  ;

  __webpack_require__.r(__webpack_exports__);
  /* harmony export (binding) */


  __webpack_require__.d(__webpack_exports__, "Colgroup", function () {
    return Colgroup;
  });
  /* harmony import */


  var _Utilities_helpers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(4);
  /* harmony import */


  var _Utilities_data__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(5);
  /* harmony import */


  var _Events__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(37);
  /* harmony import */


  var _CSS__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(43);
  /* harmony import */


  var _Form_Node__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(35);

  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  function _defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    return Constructor;
  }

  function _defineProperty(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }

    return obj;
  }
  /*
  ** Colgroup.js
  **
  ** Colgroup.js is an extensible HTML5 Web Component wrapper, built around the Colgroup
  ** element. It's aim is in providing an colgroup element that is able to be
  ** extended via the v1 web components api...
  **
  ** Eric James Foster, Fostware LLC, MIT License.
  ***/
  // Get utilities...
  // Get data...
  // Get Events...
  // Get CSS...
  // Get Node class...
  // Globalize common utility functions...


  var dir = console.dir;
  var log = _Utilities_helpers__WEBPACK_IMPORTED_MODULE_0__["log"];
  var el = _Utilities_helpers__WEBPACK_IMPORTED_MODULE_0__["el"];
  var dom = _Utilities_helpers__WEBPACK_IMPORTED_MODULE_0__["dom"];

  var Colgroup =
  /*#__PURE__*/
  function () {
    function Colgroup() {
      _classCallCheck(this, Colgroup);
    }

    _createClass(Colgroup, null, [{
      key: "_appendStyleNode",
      // A CSS template literal, holding default styles for an colgroup...
      // Static method for appending child nodes to parent elements...
      value: function _appendStyleNode(root, child) {
        return root.appendChild(_Form_Node__WEBPACK_IMPORTED_MODULE_4__["Node"].createNode(child()));
      } // Static method for defining a flare colgroup element...

    }, {
      key: "createComponent",
      value: function createComponent() {
        var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        var template = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false; // log('props', ['orange', 'bold'])
        // dir(props)
        // Declarations..

        var _HTMLColgroupComponent,
            eListeners = [],
            customProps = [],
            shadowBool,
            shadow = props.shadow,
            colgroup,
            self,
            obj;
        /* Doing some finaglery with the native-shim and HTMLElement object.  This will
        be necessary until web components are fully supported in all browsers... */


        window.useNativeShim = false;
        window.HTMLElement = window._HTMLElement; // Get attribute names and Listeners...

        if (props) {
          obj = _Utilities_helpers__WEBPACK_IMPORTED_MODULE_0__["processData"](_Utilities_helpers__WEBPACK_IMPORTED_MODULE_0__["propsArray"](props)); // Store attribute and Listener pairs...

          customProps = obj.props;
          eListeners = obj.eventListeners;
        } // Create an HTMLColgroupElement...


        colgroup = document.createElement('colgroup'); // Some default settings for colgroup elements...
        // Set flare identifier flag..

        colgroup.flare = true; // Pass props from flare component declaration on to the inner colgroup el...

        for (var _i = 0, _Object$keys = Object.keys(props); _i < _Object$keys.length; _i++) {
          var key = _Object$keys[_i]; // Check all keys in colgroup el object...

          if (key in colgroup) {
            // Pass on the ones that match...
            // log(`${key} in colgroup`, ['yellow', 'bold'])
            colgroup["".concat(key)] = props["".concat(key)]; // Or if they are style properties...,
          } else if (key in colgroup.style) {
            // log(`${key} in colgroup`, ['pink', 'bold'])
            // Put them here...
            colgroup.style["".concat(key)] = props["".concat(key)];
          }
        } // // Check for '-----' attribute,
        //     if ('-----' in props) {
        //       colgroup.textContent = props.-----
        //       // colgroup.style.margin = '5'
        //     }
        // The colgroup component element's constructor definition...


        _HTMLColgroupComponent = function HTMLColgroupComponent() {
          var shadowRoot; // Construct an element, store as self...

          self = Reflect.construct(HTMLElement, [], _HTMLColgroupComponent);

          if (shadow) {
            // Create shadow root...
            shadowRoot = self.attachShadow({
              mode: 'open'
            }); // Append to shadow root...

            shadowRoot.appendChild(colgroup); // Create a node from the template function, and append to shadowRoot....

            Colgroup._appendStyleNode(shadowRoot, template);
          } // Return constructor...


          return self;
        }; // Add superclass prototype...


        _HTMLColgroupComponent.prototype = Object.create(HTMLColgroupElement.prototype); // Add constructor...

        _HTMLColgroupComponent.prototype.constructor = _HTMLColgroupComponent; // Register event listener methods..

        _Events__WEBPACK_IMPORTED_MODULE_2__["Events"].registerCallbacks(_HTMLColgroupComponent, eListeners); // console.dir(HTMLComponent)
        // Add connectedCallback method appending children if shadow is false...


        if (!shadow) {
          _HTMLColgroupComponent.prototype.connectedCallback = function () {
            self.appendChild(colgroup);
          };
        } // Return component to the caller...


        return _HTMLColgroupComponent;
      }
    }]);

    return Colgroup;
  }();

  _defineProperty(Colgroup, "_tempLiteral", ":host {\n\n                        }");
  /***/

},
/* 173 */

/***/
function (module, __webpack_exports__, __webpack_require__) {
  ;

  __webpack_require__.r(__webpack_exports__);
  /* harmony export (binding) */


  __webpack_require__.d(__webpack_exports__, "Footer", function () {
    return Footer;
  });
  /* harmony import */


  var _Utilities_helpers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(4);
  /* harmony import */


  var _Utilities_data__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(5);
  /* harmony import */


  var _Events__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(37);
  /* harmony import */


  var _CSS__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(43);
  /* harmony import */


  var _Form_Node__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(35);

  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  function _defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    return Constructor;
  }

  function _defineProperty(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }

    return obj;
  }
  /*
  ** Footer.js
  **
  ** Footer.js is an extensible HTML5 Web Component wrapper, built around the Footer
  ** element. It's aim is in providing an footer element that is able to be
  ** extended via the v1 web components api...
  **
  ** Eric James Foster, Fostware LLC, MIT License.
  ***/
  // Get utilities...
  // Get data...
  // Get Events...
  // Get CSS...
  // Get Node class...
  // Globalize common utility functions...


  var dir = console.dir;
  var log = _Utilities_helpers__WEBPACK_IMPORTED_MODULE_0__["log"];
  var el = _Utilities_helpers__WEBPACK_IMPORTED_MODULE_0__["el"];
  var dom = _Utilities_helpers__WEBPACK_IMPORTED_MODULE_0__["dom"];

  var Footer =
  /*#__PURE__*/
  function () {
    function Footer() {
      _classCallCheck(this, Footer);
    }

    _createClass(Footer, null, [{
      key: "_appendStyleNode",
      // A CSS template literal, holding default styles for an footer...
      // Static method for appending child nodes to parent elements...
      value: function _appendStyleNode(root, child) {
        return root.appendChild(_Form_Node__WEBPACK_IMPORTED_MODULE_4__["Node"].createNode(child()));
      } // Static method for defining a flare footer element...

    }, {
      key: "createComponent",
      value: function createComponent() {
        var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        var template = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false; // log('props', ['orange', 'bold'])
        // dir(props)
        // Declarations..

        var _HTMLFooterComponent,
            eListeners = [],
            customProps = [],
            shadowBool,
            shadow = props.shadow,
            footer,
            self,
            obj;
        /* Doing some finaglery with the native-shim and HTMLElement object.  This will
        be necessary until web components are fully supported in all browsers... */


        window.useNativeShim = false;
        window.HTMLElement = window._HTMLElement; // Get attribute names and Listeners...

        if (props) {
          obj = _Utilities_helpers__WEBPACK_IMPORTED_MODULE_0__["processData"](_Utilities_helpers__WEBPACK_IMPORTED_MODULE_0__["propsArray"](props)); // Store attribute and Listener pairs...

          customProps = obj.props;
          eListeners = obj.eventListeners;
        } // Create an HTMLFooterElement...


        footer = document.createElement('footer'); // Some default settings for footer elements...
        // Set flare identifier flag..

        footer.flare = true; // Pass props from flare component declaration on to the inner footer el...

        for (var _i = 0, _Object$keys = Object.keys(props); _i < _Object$keys.length; _i++) {
          var key = _Object$keys[_i]; // Check all keys in footer el object...

          if (key in footer) {
            // Pass on the ones that match...
            // log(`${key} in footer`, ['yellow', 'bold'])
            footer["".concat(key)] = props["".concat(key)]; // Or if they are style properties...,
          } else if (key in footer.style) {
            // log(`${key} in footer`, ['pink', 'bold'])
            // Put them here...
            footer.style["".concat(key)] = props["".concat(key)];
          }
        } // // Check for '-----' attribute,
        //     if ('-----' in props) {
        //       footer.textContent = props.-----
        //       // footer.style.margin = '5'
        //     }
        // The footer component element's constructor definition...


        _HTMLFooterComponent = function HTMLFooterComponent() {
          var shadowRoot; // Construct an element, store as self...

          self = Reflect.construct(HTMLElement, [], _HTMLFooterComponent);

          if (shadow) {
            // Create shadow root...
            shadowRoot = self.attachShadow({
              mode: 'open'
            }); // Append to shadow root...

            shadowRoot.appendChild(footer); // Create a node from the template function, and append to shadowRoot....

            Footer._appendStyleNode(shadowRoot, template);
          } // Return constructor...


          return self;
        }; // Add superclass prototype...


        _HTMLFooterComponent.prototype = Object.create(HTMLFooterElement.prototype); // Add constructor...

        _HTMLFooterComponent.prototype.constructor = _HTMLFooterComponent; // Register event listener methods..

        _Events__WEBPACK_IMPORTED_MODULE_2__["Events"].registerCallbacks(_HTMLFooterComponent, eListeners); // console.dir(HTMLComponent)
        // Add connectedCallback method appending children if shadow is false...


        if (!shadow) {
          _HTMLFooterComponent.prototype.connectedCallback = function () {
            self.appendChild(footer);
          };
        } // Return component to the caller...


        return _HTMLFooterComponent;
      }
    }]);

    return Footer;
  }();

  _defineProperty(Footer, "_tempLiteral", ":host {\n\n                        }");
  /***/

},
/* 174 */

/***/
function (module, __webpack_exports__, __webpack_require__) {
  ;

  __webpack_require__.r(__webpack_exports__);
  /* harmony export (binding) */


  __webpack_require__.d(__webpack_exports__, "H1", function () {
    return H1;
  });
  /* harmony import */


  var _Utilities_helpers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(4);
  /* harmony import */


  var _Utilities_data__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(5);
  /* harmony import */


  var _Events__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(37);
  /* harmony import */


  var _CSS__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(43);
  /* harmony import */


  var _Form_Node__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(35);

  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  function _defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    return Constructor;
  }

  function _defineProperty(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }

    return obj;
  }
  /*
  ** H1.js
  **
  ** H1.js is an extensible HTML5 Web Component wrapper, built around the H1
  ** element. It's aim is in providing an h1 element that is able to be
  ** extended via the v1 web components api...
  **
  ** Eric James Foster, Fostware LLC, MIT License.
  ***/
  // Get utilities...
  // Get data...
  // Get Events...
  // Get CSS...
  // Get Node class...
  // Globalize common utility functions...


  var dir = console.dir;
  var log = _Utilities_helpers__WEBPACK_IMPORTED_MODULE_0__["log"];
  var el = _Utilities_helpers__WEBPACK_IMPORTED_MODULE_0__["el"];
  var dom = _Utilities_helpers__WEBPACK_IMPORTED_MODULE_0__["dom"];

  var H1 =
  /*#__PURE__*/
  function () {
    function H1() {
      _classCallCheck(this, H1);
    }

    _createClass(H1, null, [{
      key: "_appendStyleNode",
      // A CSS template literal, holding default styles for an h1...
      // Static method for appending child nodes to parent elements...
      value: function _appendStyleNode(root, child) {
        return root.appendChild(_Form_Node__WEBPACK_IMPORTED_MODULE_4__["Node"].createNode(child()));
      } // Static method for defining a flare h1 element...

    }, {
      key: "createComponent",
      value: function createComponent() {
        var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        var template = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
        log('props', ['orange', 'bold']);
        dir(props); // Declarations..

        var _HTMLH1Component,
            eListeners = [],
            customProps = [],
            shadowBool,
            shadow = props.shadow,
            h1,
            self,
            obj;
        /* Doing some finaglery with the native-shim and HTMLElement object.  This will
        be necessary until web components are fully supported in all browsers... */


        window.useNativeShim = false;
        window.HTMLElement = window._HTMLElement; // Get attribute names and Listeners...

        if (props) {
          obj = _Utilities_helpers__WEBPACK_IMPORTED_MODULE_0__["processData"](_Utilities_helpers__WEBPACK_IMPORTED_MODULE_0__["propsArray"](props)); // Store attribute and Listener pairs...

          customProps = obj.props;
          eListeners = obj.eventListeners;
        } // Create an HTMLH1Element...


        h1 = document.createElement('h1'); // Some default settings for h1 elements...
        // Set flare identifier flag..

        h1.flare = true; // if (props.type == 'text') {
        //
        // }
        // Pass props from flare component declaration on to the inner h1 el...

        for (var _i = 0, _Object$keys = Object.keys(props); _i < _Object$keys.length; _i++) {
          var key = _Object$keys[_i]; // Check all keys in h1 el object...

          if (key in h1) {
            // Pass on the ones that match...
            log("".concat(key, " in h1"), ['yellow', 'bold']);
            h1["".concat(key)] = props["".concat(key)]; // Or if they are style properties...,
          } else if (key in h1.style) {
            log("".concat(key, " in h1"), ['pink', 'bold']); // Put them here...

            h1.style["".concat(key)] = props["".concat(key)];
          }
        } // Check for 'content' attribute,


        if ('content' in props) {
          h6.textContent = props.content; // h6.style.margin = '5'
        } // The h1 component element's constructor definition...


        _HTMLH1Component = function HTMLH1Component() {
          var shadowRoot; // Construct an element, store as self...

          self = Reflect.construct(HTMLElement, [], _HTMLH1Component);

          if (shadow) {
            // Create shadow root...
            shadowRoot = self.attachShadow({
              mode: 'open'
            }); // Append to shadow root...

            shadowRoot.appendChild(h1); // Create a node from the template function, and append to shadowRoot....

            H1._appendStyleNode(shadowRoot, template);
          } // Return constructor...


          return self;
        }; // Add superclass prototype...


        _HTMLH1Component.prototype = Object.create(HTMLHeaderElement.prototype); // Add constructor...

        _HTMLH1Component.prototype.constructor = _HTMLH1Component; // Register event listener methods..

        _Events__WEBPACK_IMPORTED_MODULE_2__["Events"].registerCallbacks(_HTMLH1Component, eListeners); // console.dir(HTMLComponent)
        // Add connectedCallback method appending children if shadow is false...


        if (!shadow) {
          _HTMLH1Component.prototype.connectedCallback = function () {
            self.appendChild(h1);
          };
        } // Return component to the caller...


        return _HTMLH1Component;
      }
    }]);

    return H1;
  }();

  _defineProperty(H1, "_tempLiteral", ":host {\n                          background-color: black;\n                          border-radius: 5%;\n                        }");
  /***/

},
/* 175 */

/***/
function (module, __webpack_exports__, __webpack_require__) {
  ;

  __webpack_require__.r(__webpack_exports__);
  /* harmony export (binding) */


  __webpack_require__.d(__webpack_exports__, "H2", function () {
    return H2;
  });
  /* harmony import */


  var _Utilities_helpers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(4);
  /* harmony import */


  var _Utilities_data__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(5);
  /* harmony import */


  var _Events__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(37);
  /* harmony import */


  var _CSS__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(43);
  /* harmony import */


  var _Form_Node__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(35);

  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  function _defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    return Constructor;
  }

  function _defineProperty(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }

    return obj;
  }
  /*
  ** H2.js
  **
  ** H2.js is an extensible HTML5 Web Component wrapper, built around the H2
  ** element. It's aim is in providing an h2 element that is able to be
  ** extended via the v1 web components api...
  **
  ** Eric James Foster, Fostware LLC, MIT License.
  ***/
  // Get utilities...
  // Get data...
  // Get Events...
  // Get CSS...
  // Get Node class...
  // Globalize common utility functions...


  var dir = console.dir;
  var log = _Utilities_helpers__WEBPACK_IMPORTED_MODULE_0__["log"];
  var el = _Utilities_helpers__WEBPACK_IMPORTED_MODULE_0__["el"];
  var dom = _Utilities_helpers__WEBPACK_IMPORTED_MODULE_0__["dom"];

  var H2 =
  /*#__PURE__*/
  function () {
    function H2() {
      _classCallCheck(this, H2);
    }

    _createClass(H2, null, [{
      key: "_appendStyleNode",
      // A CSS template literal, holding default styles for an h2...
      // Static method for appending child nodes to parent elements...
      value: function _appendStyleNode(root, child) {
        return root.appendChild(_Form_Node__WEBPACK_IMPORTED_MODULE_4__["Node"].createNode(child()));
      } // Static method for defining a flare h2 element...

    }, {
      key: "createComponent",
      value: function createComponent() {
        var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        var template = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false; // log('props', ['orange', 'bold'])
        // dir(props)
        // Declarations..

        var _HTMLH2Component,
            eListeners = [],
            customProps = [],
            shadowBool,
            shadow = props.shadow,
            h2,
            self,
            obj;
        /* Doing some finaglery with the native-shim and HTMLElement object.  This will
        be necessary until web components are fully supported in all browsers... */


        window.useNativeShim = false;
        window.HTMLElement = window._HTMLElement; // Get attribute names and Listeners...

        if (props) {
          obj = _Utilities_helpers__WEBPACK_IMPORTED_MODULE_0__["processData"](_Utilities_helpers__WEBPACK_IMPORTED_MODULE_0__["propsArray"](props)); // Store attribute and Listener pairs...

          customProps = obj.props;
          eListeners = obj.eventListeners;
        } // Create an HTMLH2Element...


        h2 = document.createElement('h2'); // Some default settings for h2 elements...
        // Set flare identifier flag..

        h2.flare = true; // Pass props from flare component declaration on to the inner h2 el...

        for (var _i = 0, _Object$keys = Object.keys(props); _i < _Object$keys.length; _i++) {
          var key = _Object$keys[_i]; // Check all keys in h2 el object...

          if (key in h2) {
            // Pass on the ones that match...
            // log(`${key} in h2`, ['yellow', 'bold'])
            h2["".concat(key)] = props["".concat(key)]; // Or if they are style properties...,
          } else if (key in h2.style) {
            // log(`${key} in h2`, ['pink', 'bold'])
            // Put them here...
            h2.style["".concat(key)] = props["".concat(key)];
          }
        } // Check for 'content' attribute,


        if ('content' in props) {
          h2.textContent = props.content; // h2.style.margin = '5'
        } // The h2 component element's constructor definition...


        _HTMLH2Component = function HTMLH2Component() {
          var shadowRoot; // Construct an element, store as self...

          self = Reflect.construct(HTMLElement, [], _HTMLH2Component);

          if (shadow) {
            // Create shadow root...
            shadowRoot = self.attachShadow({
              mode: 'open'
            }); // Append to shadow root...

            shadowRoot.appendChild(h2); // Create a node from the template function, and append to shadowRoot....

            H2._appendStyleNode(shadowRoot, template);
          } // Return constructor...


          return self;
        }; // Add superclass prototype...


        _HTMLH2Component.prototype = Object.create(HTMLH2Element.prototype); // Add constructor...

        _HTMLH2Component.prototype.constructor = _HTMLH2Component; // Register event listener methods..

        _Events__WEBPACK_IMPORTED_MODULE_2__["Events"].registerCallbacks(_HTMLH2Component, eListeners); // console.dir(HTMLComponent)
        // Add connectedCallback method appending children if shadow is false...


        if (!shadow) {
          _HTMLH2Component.prototype.connectedCallback = function () {
            self.appendChild(h2);
          };
        } // Return component to the caller...


        return _HTMLH2Component;
      }
    }]);

    return H2;
  }();

  _defineProperty(H2, "_tempLiteral", ":host {\n\n                        }");
  /***/

},
/* 176 */

/***/
function (module, __webpack_exports__, __webpack_require__) {
  ;

  __webpack_require__.r(__webpack_exports__);
  /* harmony export (binding) */


  __webpack_require__.d(__webpack_exports__, "H3", function () {
    return H3;
  });
  /* harmony import */


  var _Utilities_helpers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(4);
  /* harmony import */


  var _Utilities_data__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(5);
  /* harmony import */


  var _Events__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(37);
  /* harmony import */


  var _CSS__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(43);
  /* harmony import */


  var _Form_Node__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(35);

  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  function _defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    return Constructor;
  }

  function _defineProperty(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }

    return obj;
  }
  /*
  ** H3.js
  **
  ** H3.js is an extensible HTML5 Web Component wrapper, built around the H3
  ** element. It's aim is in providing an h3 element that is able to be
  ** extended via the v1 web components api...
  **
  ** Eric James Foster, Fostware LLC, MIT License.
  ***/
  // Get utilities...
  // Get data...
  // Get Events...
  // Get CSS...
  // Get Node class...
  // Globalize common utility functions...


  var dir = console.dir;
  var log = _Utilities_helpers__WEBPACK_IMPORTED_MODULE_0__["log"];
  var el = _Utilities_helpers__WEBPACK_IMPORTED_MODULE_0__["el"];
  var dom = _Utilities_helpers__WEBPACK_IMPORTED_MODULE_0__["dom"];

  var H3 =
  /*#__PURE__*/
  function () {
    function H3() {
      _classCallCheck(this, H3);
    }

    _createClass(H3, null, [{
      key: "_appendStyleNode",
      // A CSS template literal, holding default styles for an h3...
      // Static method for appending child nodes to parent elements...
      value: function _appendStyleNode(root, child) {
        return root.appendChild(_Form_Node__WEBPACK_IMPORTED_MODULE_4__["Node"].createNode(child()));
      } // Static method for defining a flare h3 element...

    }, {
      key: "createComponent",
      value: function createComponent() {
        var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        var template = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false; // log('props', ['orange', 'bold'])
        // dir(props)
        // Declarations..

        var _HTMLH3Component,
            eListeners = [],
            customProps = [],
            shadowBool,
            shadow = props.shadow,
            h3,
            self,
            obj;
        /* Doing some finaglery with the native-shim and HTMLElement object.  This will
        be necessary until web components are fully supported in all browsers... */


        window.useNativeShim = false;
        window.HTMLElement = window._HTMLElement; // Get attribute names and Listeners...

        if (props) {
          obj = _Utilities_helpers__WEBPACK_IMPORTED_MODULE_0__["processData"](_Utilities_helpers__WEBPACK_IMPORTED_MODULE_0__["propsArray"](props)); // Store attribute and Listener pairs...

          customProps = obj.props;
          eListeners = obj.eventListeners;
        } // Create an HTMLH3Element...


        h3 = document.createElement('h3'); // Some default settings for h3 elements...
        // Set flare identifier flag..

        h3.flare = true; // Pass props from flare component declaration on to the inner h3 el...

        for (var _i = 0, _Object$keys = Object.keys(props); _i < _Object$keys.length; _i++) {
          var key = _Object$keys[_i]; // Check all keys in h3 el object...

          if (key in h3) {
            // Pass on the ones that match...
            // log(`${key} in h3`, ['yellow', 'bold'])
            h3["".concat(key)] = props["".concat(key)]; // Or if they are style properties...,
          } else if (key in h3.style) {
            // log(`${key} in h3`, ['pink', 'bold'])
            // Put them here...
            h3.style["".concat(key)] = props["".concat(key)];
          }
        } // Check for 'content' attribute,


        if ('content' in props) {
          h3.textContent = props.content; // h3.style.margin = '5'
        } // The h3 component element's constructor definition...


        _HTMLH3Component = function HTMLH3Component() {
          var shadowRoot; // Construct an element, store as self...

          self = Reflect.construct(HTMLElement, [], _HTMLH3Component);

          if (shadow) {
            // Create shadow root...
            shadowRoot = self.attachShadow({
              mode: 'open'
            }); // Append to shadow root...

            shadowRoot.appendChild(h3); // Create a node from the template function, and append to shadowRoot....

            H3._appendStyleNode(shadowRoot, template);
          } // Return constructor...


          return self;
        }; // Add superclass prototype...


        _HTMLH3Component.prototype = Object.create(HTMLH3Element.prototype); // Add constructor...

        _HTMLH3Component.prototype.constructor = _HTMLH3Component; // Register event listener methods..

        _Events__WEBPACK_IMPORTED_MODULE_2__["Events"].registerCallbacks(_HTMLH3Component, eListeners); // console.dir(HTMLComponent)
        // Add connectedCallback method appending children if shadow is false...


        if (!shadow) {
          _HTMLH3Component.prototype.connectedCallback = function () {
            self.appendChild(h3);
          };
        } // Return component to the caller...


        return _HTMLH3Component;
      }
    }]);

    return H3;
  }();

  _defineProperty(H3, "_tempLiteral", ":host {\n\n                        }");
  /***/

},
/* 177 */

/***/
function (module, __webpack_exports__, __webpack_require__) {
  ;

  __webpack_require__.r(__webpack_exports__);
  /* harmony export (binding) */


  __webpack_require__.d(__webpack_exports__, "H4", function () {
    return H4;
  });
  /* harmony import */


  var _Utilities_helpers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(4);
  /* harmony import */


  var _Utilities_data__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(5);
  /* harmony import */


  var _Events__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(37);
  /* harmony import */


  var _CSS__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(43);
  /* harmony import */


  var _Form_Node__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(35);

  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  function _defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    return Constructor;
  }

  function _defineProperty(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }

    return obj;
  }
  /*
  ** H4.js
  **
  ** H4.js is an extensible HTML5 Web Component wrapper, built around the H4
  ** element. It's aim is in providing an h4 element that is able to be
  ** extended via the v1 web components api...
  **
  ** Eric James Foster, Fostware LLC, MIT License.
  ***/
  // Get utilities...
  // Get data...
  // Get Events...
  // Get CSS...
  // Get Node class...
  // Globalize common utility functions...


  var dir = console.dir;
  var log = _Utilities_helpers__WEBPACK_IMPORTED_MODULE_0__["log"];
  var el = _Utilities_helpers__WEBPACK_IMPORTED_MODULE_0__["el"];
  var dom = _Utilities_helpers__WEBPACK_IMPORTED_MODULE_0__["dom"];

  var H4 =
  /*#__PURE__*/
  function () {
    function H4() {
      _classCallCheck(this, H4);
    }

    _createClass(H4, null, [{
      key: "_appendStyleNode",
      // A CSS template literal, holding default styles for an h4...
      // Static method for appending child nodes to parent elements...
      value: function _appendStyleNode(root, child) {
        return root.appendChild(_Form_Node__WEBPACK_IMPORTED_MODULE_4__["Node"].createNode(child()));
      } // Static method for defining a flare h4 element...

    }, {
      key: "createComponent",
      value: function createComponent() {
        var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        var template = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false; // log('props', ['orange', 'bold'])
        // dir(props)
        // Declarations..

        var _HTMLH4Component,
            eListeners = [],
            customProps = [],
            shadowBool,
            shadow = props.shadow,
            h4,
            self,
            obj;
        /* Doing some finaglery with the native-shim and HTMLElement object.  This will
        be necessary until web components are fully supported in all browsers... */


        window.useNativeShim = false;
        window.HTMLElement = window._HTMLElement; // Get attribute names and Listeners...

        if (props) {
          obj = _Utilities_helpers__WEBPACK_IMPORTED_MODULE_0__["processData"](_Utilities_helpers__WEBPACK_IMPORTED_MODULE_0__["propsArray"](props)); // Store attribute and Listener pairs...

          customProps = obj.props;
          eListeners = obj.eventListeners;
        } // Create an HTMLH4Element...


        h4 = document.createElement('h4'); // Some default settings for h4 elements...
        // Set flare identifier flag..

        h4.flare = true; // Pass props from flare component declaration on to the inner h4 el...

        for (var _i = 0, _Object$keys = Object.keys(props); _i < _Object$keys.length; _i++) {
          var key = _Object$keys[_i]; // Check all keys in h4 el object...

          if (key in h4) {
            // Pass on the ones that match...
            // log(`${key} in h4`, ['yellow', 'bold'])
            h4["".concat(key)] = props["".concat(key)]; // Or if they are style properties...,
          } else if (key in h4.style) {
            // log(`${key} in h4`, ['pink', 'bold'])
            // Put them here...
            h4.style["".concat(key)] = props["".concat(key)];
          }
        } // Check for 'content' attribute,


        if ('content' in props) {
          h4.textContent = props.content; // h4.style.margin = '5'
        } // The h4 component element's constructor definition...


        _HTMLH4Component = function HTMLH4Component() {
          var shadowRoot; // Construct an element, store as self...

          self = Reflect.construct(HTMLElement, [], _HTMLH4Component);

          if (shadow) {
            // Create shadow root...
            shadowRoot = self.attachShadow({
              mode: 'open'
            }); // Append to shadow root...

            shadowRoot.appendChild(h4); // Create a node from the template function, and append to shadowRoot....

            H4._appendStyleNode(shadowRoot, template);
          } // Return constructor...


          return self;
        }; // Add superclass prototype...


        _HTMLH4Component.prototype = Object.create(HTMLH4Element.prototype); // Add constructor...

        _HTMLH4Component.prototype.constructor = _HTMLH4Component; // Register event listener methods..

        _Events__WEBPACK_IMPORTED_MODULE_2__["Events"].registerCallbacks(_HTMLH4Component, eListeners); // console.dir(HTMLComponent)
        // Add connectedCallback method appending children if shadow is false...


        if (!shadow) {
          _HTMLH4Component.prototype.connectedCallback = function () {
            self.appendChild(h4);
          };
        } // Return component to the caller...


        return _HTMLH4Component;
      }
    }]);

    return H4;
  }();

  _defineProperty(H4, "_tempLiteral", ":host {\n\n                        }");
  /***/

},
/* 178 */

/***/
function (module, __webpack_exports__, __webpack_require__) {
  ;

  __webpack_require__.r(__webpack_exports__);
  /* harmony export (binding) */


  __webpack_require__.d(__webpack_exports__, "H5", function () {
    return H5;
  });
  /* harmony import */


  var _Utilities_helpers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(4);
  /* harmony import */


  var _Utilities_data__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(5);
  /* harmony import */


  var _Events__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(37);
  /* harmony import */


  var _CSS__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(43);
  /* harmony import */


  var _Form_Node__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(35);

  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  function _defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    return Constructor;
  }

  function _defineProperty(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }

    return obj;
  }
  /*
  ** H5.js
  **
  ** H5.js is an extensible HTML5 Web Component wrapper, built around the H5
  ** element. It's aim is in providing an h5 element that is able to be
  ** extended via the v1 web components api...
  **
  ** Eric James Foster, Fostware LLC, MIT License.
  ***/
  // Get utilities...
  // Get data...
  // Get Events...
  // Get CSS...
  // Get Node class...
  // Globalize common utility functions...


  var dir = console.dir;
  var log = _Utilities_helpers__WEBPACK_IMPORTED_MODULE_0__["log"];
  var el = _Utilities_helpers__WEBPACK_IMPORTED_MODULE_0__["el"];
  var dom = _Utilities_helpers__WEBPACK_IMPORTED_MODULE_0__["dom"];

  var H5 =
  /*#__PURE__*/
  function () {
    function H5() {
      _classCallCheck(this, H5);
    }

    _createClass(H5, null, [{
      key: "_appendStyleNode",
      // A CSS template literal, holding default styles for an h5...
      // Static method for appending child nodes to parent elements...
      value: function _appendStyleNode(root, child) {
        return root.appendChild(_Form_Node__WEBPACK_IMPORTED_MODULE_4__["Node"].createNode(child()));
      } // Static method for defining a flare h5 element...

    }, {
      key: "createComponent",
      value: function createComponent() {
        var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        var template = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false; // log('props', ['orange', 'bold'])
        // dir(props)
        // Declarations..

        var _HTMLH5Component,
            eListeners = [],
            customProps = [],
            shadowBool,
            shadow = props.shadow,
            h5,
            self,
            obj;
        /* Doing some finaglery with the native-shim and HTMLElement object.  This will
        be necessary until web components are fully supported in all browsers... */


        window.useNativeShim = false;
        window.HTMLElement = window._HTMLElement; // Get attribute names and Listeners...

        if (props) {
          obj = _Utilities_helpers__WEBPACK_IMPORTED_MODULE_0__["processData"](_Utilities_helpers__WEBPACK_IMPORTED_MODULE_0__["propsArray"](props)); // Store attribute and Listener pairs...

          customProps = obj.props;
          eListeners = obj.eventListeners;
        } // Create an HTMLH5Element...


        h5 = document.createElement('h5'); // Some default settings for h5 elements...
        // Set flare identifier flag..

        h5.flare = true; // Pass props from flare component declaration on to the inner h5 el...

        for (var _i = 0, _Object$keys = Object.keys(props); _i < _Object$keys.length; _i++) {
          var key = _Object$keys[_i]; // Check all keys in h5 el object...

          if (key in h5) {
            // Pass on the ones that match...
            // log(`${key} in h5`, ['yellow', 'bold'])
            h5["".concat(key)] = props["".concat(key)]; // Or if they are style properties...,
          } else if (key in h5.style) {
            // log(`${key} in h5`, ['pink', 'bold'])
            // Put them here...
            h5.style["".concat(key)] = props["".concat(key)];
          }
        } // Check for 'content' attribute,


        if ('content' in props) {
          h5.textContent = props.content; // h5.style.margin = '5'
        } // The h5 component element's constructor definition...


        _HTMLH5Component = function HTMLH5Component() {
          var shadowRoot; // Construct an element, store as self...

          self = Reflect.construct(HTMLElement, [], _HTMLH5Component);

          if (shadow) {
            // Create shadow root...
            shadowRoot = self.attachShadow({
              mode: 'open'
            }); // Append to shadow root...

            shadowRoot.appendChild(h5); // Create a node from the template function, and append to shadowRoot....

            H5._appendStyleNode(shadowRoot, template);
          } // Return constructor...


          return self;
        }; // Add superclass prototype...


        _HTMLH5Component.prototype = Object.create(HTMLH5Element.prototype); // Add constructor...

        _HTMLH5Component.prototype.constructor = _HTMLH5Component; // Register event listener methods..

        _Events__WEBPACK_IMPORTED_MODULE_2__["Events"].registerCallbacks(_HTMLH5Component, eListeners); // console.dir(HTMLComponent)
        // Add connectedCallback method appending children if shadow is false...


        if (!shadow) {
          _HTMLH5Component.prototype.connectedCallback = function () {
            self.appendChild(h5);
          };
        } // Return component to the caller...


        return _HTMLH5Component;
      }
    }]);

    return H5;
  }();

  _defineProperty(H5, "_tempLiteral", ":host {\n\n                        }");
  /***/

},
/* 179 */

/***/
function (module, __webpack_exports__, __webpack_require__) {
  ;

  __webpack_require__.r(__webpack_exports__);
  /* harmony export (binding) */


  __webpack_require__.d(__webpack_exports__, "H6", function () {
    return H6;
  });
  /* harmony import */


  var _Utilities_helpers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(4);
  /* harmony import */


  var _Utilities_data__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(5);
  /* harmony import */


  var _Events__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(37);
  /* harmony import */


  var _CSS__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(43);
  /* harmony import */


  var _Form_Node__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(35);

  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  function _defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    return Constructor;
  }

  function _defineProperty(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }

    return obj;
  }
  /*
  ** H6.js
  **
  ** H6.js is an extensible HTML5 Web Component wrapper, built around the H6
  ** element. It's aim is in providing an h6 element that is able to be
  ** extended via the v1 web components api...
  **
  ** Eric James Foster, Fostware LLC, MIT License.
  ***/
  // Get utilities...
  // Get data...
  // Get Events...
  // Get CSS...
  // Get Node class...
  // Globalize common utility functions...


  var dir = console.dir;
  var log = _Utilities_helpers__WEBPACK_IMPORTED_MODULE_0__["log"];
  var el = _Utilities_helpers__WEBPACK_IMPORTED_MODULE_0__["el"];
  var dom = _Utilities_helpers__WEBPACK_IMPORTED_MODULE_0__["dom"];

  var H6 =
  /*#__PURE__*/
  function () {
    function H6() {
      _classCallCheck(this, H6);
    }

    _createClass(H6, null, [{
      key: "_appendStyleNode",
      // A CSS template literal, holding default styles for an h6...
      // Static method for appending child nodes to parent elements...
      value: function _appendStyleNode(root, child) {
        return root.appendChild(_Form_Node__WEBPACK_IMPORTED_MODULE_4__["Node"].createNode(child()));
      } // Static method for defining a flare h6 element...

    }, {
      key: "createComponent",
      value: function createComponent() {
        var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        var template = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false; // log('props', ['orange', 'bold'])
        // dir(props)
        // Declarations..

        var _HTMLH6Component,
            eListeners = [],
            customProps = [],
            shadowBool,
            shadow = props.shadow,
            h6,
            self,
            obj;
        /* Doing some finaglery with the native-shim and HTMLElement object.  This will
        be necessary until web components are fully supported in all browsers... */


        window.useNativeShim = false;
        window.HTMLElement = window._HTMLElement; // Get attribute names and Listeners...

        if (props) {
          obj = _Utilities_helpers__WEBPACK_IMPORTED_MODULE_0__["processData"](_Utilities_helpers__WEBPACK_IMPORTED_MODULE_0__["propsArray"](props)); // Store attribute and Listener pairs...

          customProps = obj.props;
          eListeners = obj.eventListeners;
        } // Create an HTMLH6Element...


        h6 = document.createElement('h6'); // Some default settings for h6 elements...
        // Set flare identifier flag..

        h6.flare = true; // Pass props from flare component declaration on to the inner h6 el...

        for (var _i = 0, _Object$keys = Object.keys(props); _i < _Object$keys.length; _i++) {
          var key = _Object$keys[_i]; // Check all keys in h6 el object...

          if (key in h6) {
            // Pass on the ones that match...
            // log(`${key} in h6`, ['yellow', 'bold'])
            h6["".concat(key)] = props["".concat(key)]; // Or if they are style properties...,
          } else if (key in h6.style) {
            // log(`${key} in h6`, ['pink', 'bold'])
            // Put them here...
            h6.style["".concat(key)] = props["".concat(key)];
          }
        } // Check for 'content' attribute,


        if ('content' in props) {
          h6.textContent = props.content; // h6.style.margin = '5'
        } // The h6 component element's constructor definition...


        _HTMLH6Component = function HTMLH6Component() {
          var shadowRoot; // Construct an element, store as self...

          self = Reflect.construct(HTMLElement, [], _HTMLH6Component);

          if (shadow) {
            // Create shadow root...
            shadowRoot = self.attachShadow({
              mode: 'open'
            }); // Append to shadow root...

            shadowRoot.appendChild(h6); // Create a node from the template function, and append to shadowRoot....

            H6._appendStyleNode(shadowRoot, template);
          } // Return constructor...


          return self;
        }; // Add superclass prototype...


        _HTMLH6Component.prototype = Object.create(HTMLElement.prototype); // Add constructor...

        _HTMLH6Component.prototype.constructor = _HTMLH6Component; // Register event listener methods..

        _Events__WEBPACK_IMPORTED_MODULE_2__["Events"].registerCallbacks(_HTMLH6Component, eListeners); // console.dir(HTMLComponent)
        // Add connectedCallback method appending children if shadow is false...


        if (!shadow) {
          _HTMLH6Component.prototype.connectedCallback = function () {
            self.appendChild(h6);
          };
        } // Return component to the caller...


        return _HTMLH6Component;
      }
    }]);

    return H6;
  }();

  _defineProperty(H6, "_tempLiteral", ":host {\n\n                        }");
  /***/

},
/* 180 */

/***/
function (module, __webpack_exports__, __webpack_require__) {
  ;

  __webpack_require__.r(__webpack_exports__);
  /* harmony export (binding) */


  __webpack_require__.d(__webpack_exports__, "Header", function () {
    return Header;
  });
  /* harmony import */


  var _Utilities_helpers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(4);
  /* harmony import */


  var _Utilities_data__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(5);
  /* harmony import */


  var _Events__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(37);
  /* harmony import */


  var _CSS__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(43);
  /* harmony import */


  var _Form_Node__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(35);

  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  function _defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    return Constructor;
  }

  function _defineProperty(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }

    return obj;
  }
  /*
  ** Header.js
  **
  ** Header.js is an extensible HTML5 Web Component wrapper, built around the Header
  ** element. It's aim is in providing an header element that is able to be
  ** extended via the v1 web components api...
  **
  ** Eric James Foster, Fostware LLC, MIT License.
  ***/
  // Get utilities...
  // Get data...
  // Get Events...
  // Get CSS...
  // Get Node class...
  // Globalize common utility functions...


  var dir = console.dir;
  var log = _Utilities_helpers__WEBPACK_IMPORTED_MODULE_0__["log"];
  var el = _Utilities_helpers__WEBPACK_IMPORTED_MODULE_0__["el"];
  var dom = _Utilities_helpers__WEBPACK_IMPORTED_MODULE_0__["dom"];

  var Header =
  /*#__PURE__*/
  function () {
    function Header() {
      _classCallCheck(this, Header);
    }

    _createClass(Header, null, [{
      key: "_appendStyleNode",
      // A CSS template literal, holding default styles for an header...
      // Static method for appending child nodes to parent elements...
      value: function _appendStyleNode(root, child) {
        return root.appendChild(_Form_Node__WEBPACK_IMPORTED_MODULE_4__["Node"].createNode(child()));
      } // Static method for defining a flare header element...

    }, {
      key: "createComponent",
      value: function createComponent() {
        var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        var template = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false; // log('props', ['orange', 'bold'])
        // dir(props)
        // Declarations..

        var _HTMLHeaderComponent,
            eListeners = [],
            customProps = [],
            shadowBool,
            shadow = props.shadow,
            header,
            self,
            obj;
        /* Doing some finaglery with the native-shim and HTMLElement object.  This will
        be necessary until web components are fully supported in all browsers... */


        window.useNativeShim = false;
        window.HTMLElement = window._HTMLElement; // Get attribute names and Listeners...

        if (props) {
          obj = _Utilities_helpers__WEBPACK_IMPORTED_MODULE_0__["processData"](_Utilities_helpers__WEBPACK_IMPORTED_MODULE_0__["propsArray"](props)); // Store attribute and Listener pairs...

          customProps = obj.props;
          eListeners = obj.eventListeners;
        } // Create an HTMLHeaderElement...


        header = document.createElement('header'); // Some default settings for header elements...
        // Set flare identifier flag..

        header.flare = true; // Pass props from flare component declaration on to the inner header el...

        for (var _i = 0, _Object$keys = Object.keys(props); _i < _Object$keys.length; _i++) {
          var key = _Object$keys[_i]; // Check all keys in header el object...

          if (key in header) {
            // Pass on the ones that match...
            // log(`${key} in header`, ['yellow', 'bold'])
            header["".concat(key)] = props["".concat(key)]; // Or if they are style properties...,
          } else if (key in header.style) {
            // log(`${key} in header`, ['pink', 'bold'])
            // Put them here...
            header.style["".concat(key)] = props["".concat(key)];
          }
        } // // Check for '-----' attribute,
        //     if ('-----' in props) {
        //       header.textContent = props.-----
        //       // header.style.margin = '5'
        //     }
        // The header component element's constructor definition...


        _HTMLHeaderComponent = function HTMLHeaderComponent() {
          var shadowRoot; // Construct an element, store as self...

          self = Reflect.construct(HTMLElement, [], _HTMLHeaderComponent);

          if (shadow) {
            // Create shadow root...
            shadowRoot = self.attachShadow({
              mode: 'open'
            }); // Append to shadow root...

            shadowRoot.appendChild(header); // Create a node from the template function, and append to shadowRoot....

            Header._appendStyleNode(shadowRoot, template);
          } // Return constructor...


          return self;
        }; // Add superclass prototype...


        _HTMLHeaderComponent.prototype = Object.create(HTMLHeaderElement.prototype); // Add constructor...

        _HTMLHeaderComponent.prototype.constructor = _HTMLHeaderComponent; // Register event listener methods..

        _Events__WEBPACK_IMPORTED_MODULE_2__["Events"].registerCallbacks(_HTMLHeaderComponent, eListeners); // console.dir(HTMLComponent)
        // Add connectedCallback method appending children if shadow is false...


        if (!shadow) {
          _HTMLHeaderComponent.prototype.connectedCallback = function () {
            self.appendChild(header);
          };
        } // Return component to the caller...


        return _HTMLHeaderComponent;
      }
    }]);

    return Header;
  }();

  _defineProperty(Header, "_tempLiteral", ":host {\n\n                        }");
  /***/

},
/* 181 */

/***/
function (module, __webpack_exports__, __webpack_require__) {
  ;

  __webpack_require__.r(__webpack_exports__);
  /* harmony export (binding) */


  __webpack_require__.d(__webpack_exports__, "Input", function () {
    return Input;
  });
  /* harmony import */


  var _Utilities_helpers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(4);
  /* harmony import */


  var _Utilities_data__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(5);
  /* harmony import */


  var _Events__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(37);
  /* harmony import */


  var _CSS__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(43);
  /* harmony import */


  var _Form_Node__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(35);

  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  function _defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    return Constructor;
  }

  function _defineProperty(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }

    return obj;
  }
  /*
  ** Input.js
  **
  ** Input.js is an extensible HTML5 Web Component wrapper, built around the Input
  ** element. It's aim is in providing an input element that is able to be
  ** extended via the v1 web components api...
  **
  ** Eric James Foster, Fostware LLC, MIT License.
  ***/
  // Get utilities...
  // Get data...
  // Get Events...
  // Get CSS...
  // Get Node class...
  // Globalize common utility functions...


  var dir = console.dir;
  var log = _Utilities_helpers__WEBPACK_IMPORTED_MODULE_0__["log"];
  var el = _Utilities_helpers__WEBPACK_IMPORTED_MODULE_0__["el"];
  var dom = _Utilities_helpers__WEBPACK_IMPORTED_MODULE_0__["dom"];

  var Input =
  /*#__PURE__*/
  function () {
    function Input() {
      _classCallCheck(this, Input);
    }

    _createClass(Input, null, [{
      key: "_appendStyleNode",
      // A CSS template literal, holding default styles for an input...
      // Static method for appending child nodes to parent elements...
      value: function _appendStyleNode(root, child) {
        return root.appendChild(_Form_Node__WEBPACK_IMPORTED_MODULE_4__["Node"].createNode(child()));
      } // Static method for defining a flare input element...

    }, {
      key: "createComponent",
      value: function createComponent() {
        var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        var template = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
        log('props', ['orange', 'bold']);
        dir(props); // Declarations..

        var _HTMLInputComponent,
            eListeners = [],
            customProps = [],
            shadowBool,
            shadow = props.shadow,
            input,
            self,
            obj;
        /* Doing some finaglery with the native-shim and HTMLElement object.  This will
        be necessary until web components are fully supported in all browsers... */


        window.useNativeShim = false;
        window.HTMLElement = window._HTMLElement; // Get attribute names and Listeners...

        if (props) {
          obj = _Utilities_helpers__WEBPACK_IMPORTED_MODULE_0__["processData"](_Utilities_helpers__WEBPACK_IMPORTED_MODULE_0__["propsArray"](props)); // Store attribute and Listener pairs...

          customProps = obj.props;
          eListeners = obj.eventListeners;
        } // Create an HTMLInputElement...


        input = document.createElement('input'); // Some default settings for input elements...
        // Set flare identifier flag..
        // input.flare = true
        // if (props.type == 'text') {
        //
        // }
        // Pass props from flare component declaration on to the inner input el...

        for (var _i = 0, _Object$keys = Object.keys(props); _i < _Object$keys.length; _i++) {
          var key = _Object$keys[_i]; // Check all keys in input el object...

          if (key in input) {
            // Pass on the ones that match...
            log("".concat(key, " in input"), ['yellow', 'bold']);
            input["".concat(key)] = props["".concat(key)]; // Or if they are style properties...,
          } else if (key in input.style) {
            log("".concat(key, " in input"), ['pink', 'bold']); // Put them here...

            input.style["".concat(key)] = props["".concat(key)];
          }
        } // The input component element's constructor definition...


        _HTMLInputComponent = function HTMLInputComponent() {
          var shadowRoot; // Construct an element, store as self...

          self = Reflect.construct(HTMLElement, [], _HTMLInputComponent);

          if (shadow) {
            // Create shadow root...
            shadowRoot = self.attachShadow({
              mode: 'open'
            }); // Append to shadow root...

            shadowRoot.appendChild(input); // Create a node from the template function, and append to shadowRoot....

            Input._appendStyleNode(shadowRoot, template);
          } // Return constructor...


          return self;
        }; // Add superclass prototype...


        _HTMLInputComponent.prototype = Object.create(HTMLInputElement.prototype); // Add constructor...

        _HTMLInputComponent.prototype.constructor = _HTMLInputComponent; // Register event listener methods..

        _Events__WEBPACK_IMPORTED_MODULE_2__["Events"].registerCallbacks(_HTMLInputComponent, eListeners); // console.dir(HTMLComponent)
        // Add connectedCallback method appending children if shadow is false...


        if (!shadow) {
          _HTMLInputComponent.prototype.connectedCallback = function () {
            log('Im Here', ['red', 'bold']);
            dir(self);

            if (self) {
              log('self', ['yellow', 'bold']);
              self.appendChild(input); // Add a few default styles for the outer root element....

              self.style.width = '100%';
              self.style.paddingLeft = '10px';
              self.style.paddingRight = '10px';
              self.style.marginLeft = 'auto';
              self.style.marginRight = 'auto';
            } else if (this) {
              log('this', ['yellow', 'bold']);
              dir(this);
              dir(input);
              this.appendChild(input); // Add a few default styles for the outer root element....

              this.style.width = '100%';
              this.style.paddingLeft = '10px';
              this.style.paddingRight = '10px';
              this.style.marginLeft = 'auto';
              this.style.marginRight = 'auto';
            } else {
              throw Error('ConnectedCallbackError: A problem has occured while appending component children.');
            }
          };
        } // Return component to the caller...


        return _HTMLInputComponent;
      }
    }]);

    return Input;
  }();

  _defineProperty(Input, "_textLiteral", ":host {\n                          background-color: black;\n                          border-radius: 5%;\n                        }");
  /***/

},
/* 182 */

/***/
function (module, __webpack_exports__, __webpack_require__) {
  ;

  __webpack_require__.r(__webpack_exports__);
  /* harmony export (binding) */


  __webpack_require__.d(__webpack_exports__, "Paragraph", function () {
    return Paragraph;
  });
  /* harmony import */


  var _Utilities_helpers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(4);
  /* harmony import */


  var _Utilities_data__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(5);
  /* harmony import */


  var _Events__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(37);
  /* harmony import */


  var _CSS__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(43);
  /* harmony import */


  var _Form_Node__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(35);

  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  function _defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    return Constructor;
  }

  function _defineProperty(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }

    return obj;
  }
  /*
  ** Paragraph.js
  **
  ** Paragraph.js is an extensible HTML5 Web Component wrapper, built around the P
  ** element. It's aim is in providing a p element that is able to be
  ** extended via the v1 web components api...
  **
  ** Eric James Foster, Fostware LLC, MIT License.
  ***/
  // Get utilities...
  // Get data...
  // Get Events...
  // Get CSS...
  // Get Node class...
  // Globalize common utility functions...


  var dir = console.dir;
  var log = _Utilities_helpers__WEBPACK_IMPORTED_MODULE_0__["log"];
  var el = _Utilities_helpers__WEBPACK_IMPORTED_MODULE_0__["el"];
  var dom = _Utilities_helpers__WEBPACK_IMPORTED_MODULE_0__["dom"];

  var Paragraph =
  /*#__PURE__*/
  function () {
    function Paragraph() {
      _classCallCheck(this, Paragraph);
    }

    _createClass(Paragraph, null, [{
      key: "_appendStyleNode",
      // A CSS template literal, holding default styles for a p...
      // Static method for appending child nodes to parent elements...
      value: function _appendStyleNode(root, child) {
        return root.appendChild(_Form_Node__WEBPACK_IMPORTED_MODULE_4__["Node"].createNode(child()));
      } // Static method for defining a flare p element...

    }, {
      key: "createComponent",
      value: function createComponent() {
        var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        var template = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false; // Declarations..

        var _HTMLPGraphComponent,
            eListeners = [],
            customProps = [],
            shadowBool,
            shadow = props.shadow,
            p,
            self,
            obj;
        /* Doing some finaglery with the native-shim and HTMLElement object.  This will
        be necessary until web components are fully supported in all browsers... */


        window.useNativeShim = false;
        window.HTMLElement = window._HTMLElement; // Get attribute names and Listeners...

        if (props) {
          obj = _Utilities_helpers__WEBPACK_IMPORTED_MODULE_0__["processData"](_Utilities_helpers__WEBPACK_IMPORTED_MODULE_0__["propsArray"](props)); // Store attribute and Listener pairs...

          customProps = obj.props;
          eListeners = obj.eventListeners;
        } // Create an HTMLPElement...


        p = document.createElement('p'); // Some default settings for p elements...
        // Set flare identifier flag..
        // p.flare = true
        // if (props.type == 'text') {
        //
        // }
        // Pass props from flare component declaration on to the inner p el...

        for (var _i = 0, _Object$keys = Object.keys(props); _i < _Object$keys.length; _i++) {
          var key = _Object$keys[_i]; // Check all keys in p el object...

          if (key in p) {
            // Pass on the ones that match...
            log("".concat(key, " in p"), ['yellow', 'bold']);
            p["".concat(key)] = props["".concat(key)]; // Or if they are style properties...,
          } else if (key in p.style) {
            log("".concat(key, " in p"), ['pink', 'bold']); // Put them here...

            p.style["".concat(key)] = props["".concat(key)];
          }
        } // // Check for 'content' attribute,
        //     if ('content' in props) {
        //       p.textContent = props.content
        //     }
        // The p component element's constructor definition...


        _HTMLPGraphComponent = function HTMLPGraphComponent() {
          var shadowRoot; // Construct an element, store as self...

          self = Reflect.construct(HTMLElement, [], _HTMLPGraphComponent);

          if (shadow) {
            // Create shadow root...
            shadowRoot = self.attachShadow({
              mode: 'open'
            }); // Append to shadow root...

            shadowRoot.appendChild(p); // Create a node from the template function, and append to shadowRoot....

            Paragraph._appendStyleNode(shadowRoot, template);
          } // Return constructor...


          return self;
        }; // Add superclass prototype...


        _HTMLPGraphComponent.prototype = Object.create(HTMLParagraphElement.prototype); // Add constructor...

        _HTMLPGraphComponent.prototype.constructor = _HTMLPGraphComponent; // Register event listener methods..

        _Events__WEBPACK_IMPORTED_MODULE_2__["Events"].registerCallbacks(_HTMLPGraphComponent, eListeners); // console.dir(HTMLComponent)
        // Add connectedCallback method appending children if shadow is false...


        if (!shadow) {
          _HTMLPGraphComponent.prototype.connectedCallback = function () {
            self.appendChild(p);
          };
        } // Return component to the caller...


        return _HTMLPGraphComponent;
      }
    }]);

    return Paragraph;
  }();

  _defineProperty(Paragraph, "_textLiteral", ":host {\n\n                        }");
  /***/

},
/* 183 */

/***/
function (module, __webpack_exports__, __webpack_require__) {
  ;

  __webpack_require__.r(__webpack_exports__);
  /* harmony export (binding) */


  __webpack_require__.d(__webpack_exports__, "Section", function () {
    return Section;
  });
  /* harmony import */


  var _Utilities_helpers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(4);
  /* harmony import */


  var _Utilities_data__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(5);
  /* harmony import */


  var _Events__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(37);
  /* harmony import */


  var _CSS__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(43);
  /* harmony import */


  var _Form_Node__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(35);

  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  function _defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    return Constructor;
  }

  function _defineProperty(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }

    return obj;
  }
  /*
  ** Section.js
  **
  ** Section.js is an extensible HTML5 Web Component wrapper, built around the Section
  ** element. It's aim is in providing an section element that is able to be
  ** extended via the v1 web components api...
  **
  ** Eric James Foster, Fostware LLC, MIT License.
  ***/
  // Get utilities...
  // Get data...
  // Get Events...
  // Get CSS...
  // Get Node class...
  // Globalize common utility functions...


  var dir = console.dir;
  var log = _Utilities_helpers__WEBPACK_IMPORTED_MODULE_0__["log"];
  var el = _Utilities_helpers__WEBPACK_IMPORTED_MODULE_0__["el"];
  var dom = _Utilities_helpers__WEBPACK_IMPORTED_MODULE_0__["dom"];

  var Section =
  /*#__PURE__*/
  function () {
    function Section() {
      _classCallCheck(this, Section);
    }

    _createClass(Section, null, [{
      key: "_appendStyleNode",
      // A CSS template literal, holding default styles for an section...
      // Static method for appending child nodes to parent elements...
      value: function _appendStyleNode(root, child) {
        return root.appendChild(_Form_Node__WEBPACK_IMPORTED_MODULE_4__["Node"].createNode(child()));
      } // Static method for defining a flare section element...

    }, {
      key: "createComponent",
      value: function createComponent() {
        var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        var template = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false; // log('props', ['orange', 'bold'])
        // dir(props)
        // Declarations..

        var _HTMLSectionComponent,
            eListeners = [],
            customProps = [],
            shadowBool,
            shadow = props.shadow,
            section,
            self,
            obj;
        /* Doing some finaglery with the native-shim and HTMLElement object.  This will
        be necessary until web components are fully supported in all browsers... */


        window.useNativeShim = false;
        window.HTMLElement = window._HTMLElement; // Get attribute names and Listeners...

        if (props) {
          obj = _Utilities_helpers__WEBPACK_IMPORTED_MODULE_0__["processData"](_Utilities_helpers__WEBPACK_IMPORTED_MODULE_0__["propsArray"](props)); // Store attribute and Listener pairs...

          customProps = obj.props;
          eListeners = obj.eventListeners;
        } // Create an HTMLSectionElement...


        section = document.createElement('section'); // Some default settings for section elements...
        // Set flare identifier flag..

        section.flare = true; // Pass props from flare component declaration on to the inner section el...

        for (var _i = 0, _Object$keys = Object.keys(props); _i < _Object$keys.length; _i++) {
          var key = _Object$keys[_i]; // Check all keys in section el object...

          if (key in section) {
            // Pass on the ones that match...
            // log(`${key} in section`, ['yellow', 'bold'])
            section["".concat(key)] = props["".concat(key)]; // Or if they are style properties...,
          } else if (key in section.style) {
            // log(`${key} in section`, ['pink', 'bold'])
            // Put them here...
            section.style["".concat(key)] = props["".concat(key)];
          }
        } // Check for 'content' attribute,


        if ('content' in props) {
          section.textContent = props.content; // section.style.margin = '5'
        } // The section component element's constructor definition...


        _HTMLSectionComponent = function HTMLSectionComponent() {
          var shadowRoot; // Construct an element, store as self...

          self = Reflect.construct(HTMLElement, [], _HTMLSectionComponent);

          if (shadow) {
            // Create shadow root...
            shadowRoot = self.attachShadow({
              mode: 'open'
            }); // Append to shadow root...

            shadowRoot.appendChild(section); // Create a node from the template function, and append to shadowRoot....

            Section._appendStyleNode(shadowRoot, template);
          } // Return constructor...


          return self;
        }; // Add superclass prototype...


        _HTMLSectionComponent.prototype = Object.create(HTMLSectionElement.prototype); // Add constructor...

        _HTMLSectionComponent.prototype.constructor = _HTMLSectionComponent; // Register event listener methods..

        _Events__WEBPACK_IMPORTED_MODULE_2__["Events"].registerCallbacks(_HTMLSectionComponent, eListeners); // console.dir(HTMLComponent)
        // Add connectedCallback method appending children if shadow is false...


        if (!shadow) {
          _HTMLSectionComponent.prototype.connectedCallback = function () {
            self.appendChild(section);
          };
        } // Return component to the caller...


        return _HTMLSectionComponent;
      }
    }]);

    return Section;
  }();

  _defineProperty(Section, "_tempLiteral", ":host {\n\n                        }");
  /***/

},
/* 184 */

/***/
function (module, __webpack_exports__, __webpack_require__) {
  ;

  __webpack_require__.r(__webpack_exports__);
  /* harmony export (binding) */


  __webpack_require__.d(__webpack_exports__, "Span", function () {
    return Span;
  });
  /* harmony import */


  var _Utilities_helpers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(4);
  /* harmony import */


  var _Utilities_data__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(5);
  /* harmony import */


  var _Events__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(37);
  /* harmony import */


  var _CSS__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(43);
  /* harmony import */


  var _Form_Node__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(35);

  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  function _defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    return Constructor;
  }

  function _defineProperty(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }

    return obj;
  }
  /*
  ** Span.js
  **
  ** Span.js is an extensible HTML5 Web Component wrapper, built around the Span
  ** element. It's aim is in providing an span element that is able to be
  ** extended via the v1 web components api...
  **
  ** Eric James Foster, Fostware LLC, MIT License.
  ***/
  // Get utilities...
  // Get data...
  // Get Events...
  // Get CSS...
  // Get Node class...
  // Globalize common utility functions...


  var dir = console.dir;
  var log = _Utilities_helpers__WEBPACK_IMPORTED_MODULE_0__["log"];
  var el = _Utilities_helpers__WEBPACK_IMPORTED_MODULE_0__["el"];
  var dom = _Utilities_helpers__WEBPACK_IMPORTED_MODULE_0__["dom"];

  var Span =
  /*#__PURE__*/
  function () {
    function Span() {
      _classCallCheck(this, Span);
    }

    _createClass(Span, null, [{
      key: "_appendStyleNode",
      // A CSS template literal, holding default styles for an span...
      // Static method for appending child nodes to parent elements...
      value: function _appendStyleNode(root, child) {
        return root.appendChild(_Form_Node__WEBPACK_IMPORTED_MODULE_4__["Node"].createNode(child()));
      } // Static method for defining a flare span element...

    }, {
      key: "createComponent",
      value: function createComponent() {
        var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        var template = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false; // log('props', ['orange', 'bold'])
        // dir(props)
        // Declarations..

        var _HTMLSpanComponent,
            eListeners = [],
            customProps = [],
            shadowBool,
            shadow = props.shadow,
            span,
            self,
            obj;
        /* Doing some finaglery with the native-shim and HTMLElement object.  This will
        be necessary until web components are fully supported in all browsers... */


        window.useNativeShim = false;
        window.HTMLElement = window._HTMLElement; // Get attribute names and Listeners...

        if (props) {
          obj = _Utilities_helpers__WEBPACK_IMPORTED_MODULE_0__["processData"](_Utilities_helpers__WEBPACK_IMPORTED_MODULE_0__["propsArray"](props)); // Store attribute and Listener pairs...

          customProps = obj.props;
          eListeners = obj.eventListeners;
        } // Create an HTMLSpanElement...


        span = document.createElement('span'); // Some default settings for span elements...
        // Set flare identifier flag..

        span.flare = true; // Pass props from flare component declaration on to the inner span el...

        for (var _i = 0, _Object$keys = Object.keys(props); _i < _Object$keys.length; _i++) {
          var key = _Object$keys[_i]; // Check all keys in span el object...

          if (key in span) {
            // Pass on the ones that match...
            // log(`${key} in span`, ['yellow', 'bold'])
            span["".concat(key)] = props["".concat(key)]; // Or if they are style properties...,
          } else if (key in span.style) {
            // log(`${key} in span`, ['pink', 'bold'])
            // Put them here...
            span.style["".concat(key)] = props["".concat(key)];
          }
        } // Check for 'content' attribute,


        if ('content' in props) {
          span.textContent = props.content; // span.style.margin = '5'
        } // The span component element's constructor definition...


        _HTMLSpanComponent = function HTMLSpanComponent() {
          var shadowRoot; // Construct an element, store as self...

          self = Reflect.construct(HTMLElement, [], _HTMLSpanComponent);

          if (shadow) {
            // Create shadow root...
            shadowRoot = self.attachShadow({
              mode: 'open'
            }); // Append to shadow root...

            shadowRoot.appendChild(span); // Create a node from the template function, and append to shadowRoot....

            Span._appendStyleNode(shadowRoot, template);
          } // Return constructor...


          return self;
        }; // Add superclass prototype...


        _HTMLSpanComponent.prototype = Object.create(HTMLSpanElement.prototype); // Add constructor...

        _HTMLSpanComponent.prototype.constructor = _HTMLSpanComponent; // Register event listener methods..

        _Events__WEBPACK_IMPORTED_MODULE_2__["Events"].registerCallbacks(_HTMLSpanComponent, eListeners); // console.dir(HTMLComponent)
        // Add connectedCallback method appending children if shadow is false...


        if (!shadow) {
          _HTMLSpanComponent.prototype.connectedCallback = function () {
            self.appendChild(span);
          };
        } // Return component to the caller...


        return _HTMLSpanComponent;
      }
    }]);

    return Span;
  }();

  _defineProperty(Span, "_tempLiteral", ":host {\n\n                        }");
  /***/

},
/* 185 */

/***/
function (module, __webpack_exports__, __webpack_require__) {
  ;

  __webpack_require__.r(__webpack_exports__);
  /* harmony export (binding) */


  __webpack_require__.d(__webpack_exports__, "Table", function () {
    return Table;
  });
  /* harmony import */


  var _Utilities_helpers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(4);
  /* harmony import */


  var _Utilities_data__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(5);
  /* harmony import */


  var _Events__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(37);
  /* harmony import */


  var _CSS__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(43);
  /* harmony import */


  var _Form_Node__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(35);

  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  function _defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    return Constructor;
  }

  function _defineProperty(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }

    return obj;
  }
  /*
  ** Table.js
  **
  ** Table.js is an extensible HTML5 Web Component wrapper, built around the Table
  ** element. It's aim is in providing an table element that is able to be
  ** extended via the v1 web components api...
  **
  ** Eric James Foster, Fostware LLC, MIT License.
  ***/
  // Get utilities...
  // Get data...
  // Get Events...
  // Get CSS...
  // Get Node class...
  // Globalize common utility functions...


  var dir = console.dir;
  var log = _Utilities_helpers__WEBPACK_IMPORTED_MODULE_0__["log"];
  var el = _Utilities_helpers__WEBPACK_IMPORTED_MODULE_0__["el"];
  var dom = _Utilities_helpers__WEBPACK_IMPORTED_MODULE_0__["dom"];

  var Table =
  /*#__PURE__*/
  function () {
    function Table() {
      _classCallCheck(this, Table);
    }

    _createClass(Table, null, [{
      key: "_appendStyleNode",
      // A CSS template literal, holding default styles for an table...
      // Static method for appending child nodes to parent elements...
      value: function _appendStyleNode(root, child) {
        return root.appendChild(_Form_Node__WEBPACK_IMPORTED_MODULE_4__["Node"].createNode(child()));
      } // Static method for defining a flare table element...

    }, {
      key: "createComponent",
      value: function createComponent() {
        var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        var template = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false; // log('props', ['orange', 'bold'])
        // dir(props)
        // Declarations..

        var _HTMLTableComponent,
            eListeners = [],
            customProps = [],
            shadowBool,
            shadow = props.shadow,
            table,
            self,
            obj;
        /* Doing some finaglery with the native-shim and HTMLElement object.  This will
        be necessary until web components are fully supported in all browsers... */


        window.useNativeShim = false;
        window.HTMLElement = window._HTMLElement; // Get attribute names and Listeners...

        if (props) {
          obj = _Utilities_helpers__WEBPACK_IMPORTED_MODULE_0__["processData"](_Utilities_helpers__WEBPACK_IMPORTED_MODULE_0__["propsArray"](props)); // Store attribute and Listener pairs...

          customProps = obj.props;
          eListeners = obj.eventListeners;
        } // Create an HTMLTableElement...


        table = document.createElement('table'); // Some default settings for table elements...
        // Set flare identifier flag..

        table.flare = true; // Pass props from flare component declaration on to the inner table el...

        for (var _i = 0, _Object$keys = Object.keys(props); _i < _Object$keys.length; _i++) {
          var key = _Object$keys[_i]; // Check all keys in table el object...

          if (key in table) {
            // Pass on the ones that match...
            // log(`${key} in table`, ['yellow', 'bold'])
            table["".concat(key)] = props["".concat(key)]; // Or if they are style properties...,
          } else if (key in table.style) {
            // log(`${key} in table`, ['pink', 'bold'])
            // Put them here...
            table.style["".concat(key)] = props["".concat(key)];
          }
        } // // Check for '-----' attribute,
        //     if ('-----' in props) {
        //       table.textContent = props.-----
        //       // table.style.margin = '5'
        //     }
        // The table component element's constructor definition...


        _HTMLTableComponent = function HTMLTableComponent() {
          var shadowRoot; // Construct an element, store as self...

          self = Reflect.construct(HTMLElement, [], _HTMLTableComponent);

          if (shadow) {
            // Create shadow root...
            shadowRoot = self.attachShadow({
              mode: 'open'
            }); // Append to shadow root...

            shadowRoot.appendChild(table); // Create a node from the template function, and append to shadowRoot....

            Table._appendStyleNode(shadowRoot, template);
          } // Return constructor...


          return self;
        }; // Add superclass prototype...


        _HTMLTableComponent.prototype = Object.create(HTMLTableElement.prototype); // Add constructor...

        _HTMLTableComponent.prototype.constructor = _HTMLTableComponent; // Register event listener methods..

        _Events__WEBPACK_IMPORTED_MODULE_2__["Events"].registerCallbacks(_HTMLTableComponent, eListeners); // console.dir(HTMLComponent)
        // Add connectedCallback method appending children if shadow is false...


        if (!shadow) {
          _HTMLTableComponent.prototype.connectedCallback = function () {
            self.appendChild(table);
          };
        } // Return component to the caller...


        return _HTMLTableComponent;
      }
    }]);

    return Table;
  }();

  _defineProperty(Table, "_tempLiteral", ":host {\n\n                        }");
  /***/

},
/* 186 */

/***/
function (module, __webpack_exports__, __webpack_require__) {
  ;

  __webpack_require__.r(__webpack_exports__);
  /* harmony export (binding) */


  __webpack_require__.d(__webpack_exports__, "Textarea", function () {
    return Textarea;
  });
  /* harmony import */


  var _Utilities_helpers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(4);
  /* harmony import */


  var _Utilities_data__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(5);
  /* harmony import */


  var _Events__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(37);
  /* harmony import */


  var _CSS__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(43);
  /* harmony import */


  var _Form_Node__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(35);

  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  function _defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    return Constructor;
  }

  function _defineProperty(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }

    return obj;
  }
  /*
  ** Textarea.js
  **
  ** Textarea.js is an extensible HTML5 Web Component wrapper, built around the Textarea
  ** element. It's aim is in providing an textarea element that is able to be
  ** extended via the v1 web components api...
  **
  ** Eric James Foster, Fostware LLC, MIT License.
  ***/
  // Get utilities...
  // Get data...
  // Get Events...
  // Get CSS...
  // Get Node class...
  // Globalize common utility functions...


  var dir = console.dir;
  var log = _Utilities_helpers__WEBPACK_IMPORTED_MODULE_0__["log"];
  var el = _Utilities_helpers__WEBPACK_IMPORTED_MODULE_0__["el"];
  var dom = _Utilities_helpers__WEBPACK_IMPORTED_MODULE_0__["dom"];

  var Textarea =
  /*#__PURE__*/
  function () {
    function Textarea() {
      _classCallCheck(this, Textarea);
    }

    _createClass(Textarea, null, [{
      key: "_appendStyleNode",
      // A CSS template literal, holding default styles for an textarea...
      // Static method for appending child nodes to parent elements...
      value: function _appendStyleNode(root, child) {
        return root.appendChild(_Form_Node__WEBPACK_IMPORTED_MODULE_4__["Node"].createNode(child()));
      } // Static method for defining a flare textarea element...

    }, {
      key: "createComponent",
      value: function createComponent() {
        var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        var template = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false; // log('props', ['orange', 'bold'])
        // dir(props)
        // Declarations..

        var _HTMLTextareaComponent,
            eListeners = [],
            customProps = [],
            shadowBool,
            shadow = props.shadow,
            textarea,
            self,
            obj;
        /* Doing some finaglery with the native-shim and HTMLElement object.  This will
        be necessary until web components are fully supported in all browsers... */


        window.useNativeShim = false;
        window.HTMLElement = window._HTMLElement; // Get attribute names and Listeners...

        if (props) {
          obj = _Utilities_helpers__WEBPACK_IMPORTED_MODULE_0__["processData"](_Utilities_helpers__WEBPACK_IMPORTED_MODULE_0__["propsArray"](props)); // Store attribute and Listener pairs...

          customProps = obj.props;
          eListeners = obj.eventListeners;
        } // Create an HTMLTextareaElement...


        textarea = document.createElement('textarea'); // Some default settings for textarea elements...
        // Set flare identifier flag..

        textarea.flare = true; // Pass props from flare component declaration on to the inner textarea el...

        for (var _i = 0, _Object$keys = Object.keys(props); _i < _Object$keys.length; _i++) {
          var key = _Object$keys[_i]; // Check all keys in textarea el object...

          if (key in textarea) {
            // Pass on the ones that match...
            // log(`${key} in textarea`, ['yellow', 'bold'])
            textarea["".concat(key)] = props["".concat(key)]; // Or if they are style properties...,
          } else if (key in textarea.style) {
            // log(`${key} in textarea`, ['pink', 'bold'])
            // Put them here...
            textarea.style["".concat(key)] = props["".concat(key)];
          }
        } // Check for 'content' attribute,


        if ('content' in props) {
          textarea.textContent = props.content; // textarea.style.margin = '5'
        } // The textarea component element's constructor definition...


        _HTMLTextareaComponent = function HTMLTextareaComponent() {
          var shadowRoot; // Construct an element, store as self...

          self = Reflect.construct(HTMLElement, [], _HTMLTextareaComponent);

          if (shadow) {
            // Create shadow root...
            shadowRoot = self.attachShadow({
              mode: 'open'
            }); // Append to shadow root...

            shadowRoot.appendChild(textarea); // Create a node from the template function, and append to shadowRoot....

            Textarea._appendStyleNode(shadowRoot, template);
          } // Return constructor...


          return self;
        }; // Add superclass prototype...


        _HTMLTextareaComponent.prototype = Object.create(HTMLTextareaElement.prototype); // Add constructor...

        _HTMLTextareaComponent.prototype.constructor = _HTMLTextareaComponent; // Register event listener methods..

        _Events__WEBPACK_IMPORTED_MODULE_2__["Events"].registerCallbacks(_HTMLTextareaComponent, eListeners); // console.dir(HTMLComponent)
        // Add connectedCallback method appending children if shadow is false...


        if (!shadow) {
          _HTMLTextareaComponent.prototype.connectedCallback = function () {
            self.appendChild(textarea);
          };
        } // Return component to the caller...


        return _HTMLTextareaComponent;
      }
    }]);

    return Textarea;
  }();

  _defineProperty(Textarea, "_tempLiteral", ":host {\n\n                        }");
  /***/

},
/* 187 */

/***/
function (module, __webpack_exports__, __webpack_require__) {
  ;

  __webpack_require__.r(__webpack_exports__);
  /* harmony export (binding) */


  __webpack_require__.d(__webpack_exports__, "Errors", function () {
    return Errors;
  });
  /* harmony import */


  var _MountingError__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(188);
  /* harmony import */


  var _UnmountError__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(189);
  /* harmony import */


  var _UpdateError__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(190);

  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  function _defineProperty(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }

    return obj;
  }
  /*
  Errors.js
  
  Valence.js, a JavaScript library for building UI's with an API
  resembling that of React, but uses Vanilla JS Web components
  under the hood...This file deals with the framework's custom
  error handling...
  
  Eric James Foster, MIT License.
  */
  // Include custom errors...


  var Errors = function Errors() {
    _classCallCheck(this, Errors);
  };

  _defineProperty(Errors, "MountingFailure", _MountingError__WEBPACK_IMPORTED_MODULE_0__["MountingError"].Failure);

  _defineProperty(Errors, "UnknownMounting", _MountingError__WEBPACK_IMPORTED_MODULE_0__["MountingError"].Unknown);

  _defineProperty(Errors, "NoMountedUnmount", _UnmountError__WEBPACK_IMPORTED_MODULE_1__["UnmountError"].NoComponentMounted);

  _defineProperty(Errors, "UnknownUnmount", _UnmountError__WEBPACK_IMPORTED_MODULE_1__["UnmountError"].Unknown);

  _defineProperty(Errors, "UpdateFailure", _UpdateError__WEBPACK_IMPORTED_MODULE_2__["UpdateError"].Failure);

  _defineProperty(Errors, "UnknownUpdate", _UpdateError__WEBPACK_IMPORTED_MODULE_2__["UpdateError"].Unknown);
  /***/

},
/* 188 */

/***/
function (module, __webpack_exports__, __webpack_require__) {
  ;

  __webpack_require__.r(__webpack_exports__);
  /* harmony export (binding) */


  __webpack_require__.d(__webpack_exports__, "MountingError", function () {
    return MountingError;
  });

  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  function _defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    return Constructor;
  }
  /*
  MountingError.js
  
  Valence.js, a JavaScript library for building UI's with an API
  resembling that of React, but uses Vanilla JS Web components
  under the hood...This file contains the framework's custom
  MountingError...
  
  Eric James Foster, MIT License.
  */


  var MountingError =
  /*#__PURE__*/
  function () {
    function MountingError() {
      _classCallCheck(this, MountingError);
    }

    _createClass(MountingError, null, [{
      key: "Failure",
      // A custom error, thrown when a component fails to mount properly...
      get: function get() {
        // Return new error...
        return new Error('MountingError: There is no component mounted.');
      } // A custom error, thrown when there is an unknown error during the mounting process...

    }, {
      key: "Unknown",
      get: function get() {
        // Return new error...
        return new Error('MountingError: There was an unknown error during the mounting process.');
      }
    }]);

    return MountingError;
  }();
  /***/

},
/* 189 */

/***/
function (module, __webpack_exports__, __webpack_require__) {
  ;

  __webpack_require__.r(__webpack_exports__);
  /* harmony export (binding) */


  __webpack_require__.d(__webpack_exports__, "UnmountError", function () {
    return UnmountError;
  });

  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  function _defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    return Constructor;
  }
  /*
  UnountingError.js
  
  Valence.js, a JavaScript library for building UI's with an API
  resembling that of React, but uses Vanilla JS Web components
  under the hood...This file contains the framework's custom
  MountingError...
  
  Eric James Foster, MIT License.
  */


  var UnmountError =
  /*#__PURE__*/
  function () {
    function UnmountError() {
      _classCallCheck(this, UnmountError);
    }

    _createClass(UnmountError, null, [{
      key: "NoComponentMounted",
      // A custom error, thrown when an unmounted component is attempted to unmount...
      get: function get() {
        // Return new error...
        return new Error('UnmountError: There is no component mounted.');
      } // A custom error, thrown when there is an unknown error during the umount process...

    }, {
      key: "Unknown",
      get: function get() {
        // Return new error...
        return new Error('UnmountError: There was an unknown error during the unmount process.');
      }
    }]);

    return UnmountError;
  }();
  /***/

},
/* 190 */

/***/
function (module, __webpack_exports__, __webpack_require__) {
  ;

  __webpack_require__.r(__webpack_exports__);
  /* harmony export (binding) */


  __webpack_require__.d(__webpack_exports__, "UpdateError", function () {
    return UpdateError;
  });

  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  function _defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    return Constructor;
  }
  /*
  UpdateError.js
  
  Valence.js, a JavaScript library for building UI's with an API
  resembling that of React, but uses Vanilla JS Web components
  under the hood...This file contains the framework's custom
  UpdateError...
  
  Eric James Foster, MIT License.
  */


  var UpdateError =
  /*#__PURE__*/
  function () {
    function UpdateError() {
      _classCallCheck(this, UpdateError);
    }

    _createClass(UpdateError, null, [{
      key: "Failure",
      // A custom error, thrown when a component fails to update properly...
      get: function get() {
        // Return new error...
        return new Error('UpdateError: The component update failed.');
      } // A custom error, thrown when there is an unknown error during the mounting process...

    }, {
      key: "Unknown",
      get: function get() {
        // Return new error...
        return new Error('UpdateError: There was an unknown error during the update process.');
      }
    }]);

    return UpdateError;
  }();
  /***/

},
/* 191 */

/***/
function (module, __webpack_exports__, __webpack_require__) {
  ;

  __webpack_require__.r(__webpack_exports__);
  /* harmony import */


  var _Component__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(40);
  /* harmony import */


  var _Utilities_Loggers__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(33);
  /* harmony import */


  var _Utilities_DOM_classList__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(192);
  /* harmony import */


  var _btnStyles__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(193);

  function _typeof(obj) {
    if (typeof Symbol === "function" && _typeof2(Symbol.iterator) === "symbol") {
      _typeof = function _typeof(obj) {
        return _typeof2(obj);
      };
    } else {
      _typeof = function _typeof(obj) {
        return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : _typeof2(obj);
      };
    }

    return _typeof(obj);
  }

  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  function _defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    return Constructor;
  }

  function _possibleConstructorReturn(self, call) {
    if (call && (_typeof(call) === "object" || typeof call === "function")) {
      return call;
    }

    return _assertThisInitialized(self);
  }

  function _assertThisInitialized(self) {
    if (self === void 0) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }

    return self;
  }

  function _getPrototypeOf(o) {
    _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
      return o.__proto__ || Object.getPrototypeOf(o);
    };
    return _getPrototypeOf(o);
  }

  function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function");
    }

    subClass.prototype = Object.create(superClass && superClass.prototype, {
      constructor: {
        value: subClass,
        writable: true,
        configurable: true
      }
    });
    if (superClass) _setPrototypeOf(subClass, superClass);
  }

  function _setPrototypeOf(o, p) {
    _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
      o.__proto__ = p;
      return o;
    };

    return _setPrototypeOf(o, p);
  }
  /*
  ** Button.js
  **
  ** This file contains a customizable button component, for use with the
  ** Valence framework.
  **
  ** Eric James Foster, Fostware LLC, MIT License.
  ***/
  // imports...
  // import on from '../Utilities/DOM/events'
  // import el from '../Utilities/DOM/events'
  // Get Component styles...
  // Component Props....


  var btnProps = {
    name: {
      type: String,
      "default": null
    },
    href: {
      type: String,
      "default": false
    },
    to: {
      type: String,
      "default": '#'
    },
    // Gives the button focus upon page load...
    autofocus: {
      type: Boolean,
      "default": false
    },
    // Gives a button full width of parent...
    block: {
      type: Boolean,
      "default": false
    },
    disabled: {
      type: Boolean,
      "default": false
    },
    // Gives a button one of 3 default sizes, `sm`, `md`, and `lg`.....
    size: {
      type: String,
      "default": 'md'
    },

    /* Decides the semantic purpose of the button. Options are: 'primary' & 'outline-primary'
    'secondary' & 'outline-secondary', 'success' & 'outline-success', 'danger' & 'outline-danger'
    'warning & 'outline-warning, 'info' & 'outline-info', 'light' & 'outline-light', 'dark' &
    'outline-dark' and 'link'*/
    variant: {
      type: String,
      "default": 'outline-primary'
    },
    // Options are 'button', 'submit' & 'reset'...
    type: {
      type: String,
      "default": 'button'
    },
    // Options are: 'input', 'a' & 'button'...
    tag: {
      type: String,
      "default": 'button'
    },
    // Specifies an initial value for the button...
    value: {
      type: String,
      "default": null
    },
    // three state prop: true, false or null
    // on, off, (null) not a toggle
    pressed: {
      type: Boolean,
      "default": null // Define Component......

    }
  };

  var Button =
  /*#__PURE__*/
  function (_ValenceComponent) {
    _inherits(Button, _ValenceComponent); // Ctor...


    function Button() {
      var _this;

      _classCallCheck(this, Button); // Extended classes must include call to super() in ctor..


      _this = _possibleConstructorReturn(this, _getPrototypeOf(Button).call(this)); // Declare state...

      _this.state = {
        pressed: null /// Create shadowRoot with a slot....

      };
      shadowRoot = _this.shadowCaster({
        mode: 'open',
        slot: true
      }); // Attach styles to shadowRoot....

      _this.addStyles(shadowRoot, _btnStyles__WEBPACK_IMPORTED_MODULE_3__["default"]); // Register props on element ...


      _this.registerProps(btnProps); // Events....


      _this.onfocus = function () {
        _this.addClass('focus');
      };

      _this.onblur = function () {
        _this.removeClass('focus');
      };

      return _this;
    } // A class method for toggling button state...


    _createClass(Button, [{
      key: "toggleState",
      value: function toggleState(state) {
        return !state;
      } /// An instance method for updating element props with user defined props....

    }, {
      key: "_applyUserProps",
      value: function _applyUserProps() {
        for (var _i = 0, _Object$keys = Object.keys(this.props); _i < _Object$keys.length; _i++) {
          var prop = _Object$keys[_i];

          if (prop in this) {
            this[prop] = this.props[prop];
          }
        }
      } // onChange() {
      //   log('<<<<<<<[][][][][][]ONCHANGE[][][][]][][][]>>>>>>>', ['yellow', 'orange'])
      // }

      /* This method allows any needed changes to the component to be made once the
      element is appended to the DOM */

    }, {
      key: "componentDidMount",
      value: function componentDidMount() {
        var _this2 = this; /// Update element props with user defined props....


        this._applyUserProps(); // Set the tab index to make it focusable....


        this.tabIndex = -1; // Do prop related configurations...

        if (this.autofocus) {
          this.focus();
        }

        if (this.block) {
          this.addClass('btn-block');
        }

        if (this.disabled) {
          this.addClass('disabled');
        }

        if (this.size) {
          this.addClass("btn-".concat(this.size));
        }

        if (this.variant) {
          this.addClass(this.variant);
        }

        if (this.pressed !== this.state.pressed) {
          this.toggleState(this.pressed); // this.setState({pressed: })
        }

        if (this.href !== '#') {
          this.onclick = function (e) {// window.location = this.props.href
          };
        }

        if (this.to !== '#') {
          this.onclick = function (e) {
            window.location = _this2.href;
          };
        }

        if (this.type === 'submit') {}
      }
      /* This method allows any needed changes to the component to be made when attribute
      values change....  */

    }, {
      key: "onChange",
      value: function onChange() {} // End of Class

    }]);

    return Button;
  }(_Component__WEBPACK_IMPORTED_MODULE_0__["default"]); // Define the button component according to the v1 custom elements spec....
  // window.customElements.define('button-', Button)
  // Say Goodbye:)

  /* harmony default export */


  __webpack_exports__["default"] = Button;
  /***/
},
/* 192 */

/***/
function (module, __webpack_exports__, __webpack_require__) {
  ;

  __webpack_require__.r(__webpack_exports__);
  /* harmony export (binding) */


  __webpack_require__.d(__webpack_exports__, "addClass", function () {
    return addClass;
  });
  /* harmony export (binding) */


  __webpack_require__.d(__webpack_exports__, "removeClass", function () {
    return removeClass;
  });
  /* harmony export (binding) */


  __webpack_require__.d(__webpack_exports__, "listContains", function () {
    return listContains;
  });
  /* harmony export (binding) */


  __webpack_require__.d(__webpack_exports__, "replaceClass", function () {
    return replaceClass;
  });
  /*
  ** classList.js
  **
  ** classList.js has a few helper funcs for interacting with an element's
  ** classList in a little bit more of a direct way.
  **
  ** Eric James Foster, Fostware LLC, MIT License.
  ***/
  // Add a class to an el's class list...


  var addClass = function addClass(el, _class) {
    return el.classList.add(_class);
  }; // Remove a class to an el's class list...


  var removeClass = function removeClass(el, _class) {
    return el.classList.remove(_class);
  }; // Confirm the existance of a class in an el's class list....


  var listContains = function listContains(el, _class) {
    return el.classList.contains(_class);
  }; // Replace a class with a new one in an el's class list...


  var replaceClass = function replaceClass(el, oldie, newie) {
    return el.classList.replace(oldie, newie);
  };
  /***/

},
/* 193 */

/***/
function (module, __webpack_exports__, __webpack_require__) {
  ;

  __webpack_require__.r(__webpack_exports__);
  /* harmony import */


  var _Flare_Flare__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(167);

  function _templateObject() {
    var data = _taggedTemplateLiteral([" {\n      display: inline-block;\n      font-family: sf mono;\n      font-size: 20px;\n      text-align: center;\n      vertical-align: middle;\n      cursor: pointer;\n      color: white;\n      background: transparent;\n      border: 1px solid white;\n      border-radius: 5px;\n      padding: 12px;\n      margin: 5px;\n\n      &(:hover) {\n        background: tomato;\n        text-decoration: none;\n      }\n\n      &.focus {\n        border: 1px solid tomato;\n        color: tomato;\n        background: white;\n      }\n\n      &(:active) {\n        border: 1px solid tomato;\n        color: tomato;\n        background: white;\n      }\n\n      &(.disabled),\n      &(:disabled) {\n        opacity: .4;\n        pointer-events: none;\n      }\n\n      &(.btn-block) {\n        display: block;\n        width: 100%;\n\n        + .btn-block {\n          margin-top: 20px;\n        }\n      }\n\n      &(.btn-lg) {\n        font-size: 24px;\n        padding: 20px;\n      }\n      &(.btn-sm) {\n        font-size: 16px;\n        padding: 5px;\n        border-radius: 3px;\n      }\n\n      &(.primary) {\n        background: ", ";\n        color: white;\n        border: 1px solid ", ";\n      }\n      &(.primary:hover) {\n        box-shadow: 10px 10px 20px 20px ", " inset;\n      }\n      &(.primary:active) {\n        box-shadow: 10px 10px 20px 20px ", " inset;\n      }\n      &(.primary:focus) {\n        outline: none !important;\n        box-shadow: 0px 0px 2px 3px ", ";\n      }\n\n      &(.outline-primary) {\n        background: transparent;\n        color: ", ";\n        border: 1px solid ", ";\n      }\n      &(.outline-primary:hover) {\n        background: ", ";\n        color: white;\n        box-shadow: 10px 10px 20px 20px ", " inset;\n      }\n      &(.outline-primary:active) {\n        color: white;\n        box-shadow: 10px 10px 20px 20px ", " inset;\n      }\n      &(.outline-primary:focus) {\n        outline: none !important;\n        box-shadow: 0px 0px 2px 3px ", ";\n      }\n\n      &(.secondary) {\n        background: ", ";\n        color: white;\n        border: 1px solid ", ";\n      }\n      &(.secondary:hover) {\n        color: white;\n        box-shadow: 10px 10px 20px 20px ", " inset;\n      }\n      &(.secondary:active) {\n        color: white;\n        box-shadow: 10px 10px 20px 20px ", " inset;\n      }\n      &(.secondary:focus) {\n        outline: none !important;\n        box-shadow: 0px 0px 2px 3px ", ";\n      }\n\n      &(.outline-secondary) {\n        background: transparent;\n        color: ", ";\n        border: 1px solid ", ";\n      }\n      &(.outline-secondary:hover) {\n        background: ", ";\n        color: white;\n        box-shadow: 10px 10px 20px 20px ", " inset;\n      }\n      &(.outline-secondary:active) {\n        color: white;\n        box-shadow: 10px 10px 20px 20px ", " inset;\n      }\n      &(.outline-secondary:focus) {\n        outline: none !important;\n        box-shadow: 0px 0px 2px 3px ", ";\n      }\n\n      &(.success) {\n        background: ", ";\n        color: white;\n        border: 1px solid ", ";\n      }\n      &(.success:hover) {\n        box-shadow: 10px 10px 20px 20px ", " inset;\n      }\n      &(.success:active) {\n        box-shadow: 10px 10px 20px 20px ", " inset;\n      }\n      &(.success:focus) {\n        outline: none !important;\n        box-shadow: 0px 0px 2px 3px ", ";\n      }\n\n      &(.outline-success) {\n        background: transparent;\n        color: ", ";\n        border: 1px solid ", ";\n      }\n      &(.outline-success:hover) {\n        background: ", ";\n        color: white;\n        box-shadow: 10px 10px 20px 20px ", " inset;\n      }\n      &(.outline-success:active) {\n        color: white;\n        box-shadow: 10px 10px 20px 20px ", " inset;\n      }\n      &(.outline-success:focus) {\n        outline: none !important;\n        box-shadow: 0px 0px 2px 3px ", ";\n      }\n\n      &(.danger) {\n        background: ", ";\n        color: white;\n        border: 1px solid ", ";\n      }\n      &(.danger:hover) {\n        box-shadow: 10px 10px 20px 20px ", " inset;\n      }\n      &(.danger:active) {\n        box-shadow: 10px 10px 20px 20px ", " inset;\n      }\n      &(.danger:focus) {\n        outline: none !important;\n        box-shadow: 0px 0px 2px 3px ", ";\n      }\n\n      &(.outline-danger) {\n        background: transparent;\n        color: ", ";\n        border: 1px solid ", ";\n      }\n      &(.outline-danger:hover) {\n        background: ", ";\n        color: white;\n        box-shadow: 10px 10px 20px 20px ", " inset;\n      }\n      &(.outline-danger:active) {\n        color: white;\n        box-shadow: 10px 10px 20px 20px ", " inset;\n      }\n      &(.outline-danger:focus) {\n        outline: none !important;\n        box-shadow: 0px 0px 2px 3px ", ";\n      }\n\n      &(.warning) {\n        background: ", ";\n        color: white;\n        border: 1px solid ", ";\n      }\n      &(.warning:hover) {\n        box-shadow: 10px 10px 20px 20px ", " inset;\n      }\n      &(.warning:active) {\n        box-shadow: 10px 10px 20px 20px ", " inset;\n      }\n      &(.warning:focus) {\n        outline: none !important;\n        box-shadow: 0px 0px 2px 3px ", ";\n      }\n\n      &(.outline-warning) {\n        background: transparent;\n        color: ", ";\n        border: 1px solid ", ";\n      }\n      &(.outline-warning:hover) {\n        background: ", ";\n        color: black;\n        box-shadow: 10px 10px 20px 20px ", " inset;\n      }\n      &(.outline-warning:active) {\n        color: black;\n        box-shadow: 10px 10px 20px 20px ", " inset;\n      }\n      &(.outline-warning:focus) {\n        outline: none !important;\n        box-shadow: 0px 0px 2px 3px ", ";\n      }\n\n      &(.info) {\n        background: ", ";\n        color: white;\n        border: 1px solid ", ";\n      }\n      &(.info:hover) {\n        box-shadow: 10px 10px 20px 20px ", " inset;\n      }\n      &(.info:active) {\n        box-shadow: 10px 10px 20px 20px ", " inset;\n      }\n      &(.info:focus) {\n        outline: none !important;\n        box-shadow: 0px 0px 2px 3px ", ";\n      }\n\n      &(.outline-info) {\n        background: transparent;\n        color: ", ";\n        border: 1px solid ", ";\n      }\n      &(.outline-info:hover) {\n        background: ", ";\n        color: white;\n        box-shadow: 10px 10px 20px 20px ", " inset;\n      }\n      &(.outline-info:active) {\n        color: white;\n        box-shadow: 10px 10px 20px 20px ", " inset;\n      }\n      &(.outline-info:focus) {\n        outline: none !important;\n        box-shadow: 0px 0px 2px 3px ", ";\n      }\n\n      &(.light) {\n        background: ", ";\n        color: black;\n        border: 1px solid ", ";\n      }\n      &(.light:hover) {\n        box-shadow: 10px 10px 20px 20px ", " inset;\n      }\n      &(.light:active) {\n        box-shadow: 10px 10px 20px 20px ", " inset;\n      }\n      &(.light:focus) {\n        outline: none !important;\n        box-shadow: 0px 0px 2px 3px ", ";\n      }\n\n      &(.outline-light) {\n        background: transparent;\n        color: ", ";\n        border: 1px solid ", ";\n      }\n      &(.outline-light:hover) {\n        background: ", ";\n        color: black;\n        box-shadow: 10px 10px 20px 20px ", " inset;\n      }\n      &(.outline-light:active) {\n        color: black;\n        box-shadow: 10px 10px 20px 20px ", " inset;\n      }\n      &(.outline-light:focus) {\n        outline: none !important;\n        box-shadow: 0px 0px 2px 3px ", ";\n      }\n\n      &(.dark) {\n        background: ", ";\n        color: white;\n        border: 1px solid ", ";\n      }\n      &(.dark:hover) {\n        box-shadow: 10px 10px 20px 20px ", " inset;\n      }\n      &(.dark:active) {\n        box-shadow: 10px 10px 20px 20px ", " inset;\n      }\n      &(.dark:focus) {\n        outline: none !important;\n        box-shadow: 0px 0px 2px 3px ", ";\n      }\n\n      &(.outline-dark) {\n        background: transparent;\n        color: ", ";\n        border: 1px solid ", ";\n      }\n      &(.outline-dark:hover) {\n        background: ", ";\n        color: white;\n        box-shadow: 10px 10px 20px 20px ", " inset;\n      }\n      &(.outline-dark:active) {\n        color: white;\n        box-shadow: 10px 10px 20px 20px ", " inset;\n      }\n      &(.outline-dark:focus) {\n        outline: none !important;\n        box-shadow: 0px 0px 2px 3px ", ";\n      }\n\n      &(.link) {\n        background: transparent;\n        color: ", ";\n        border: 1px solid transparent;\n      }\n      &(.link:hover) {\n        color: ", ";\n      }\n      &(.link:active) {\n        color: ", ";\n      }\n      &(.link:focus) {\n        outline: none !important;\n        box-shadow: 0px 0px 2px 3px ", ";\n      }\n\n    }\n\n    input[type=\"submit\"],\n    input[type=\"reset\"],\n    input[type=\"button\"] {\n      &.btn-block {\n        width: 100%;\n      }\n    }\n"]);

    _templateObject = function _templateObject() {
      return data;
    };

    return data;
  }

  function _taggedTemplateLiteral(strings, raw) {
    if (!raw) {
      raw = strings.slice(0);
    }

    return Object.freeze(Object.defineProperties(strings, {
      raw: {
        value: Object.freeze(raw)
      }
    }));
  }
  /*
  ** btnStyles.js
  **
  ** btnStyles.js contains the css template literal for the Button
  ** WebComponent...
  **
  ** Eric James Foster, Fostware LLC, MIT License.
  ***/
  // Color variables....


  var primary = '#3263cd';
  var primaryHover = '#2155cd';
  var primaryActive = '#1144cf';
  var primaryFocus = '#4486cd';
  var secondary = '#6c757d';
  var secondaryHover = '#5b646b';
  var secondaryActive = '#4a535a';
  var secondaryFocus = '#8e979f';
  var success = '#5a9400';
  var successHover = '#499411';
  var successActive = '#38a512';
  var successFocus = '#8dc733';
  var danger = '#dc3545';
  var dangerHover = '#dc2434';
  var dangerActive = '#dd1323';
  var dangerFocus = '#fe5767';
  var warning = '#f8b102';
  var warningHover = '#e7a001';
  var warningActive = '#d69000';
  var warningFocus = '#fce546';
  var info = '#16a2b8';
  var infoHover = '#05a2a6';
  var infoActive = '#02a184';
  var infoFocus = '#5ae6fb';
  var light = '#f8f9fa';
  var lightHover = '#e7e8e9';
  var lightActive = '#d6d7d8';
  var lightFocus = '#ffffff';
  var dark = '#343a40';
  var darkHover = '#313830';
  var darkActive = '#2d352d';
  var darkFocus = '#565656';
  var link = '#3263cd';
  var linkHover = '#2155cd';
  var linkActive = '#1144cf';
  var linkFocus = '#4486cd'; // Preconfigured styles for the button....

  var btnStyles = Object(_Flare_Flare__WEBPACK_IMPORTED_MODULE_0__["css"])(_templateObject(), primary, primary, primaryHover, primaryActive, primaryFocus, primary, primary, primaryHover, primaryHover, primaryActive, primaryFocus, secondary, secondary, secondaryHover, secondaryActive, secondaryFocus, secondary, secondary, secondaryHover, secondaryHover, secondaryActive, secondaryFocus, success, success, successHover, successActive, successFocus, success, success, successHover, successHover, successActive, successFocus, danger, danger, dangerHover, dangerActive, dangerFocus, danger, danger, dangerHover, dangerHover, dangerActive, dangerFocus, warning, warning, warningHover, warningActive, warningFocus, warning, warning, warningHover, warningHover, warningActive, warningFocus, info, info, infoHover, infoActive, infoFocus, info, info, infoHover, infoHover, infoActive, infoFocus, light, light, lightHover, lightActive, darkFocus, light, light, lightHover, lightHover, lightActive, darkFocus, dark, dark, darkHover, darkActive, darkFocus, dark, dark, darkHover, darkHover, darkActive, darkFocus, link, linkHover, linkActive, linkFocus);
  /* harmony default export */

  __webpack_exports__["default"] = btnStyles;
  /***/
},
/* 194 */

/***/
function (module, __webpack_exports__, __webpack_require__) {
  ;

  __webpack_require__.r(__webpack_exports__);
  /* harmony import */


  var _Component__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(40);
  /* harmony import */


  var _Utilities_Loggers__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(33);
  /* harmony import */


  var _Utilities_DOM_classList__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(192);
  /* harmony import */


  var _inputStyles__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(195);

  function _typeof(obj) {
    if (typeof Symbol === "function" && _typeof2(Symbol.iterator) === "symbol") {
      _typeof = function _typeof(obj) {
        return _typeof2(obj);
      };
    } else {
      _typeof = function _typeof(obj) {
        return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : _typeof2(obj);
      };
    }

    return _typeof(obj);
  }

  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  function _defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    return Constructor;
  }

  function _possibleConstructorReturn(self, call) {
    if (call && (_typeof(call) === "object" || typeof call === "function")) {
      return call;
    }

    return _assertThisInitialized(self);
  }

  function _assertThisInitialized(self) {
    if (self === void 0) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }

    return self;
  }

  function _getPrototypeOf(o) {
    _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
      return o.__proto__ || Object.getPrototypeOf(o);
    };
    return _getPrototypeOf(o);
  }

  function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function");
    }

    subClass.prototype = Object.create(superClass && superClass.prototype, {
      constructor: {
        value: subClass,
        writable: true,
        configurable: true
      }
    });
    if (superClass) _setPrototypeOf(subClass, superClass);
  }

  function _setPrototypeOf(o, p) {
    _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
      o.__proto__ = p;
      return o;
    };

    return _setPrototypeOf(o, p);
  }
  /*
  ** Input.js
  **
  ** Input.js is a WebComponent/Custom Element wrapper around the built-in
  ** HTML5 input element.. It has increased functionality, and built-in
  ** scoped styles....
  **
  ** Eric James Foster, Fostware LLC, MIT License.
  ***/
  // imports...
  // Get Loggers...
  // Get classList modifiers....
  // Get Component styles...
  // Input component's props....


  var inputProps = {
    name: {
      type: String,
      "default": null
    },
    placeholder: {
      type: String,
      "default": null
    },
    type: {
      type: String,
      "default": 'text'
    },
    label: {
      type: String,
      "default": null
    },
    labelMod: {
      type: String,
      "default": 'top'
    },
    styles: {
      type: String,
      "default": null
    },
    disabled: {
      type: Boolean,
      "default": false
    },
    autocomplete: {
      type: String,
      "default": 'on'
    },
    autofocus: {
      type: Boolean,
      "default": false
    },
    required: {
      type: Boolean,
      "default": false
    },
    form: {
      type: String,
      "default": null
    },
    size: {
      type: String,
      "default": 'md'
    },
    state: {
      type: [String, Boolean],
      "default": null
    },
    value: {
      type: String,
      "default": null
    },
    readonly: {
      type: Boolean,
      "default": false
    },
    number: {
      type: Boolean,
      "default": false
    },
    list: {
      type: Boolean,
      "default": false
    }
  };

  var Input =
  /*#__PURE__*/
  function (_ValenceComponent) {
    _inherits(Input, _ValenceComponent); // Ctor...


    function Input() {
      var _this;

      _classCallCheck(this, Input);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(Input).call(this)); // Create a shadow-root with a slot for user markup...

      var shadowRoot = _this.shadowCaster({
        mode: 'open',
        slot: true
      }); // Create and append, an <input> el...


      var input = document.createElement('input'),
          label; // Pass props component declaration on to the inner input el...

      for (var _i = 0, _Object$keys = Object.keys(_this.props); _i < _Object$keys.length; _i++) {
        var key = _Object$keys[_i]; // Check all keys in input el object...

        if (key in input) {
          // Pass on the ones that match...
          // log(`${key} in input`, ['yellow', 'bold'])
          input["".concat(key)] = _this.props["".concat(key)]; // Or if they are style properties...,
        } else if (key in input.style) {
          // log(`${key} in input`, ['pink', 'bold'])
          // Put them here...
          input.style["".concat(key)] = _this.props["".concat(key)];
        }
      }

      if (_this.props.label) {
        // Create a span for text spatial manipulation....
        label = document.createElement('span');
        label.append(_this.props.label); // Check label modifier....

        if (_this.props.labelMod) {
          Object(_Utilities_DOM_classList__WEBPACK_IMPORTED_MODULE_2__["addClass"])(label, "label-".concat(_this.props.labelMod));
          Object(_Utilities_DOM_classList__WEBPACK_IMPORTED_MODULE_2__["addClass"])(input, "label-".concat(_this.props.labelMod)); // Append label and input to root....

          if (_this.props.labelMod === 'left' || _this.props.labelMod === 'top-right') {
            shadowRoot.appendChild(label);
            shadowRoot.appendChild(input);
          } else if (_this.props.labelMod === 'right' || _this.props.labelMod.indexOf('bottom') !== -1) {
            shadowRoot.appendChild(input);
            shadowRoot.appendChild(label);
          }
        }
      } // Apply styles to the component via the shadow-root....


      if (_this.props.styles) {
        _this.addStyles(shadowRoot, "".concat(_inputStyles__WEBPACK_IMPORTED_MODULE_3__["default"], "\n         ").concat(_this.processStyles(_this.props.styles)));
      } else {
        _this.addStyles(shadowRoot, _inputStyles__WEBPACK_IMPORTED_MODULE_3__["default"]);
      } // Register the component's prop object...


      _this.registerProps(inputProps);

      return _this;
    } // Completing any component post-mounting work here...


    _createClass(Input, [{
      key: "componentDidMount",
      value: function componentDidMount() {
        // Update element props with user defined props....
        this.applyUserProps(this.observedAttributes);
      } // Defining the props Callback to apply user-defined prop settings to the component...

    }, {
      key: "onChange",
      value: function onChange(props) {
        Object(_Utilities_Loggers__WEBPACK_IMPORTED_MODULE_1__["_log"])('&&&&&&&&&&&&&&&&&&&&&&onChange&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&');
        dir(this);
        dir(this.props);
        dir(props);
      }
    }]);

    return Input;
  }(_Component__WEBPACK_IMPORTED_MODULE_0__["default"]);
  /* harmony default export */


  __webpack_exports__["default"] = Input;
  /***/
},
/* 195 */

/***/
function (module, __webpack_exports__, __webpack_require__) {
  ;

  __webpack_require__.r(__webpack_exports__);
  /* harmony import */


  var _Flare_Flare__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(167);

  function _templateObject() {
    var data = _taggedTemplateLiteral([" {\n    --size: 20px;\n    display: block;\n    padding: 0px;\n    padding-top: 0px;\n    padding-bottom: 40px;\n    background: blue;\n    font-family: hermit;\n    font-size: calc(var(--size) / 2);\n    height: var(--size);\n    width: 1200px;\n\n    input {\n      width: 85%;\n      height: 100%;\n      margin-top: 5px;\n      font-family: hermit;\n      font-size: calc(var(--size) * .8);\n      border: none;\n      border-radius: 5px;\n      background: yellow;\n    }\n\n    > input.label-left {\n      display: inline-block;\n      width: 75%;\n      margin-left: 10px;\n    }\n\n    > input.label-right {\n      display: inline-block;\n      width: 75%;\n      margin-right: 10px;\n    }\n\n    > input.label-bottom {\n      margin-bottom: 10px;\n    }\n\n    > span.label-left,\n      span.label-right {\n        display: inline-block;\n    }\n\n    > span.label-bottom-right,\n      span.label-top-right {\n      float: right;\n    }\n  }\n"]);

    _templateObject = function _templateObject() {
      return data;
    };

    return data;
  }

  function _taggedTemplateLiteral(strings, raw) {
    if (!raw) {
      raw = strings.slice(0);
    }

    return Object.freeze(Object.defineProperties(strings, {
      raw: {
        value: Object.freeze(raw)
      }
    }));
  }
  /*
  ** inputStyles.js
  **
  ** inputStyles.js contains the css template literal for the Input
  ** WebComponent...
  **
  ** Eric James Foster, Fostware LLC, MIT License.
  ***/
  // Get css ...


  var inputStyles = Object(_Flare_Flare__WEBPACK_IMPORTED_MODULE_0__["css"])(_templateObject());
  /* harmony default export */

  __webpack_exports__["default"] = inputStyles;
  /***/
},
/* 196 */

/***/
function (module, __webpack_exports__, __webpack_require__) {
  ;

  __webpack_require__.r(__webpack_exports__);
  /* harmony import */


  var _Component__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(40);
  /* harmony import */


  var _Flare_Flare__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(167);
  /* harmony import */


  var _Utilities_Loggers__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(33);
  /* harmony import */


  var _Utilities_DOM_classList__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(192);

  function _typeof(obj) {
    if (typeof Symbol === "function" && _typeof2(Symbol.iterator) === "symbol") {
      _typeof = function _typeof(obj) {
        return _typeof2(obj);
      };
    } else {
      _typeof = function _typeof(obj) {
        return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : _typeof2(obj);
      };
    }

    return _typeof(obj);
  }

  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  function _defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    return Constructor;
  }

  function _possibleConstructorReturn(self, call) {
    if (call && (_typeof(call) === "object" || typeof call === "function")) {
      return call;
    }

    return _assertThisInitialized(self);
  }

  function _getPrototypeOf(o) {
    _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
      return o.__proto__ || Object.getPrototypeOf(o);
    };
    return _getPrototypeOf(o);
  }

  function _assertThisInitialized(self) {
    if (self === void 0) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }

    return self;
  }

  function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function");
    }

    subClass.prototype = Object.create(superClass && superClass.prototype, {
      constructor: {
        value: subClass,
        writable: true,
        configurable: true
      }
    });
    if (superClass) _setPrototypeOf(subClass, superClass);
  }

  function _setPrototypeOf(o, p) {
    _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
      o.__proto__ = p;
      return o;
    };

    return _setPrototypeOf(o, p);
  }

  function _defineProperty(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }

    return obj;
  }

  function _templateObject() {
    var data = _taggedTemplateLiteral([" {\n    display: flex;\n    flex-wrap: wrap;\n    justify-content: flex-start;\n    background: blue;\n    padding: 15px 30px;\n    margin: auto;\n    width: 100%;\n\n    @media (max-width: 576px) {\n      max-width: 410px;\n    }\n\n    @media (min-width: 576px) {\n      max-width: 510px;\n    }\n\n    @media (min-width: 768px) {\n      max-width: 690px;\n    }\n\n    @media (min-width: 992px) {\n      max-width: 930px;\n    }\n\n    @media (min-width: 1200px) {\n      max-width: 1090px;\n    }\n\n    &(.vertical) {\n      flex-wrap: wrap;\n      justify-content: center;\n      align-items: center;\n    }\n\n    &(.fluid) {\n      width: 100%;\n    }\n\n  }\n"]);

    _templateObject = function _templateObject() {
      return data;
    };

    return data;
  }

  function _taggedTemplateLiteral(strings, raw) {
    if (!raw) {
      raw = strings.slice(0);
    }

    return Object.freeze(Object.defineProperties(strings, {
      raw: {
        value: Object.freeze(raw)
      }
    }));
  }
  /*
  ** Container.js
  **
  ** Container.js is a very simple Valence Component. A container of fixed-width
  ** that changes max-width at defined breaking points, or, with an optional
  ** `fluid` prop, remains at 100% at all times, changing with the width of it's
  ** parent...
  **
  ** Eric James Foster, Fostware LLC, MIT License.
  ***/
  // Get css ...
  // Get logger...
  // Get classlist manipulation...
  // Get Component styles...
  // import btnStyles from './btnStyles'


  var containerStyles = Object(_Flare_Flare__WEBPACK_IMPORTED_MODULE_1__["css"])(_templateObject()); // Component props....

  var containerProps = {
    fluid: {
      type: Boolean,
      "default": false
    },
    vertical: {
      type: Boolean,
      "default": false // Component class....

    }
  };

  var Container =
  /*#__PURE__*/
  function (_ValenceComponent) {
    _inherits(Container, _ValenceComponent); // Reference to stule element...
    // ctor


    function Container() {
      var _this;

      _classCallCheck(this, Container);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(Container).call(this)); // Add shadow root and slot for user markup...

      _defineProperty(_assertThisInitialized(_this), "_style", null);

      var shadowRoot = _this.shadowCaster(); // Attach styles to shadowRoot....


      _this._style = _this.addStyles(shadowRoot, containerStyles); /// Register the component's prop object...

      _this.registerProps(containerProps);

      return _this;
    } // Complete post mounting Component work here...


    _createClass(Container, [{
      key: "componentDidMount",
      value: function componentDidMount() {
        Object(_Utilities_Loggers__WEBPACK_IMPORTED_MODULE_2__["_log"])('#####################################-style-########################################', ['', '']);
        Object(_Utilities_Loggers__WEBPACK_IMPORTED_MODULE_2__["_log"])('');
        dir(this._style);
        dir(); /// Update element props with user defined props....

        this.applyUserProps(this.props);

        if (this.vertical) {
          this.addClass('vertical');
        }
      }
    }]);

    return Container;
  }(_Component__WEBPACK_IMPORTED_MODULE_0__["default"]);
  /* harmony default export */


  __webpack_exports__["default"] = Container;
  /***/
},
/* 197 */

/***/
function (module, __webpack_exports__, __webpack_require__) {
  ;

  __webpack_require__.r(__webpack_exports__);
  /* harmony import */


  var _Component__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(40);
  /* harmony import */


  var _Flare_Flare__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(167);
  /* harmony import */


  var _Utilities_Loggers__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(33);
  /* harmony import */


  var _Utilities_DOM_classList__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(192);
  /* harmony import */


  var _Utilities_Is__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(6);
  /* harmony import */


  var _Utilities_DOM_events__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(198);

  function _typeof(obj) {
    if (typeof Symbol === "function" && _typeof2(Symbol.iterator) === "symbol") {
      _typeof = function _typeof(obj) {
        return _typeof2(obj);
      };
    } else {
      _typeof = function _typeof(obj) {
        return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : _typeof2(obj);
      };
    }

    return _typeof(obj);
  }

  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  function _defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    return Constructor;
  }

  function _possibleConstructorReturn(self, call) {
    if (call && (_typeof(call) === "object" || typeof call === "function")) {
      return call;
    }

    return _assertThisInitialized(self);
  }

  function _getPrototypeOf(o) {
    _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
      return o.__proto__ || Object.getPrototypeOf(o);
    };
    return _getPrototypeOf(o);
  }

  function _assertThisInitialized(self) {
    if (self === void 0) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }

    return self;
  }

  function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function");
    }

    subClass.prototype = Object.create(superClass && superClass.prototype, {
      constructor: {
        value: subClass,
        writable: true,
        configurable: true
      }
    });
    if (superClass) _setPrototypeOf(subClass, superClass);
  }

  function _setPrototypeOf(o, p) {
    _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
      o.__proto__ = p;
      return o;
    };

    return _setPrototypeOf(o, p);
  }

  function _defineProperty(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }

    return obj;
  }

  function _templateObject2() {
    var data = _taggedTemplateLiteral(["\n  ::slotted(row-) {\n    justify-content: space-evenly;\n    align-items: stretch;\n    flex-wrap: nowrap;\n    background: blue;\n  }\n  ::slotted(column-) {\n    background: blue;\n  }"]);

    _templateObject2 = function _templateObject2() {
      return data;
    };

    return data;
  }

  function _templateObject() {
    var data = _taggedTemplateLiteral([" {\n    flex: 1;\n    background: #6c757d;\n    border: 1px solid #323232;\n    font-family: hermit;\n    font-size: 22px;\n    line-height: 66px;\n    text-align: center;\n\n  }\n"]);

    _templateObject = function _templateObject() {
      return data;
    };

    return data;
  }

  function _taggedTemplateLiteral(strings, raw) {
    if (!raw) {
      raw = strings.slice(0);
    }

    return Object.freeze(Object.defineProperties(strings, {
      raw: {
        value: Object.freeze(raw)
      }
    }));
  }
  /*
  ** Column.js
  **
  ** Column Components will hold the content in the grid system....
  **
  ** Eric James Foster, Fostware LLC, MIT License.
  ***/
  // Get css ...
  // Get logger...
  // Get classlist manipulation...
  // Get validation...
  // Get event listener method...
  // Component styles...


  var columnStyles = Object(_Flare_Flare__WEBPACK_IMPORTED_MODULE_1__["css"])(_templateObject());
  var userMarkupStyles = Object(_Flare_Flare__WEBPACK_IMPORTED_MODULE_1__["css"])(_templateObject2());
  var columnProps = {
    col: {
      type: Boolean,
      "default": false
    },
    cols: {
      type: Number,
      "default": null
    },
    xs: {
      type: [Boolean, String, Number],
      "default": false
    },
    sm: {
      type: [Boolean, String, Number],
      "default": false
    },
    md: {
      type: [Boolean, String, Number],
      "default": false
    },
    lg: {
      type: [Boolean, String, Number],
      "default": false
    },
    xl: {
      type: [Boolean, String, Number],
      "default": false
    },
    place: {
      type: String,
      "default": 'center'
    }
  };

  var Column =
  /*#__PURE__*/
  function (_ValenceComponent) {
    _inherits(Column, _ValenceComponent);
    /*
    *** Class variables ********
    **************************/
    // An instance property for this component's active col count....
    // An instance property for the component's style object...
    // An instance prop holding screen size breakpoints for layout changes....
    // An instance prop holding the devices screen width...
    // An instance prop holding the parent row's width...
    // _rowWidth = null
    // Ctor....


    function Column() {
      var _this;

      _classCallCheck(this, Column);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(Column).call(this)); // Add shadow root and slot for user markup...

      _defineProperty(_assertThisInitialized(_this), "_cols_", null);

      _defineProperty(_assertThisInitialized(_this), "_style", null);

      _defineProperty(_assertThisInitialized(_this), "_breakpoint", 0);

      _defineProperty(_assertThisInitialized(_this), "_screenWidth", null);

      var shadowRoot = _this.shadowCaster(); // Attach styles to shadowRoot....


      _this._style = _this.addStyles(shadowRoot, columnStyles); /// Register the component's prop object...

      _this.registerProps(columnProps);

      return _this;
    } // A privat Boolean instance prop, reflecting whether or not a _screenWidth breakpoint has been surpassed...


    _createClass(Column, [{
      key: "_set_cols",
      // An internal method for setting _cols according with screen size....
      value: function _set_cols(screenWidth) {
        // Using a switch to determine col size, based on _screenWidth and props given...
        switch (true) {
          case screenWidth < 576:
            if (this.xs) {
              return this.xs;
            } else if (screenWidth > this._breakpoint) {
              return this._breakCols;
            } else {
              return this.cols;
            }

            break;

          case screenWidth < 768:
            if (this.sm) {
              return this.sm;
            } else if (screenWidth > this._breakpoint) {
              return this._breakCols;
            } else {
              return this.cols;
            }

            break;

          case screenWidth < 992:
            if (this.md) {
              return this.md;
            } else if (screenWidth > this._breakpoint) {
              return this._breakCols;
            } else {
              return this.cols;
            }

            break;

          case screenWidth < 1200:
            if (this.lg) {
              return this.lg;
            } else if (screenWidth > this._breakpoint) {
              return this._breakCols;
            } else {
              return this.cols;
            }

            break;

          case screenWidth > 1200:
            if (this.xl) {
              return this.xl;
            } else if (screenWidth > this._breakpoint) {
              return this._breakCols;
            } else {
              return this.cols;
            }

            break;

          default:
            return this.cols;
        }
      } // A method for determining col value to use in setting flex-basis, and setting it...

    }, {
      key: "setFlexBasis",
      value: function setFlexBasis() {
        if (this._breakpoint) {
          this._cols_ = this._set_cols(this._screenWidth); // if (this._beyondBreakpoint) {
          //   this.parentNode.style.flexWrap = 'nowrap'
          // } else {
          //   this.parentNode.style.flexWrap = 'wrap'
          // }
        } else {
          this._cols_ = this.cols;
        } // Define basis...


        var flexBasis = this._cols_ / 12 * 100; // Check flag to be sure flex Basis is not already set on another col....

        this.style.flex = "0 0 ".concat(flexBasis, "%"); // this.style.maxWidth = `${flexBasis}%`
        // this.style.position = 'relative'
        // If flex basis is less than 100%, Set flag...
      }
    }, {
      key: "componentDidMount",
      value: function componentDidMount() {
        var _this2 = this; // Set _screenWidth...


        this._screenWidth = window.innerWidth; /// Update element props with user defined props....

        this.applyUserProps(this.props); // Check cols prop, and adjust width accordingly...

        if (this.cols || this.md || this.sm || this.lg || this.xl) {
          // Set breakpoint...
          var breakpointData = this.sm ? [576, this.sm] : this.md ? [768, this.md] : this.lg ? [992, this.lg] : this.xl ? [1200, this.xl] : false;
          this._breakpoint = breakpointData[0];
          this._breakCols = breakpointData[1]; // If we have a breakpoint, see if we are beyond it to determine the cols amount to use for determining length...

          this.setFlexBasis(); //Dynamic readjustment of the column's width....

          Object(_Utilities_DOM_events__WEBPACK_IMPORTED_MODULE_5__["default"])('resize', window, function (e) {
            // Reset _screenWidth...
            _this2._screenWidth = window.innerWidth; /// If we have a breakpoint, see if we are beyond it to determine the cols amount to use for determining length...

            _this2.setFlexBasis();
          });
        } // Check placement prop...


        if (this.place) {
          this.addClass(this.place);
        }

        this.insertRules(userMarkupStyles, this._style);
      }
    }, {
      key: "_beyondBreakpoint",
      get: function get() {
        if (this._screenWidth > this._breakpoint) {
          return true;
        } else {
          return false;
        }
      }
    }]);

    return Column;
  }(_Component__WEBPACK_IMPORTED_MODULE_0__["default"]);
  /* harmony default export */


  __webpack_exports__["default"] = Column; /// Class method for setting styles based on cols and breakpoint props...
  //   _setColWidths() {
  // // Set the width of the column...
  //     if (this._screenWidth >= this._breakpoint) {
  // // Remove wrapping functionality from the parent row...
  //       addClass(this.parentNode, 'no-wrap')
  // // Remove class 'wrap'...
  //       if (this.parentNode.classList.contains('wrap')) {
  //         removeClass(this.parentNode, 'wrap')
  //       }
  //       this.style.flex = this._cols
  //       this.style.flexBasis = ''
  //     } else {
  // // Add column wrapping functionality...
  //       addClass(this.parentNode, 'wrap')
  // // Remove 'no-wrap' class...
  //       if (this.parentNode.classList.contains('no-wrap')) {
  //         removeClass(this.parentNode, 'no-wrap')
  //       }
  //       this.style.flex = this._cols
  //       this.style.minWidth = ''
  //     }
  //   }

  /***/
},
/* 198 */

/***/
function (module, __webpack_exports__, __webpack_require__) {
  ;

  __webpack_require__.r(__webpack_exports__);
  /* harmony import */


  var _el__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(32);
  /*
  events.js
  
  This file contains the library convenience EventListener function.
  
  Author: Eric James Foster
  License: ISC
  */
  //Function for setting event listeners.


  var on = function on(event, elem, callback) {
    var domEl = Object(_el__WEBPACK_IMPORTED_MODULE_0__["default"])(elem); // Making sure we have addEventListener, in case of IE or Edge....

    if (document.addEventListener) {
      return elem.addEventListener(event, callback);
    } else {
      // For IE or Edge...
      return elem.attachEvent("on".concat(event), callback);
    }
  };
  /* harmony default export */


  __webpack_exports__["default"] = on;
  /***/
},
/* 199 */

/***/
function (module, __webpack_exports__, __webpack_require__) {
  ;

  __webpack_require__.r(__webpack_exports__);
  /* harmony import */


  var _Component__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(40);
  /* harmony import */


  var _Flare_Flare__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(167);
  /* harmony import */


  var _Utilities_Loggers__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(33);
  /* harmony import */


  var _Utilities_helpers__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(4);
  /* harmony import */


  var _Utilities_DOM_classList__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(192);
  /* harmony import */


  var _Utilities_convertCSSUnitToRealNumber__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(200);

  function _typeof(obj) {
    if (typeof Symbol === "function" && _typeof2(Symbol.iterator) === "symbol") {
      _typeof = function _typeof(obj) {
        return _typeof2(obj);
      };
    } else {
      _typeof = function _typeof(obj) {
        return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : _typeof2(obj);
      };
    }

    return _typeof(obj);
  }

  function _templateObject2() {
    var data = _taggedTemplateLiteral(["\n        ::slotted(col-),\n        ::slotted(column-) {\n          background: green;\n          margin-right: ", ";\n        }\n\n        ::slotted(:last-child) {\n          background: yellow;\n          margin: 0px;\n          flex: 1;\n        }\n\n        @media (min-width: 768px) {\n          ::slotted(col-),\n          ::slotted(column-) {\n            background: orange;\n            margin-right: ", ";\n          }\n        }"]);

    _templateObject2 = function _templateObject2() {
      return data;
    };

    return data;
  }

  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  function _defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    return Constructor;
  }

  function _possibleConstructorReturn(self, call) {
    if (call && (_typeof(call) === "object" || typeof call === "function")) {
      return call;
    }

    return _assertThisInitialized(self);
  }

  function _getPrototypeOf(o) {
    _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
      return o.__proto__ || Object.getPrototypeOf(o);
    };
    return _getPrototypeOf(o);
  }

  function _assertThisInitialized(self) {
    if (self === void 0) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }

    return self;
  }

  function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function");
    }

    subClass.prototype = Object.create(superClass && superClass.prototype, {
      constructor: {
        value: subClass,
        writable: true,
        configurable: true
      }
    });
    if (superClass) _setPrototypeOf(subClass, superClass);
  }

  function _setPrototypeOf(o, p) {
    _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
      o.__proto__ = p;
      return o;
    };

    return _setPrototypeOf(o, p);
  }

  function _defineProperty(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }

    return obj;
  }

  function _templateObject() {
    var data = _taggedTemplateLiteral([" {\n  display: flex;\n  flex: 1;\n  flex-wrap: wrap;\n  justify-content: flex-start;\n  min-width: 100%;\n  margin: 0 -15px;\n  background: red;\n\n  &(.align-top),\n  &(.align-start) {\n    align-content: flex-start;\n  }\n\n  &(.align-mid),\n  &(.align-middle),\n  &(.align-center) {\n    align-content: center;\n  }\n\n  &(.align-bottom),\n  &(.align-end) {\n    align-content: flex-end;\n  }\n\n  &(.justify-start),\n  &(.justify-beginning) {\n    justify-content: flex-start;\n  }\n\n  &(.justify-mid),\n  &(.justify-middle),\n  &(.justify-center) {\n    justify-content: center;\n  }\n\n  &(.justify-end),\n  &(.justify-beginning) {\n    justify-content: flex-start;\n  }\n\n  &(.justify-between),\n  &(.justify-space-between) {\n    justify-content: space-between;\n  }\n\n  &(.justify-around),\n  &(.justify-space-around) {\n    justify-content: space-around;\n  }\n\n  &(.justify-evenly),\n  &(.justify-space-evenly) {\n    justify-content: space-evenly;\n  }\n\n\n}\n"]);

    _templateObject = function _templateObject() {
      return data;
    };

    return data;
  }

  function _taggedTemplateLiteral(strings, raw) {
    if (!raw) {
      raw = strings.slice(0);
    }

    return Object.freeze(Object.defineProperties(strings, {
      raw: {
        value: Object.freeze(raw)
      }
    }));
  }
  /*
  ** Row.js
  **
  ** Row.js is part of the Grid-Layout system. It is a horizontal section
  ** that holds between 1 and 12 Columns or Cols.
  **
  ** Eric James Foster, Fostware LLC, MIT License.
  ***/
  // Get Valence...
  // Get Flare...
  // Get logger...
  // Get classlist manipulation...
  // Get Int parsing...
  // Component styles...


  var rowStyles = Object(_Flare_Flare__WEBPACK_IMPORTED_MODULE_1__["css"])(_templateObject()); // Component props....

  var rowProps = {
    gutters: {
      type: [Boolean, String],
      "default": '15px'
    },
    bumpers: {
      type: [Boolean, String],
      "default": null
    },
    align: {
      type: String,
      "default": 'center'
    },
    justify: {
      type: String,
      "default": 'space-evenly' // Component class....

    }
  };

  var Row =
  /*#__PURE__*/
  function (_ValenceComponent) {
    _inherits(Row, _ValenceComponent); // An instance variable holding a reference to the component's style sheet...
    // ctor


    function Row() {
      var _this;

      _classCallCheck(this, Row);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(Row).call(this)); // Add shadow root and slot for user markup...

      _defineProperty(_assertThisInitialized(_this), "_style", null);

      var shadowRoot = _this.shadowCaster();
      /* Attach styles to shadowRoot.... Set the style object on an instance var
       for access to the style sheet ...*/


      _this._style = _this.addStyles(shadowRoot, rowStyles); // Register the component's prop object...

      _this.registerProps(rowProps);

      return _this;
    } // Work to complete once component is mounted and props are applied....


    _createClass(Row, [{
      key: "componentDidMount",
      value: function componentDidMount() {
        // Update element props with user defined props....
        this.applyUserProps(this.props); // Check for `gutters` prop, and set padding accordingly...

        if (this.gutters) {
          // Remove unit from CSS string and parse int...
          var cssVal = Object(_Utilities_convertCSSUnitToRealNumber__WEBPACK_IMPORTED_MODULE_5__["default"])(this.gutters); // this.parentNode.style.padding = `15px ${this.gutters + 15}px`

          this.style.margin = "0px -".concat(cssVal, "px");
        } else {
          // this.parentNode.style.padding = '15px 15px'
          this.style.margin = "0px -30px";
        } // Check for `bumpers`...


        if (this.bumpers) {
          var style = Object(_Flare_Flare__WEBPACK_IMPORTED_MODULE_1__["css"])(_templateObject2(), this.bumpers, this.bumpers); //
          // if (this.gutters) {
          //   let style = css`
          //     ::slotted(col-),
          //     ::slotted(column-) {
          //       background: green;
          //       margin-right: ${this.bumpers};
          //     }
          // }
          // Insert the CSS literal into the component style sheet...

          this.insertRules(style, this._style);
        }
      }
    }]);

    return Row;
  }(_Component__WEBPACK_IMPORTED_MODULE_0__["default"]);
  /* harmony default export */


  __webpack_exports__["default"] = Row;
  /***/
},
/* 200 */

/***/
function (module, __webpack_exports__, __webpack_require__) {
  ;

  __webpack_require__.r(__webpack_exports__);
  /* harmony export (binding) */


  __webpack_require__.d(__webpack_exports__, "default", function () {
    return convertCSSUnitToRealNumber;
  });
  /*
  ** convertCSSUnitToRealNumber.js
  **
  ** convertCSSUnitToRealNumber.js is a helper function for converting a css value
  ** string, such as: '15px', to a real, usable number, like: 15.
  **
  ** Eric James Foster, Fostware LLC, MIT License.
  ***/


  var NUM_REG_EXP = /[0-9]/;

  function convertCSSUnitToRealNumber(val) {
    log('val');
    log(val); // Filter string for numbers....

    var numStringArr = val.split('').filter(function (_char) {
      return NUM_REG_EXP.test(_char);
    });
    log('numStringArr');
    dir(numStringArr);
    log(Number.parseInt(numStringArr.join(''))); // Rejoin number string and parse...

    return Number.parseInt(numStringArr.join(''));
  }
  /***/

},
/* 201 */

/***/
function (module, __webpack_exports__, __webpack_require__) {
  ;

  __webpack_require__.r(__webpack_exports__);
  /*
  ** valenceLogo.js
  **
  ** valenceLogo.js is svg markup of the valence.js logo.....
  **
  ** Eric James Foster, Fostware LLC, MIT License.
  ***/


  var valenceLogo = function valenceLogo() {
    return "<svg width=\"100%\" height=\"100%\" viewBox=\"0 0 700 700\" version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" xml:space=\"preserve\" style=\"fill-rule:evenodd;clip-rule:evenodd;stroke-linecap:round;stroke-linejoin:round;stroke-miterlimit:1.41421;\">\n    <g>\n      <ellipse cx=\"350\" cy=\"350\" rx=\"68.5\" ry=\"71.5\" style=\"fill:#f6bc00;stroke-width:4.5px;stroke:#f6bc00;\"/>\n      <g>\n        <ellipse cx=\"350\" cy=\"350\" rx=\"107\" ry=\"309.5\" style=\"fill:none;stroke-width:9px;stroke:#5670a5;\"/>\n        <circle cx=\"288.256\" cy=\"97.5\" r=\"23.5\" style=\"fill:#5670a5;stroke-width:4.5px;stroke:#5670a5;\"/>\n      </g>\n      <g>\n        <path d=\"M617.748,505.245c-29.622,51.089 -173.645,23.003 -321.419,-62.679c-147.775,-85.682 -243.699,-196.723 -214.077,-247.811c29.622,-51.089 173.645,-23.003 321.419,62.679c147.775,85.682 243.699,196.723 214.077,247.811Z\" style=\"fill:none;stroke-width:9px;stroke:#699d00;\"/>\n        <circle cx=\"599.449\" cy=\"422.5\" r=\"23.5\" style=\"fill:#699d00;stroke-width:4.5px;stroke:#699d00;\"/>\n      </g>\n      <g>\n        <path d=\"M618.99,196.917c29.21,51.325 -67.606,161.589 -216.066,246.078c-148.46,84.489 -292.705,111.414 -321.914,60.088c-29.21,-51.325 67.606,-161.589 216.066,-246.078c148.46,-84.489 292.705,-111.414 321.914,-60.088Z\" style=\"fill:none;stroke-width:9px;stroke:#c02d0c;\"/>\n        <circle cx=\"168.5\" cy=\"529.114\" r=\"23.5\" style=\"fill:#c02d0c;stroke-width:4.5px;stroke:#c02d0c;\"/>\n      </g>\n    </g>\n  </svg>";
  };
  /* harmony default export */


  __webpack_exports__["default"] = valenceLogo;
  /***/
}]);